//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var AstVisitor = require('./AstVisitor')

var CombeAst_AnalyseScoping = module.exports = AstVisitor.subclass('CombeAst_AnalyseScoping', {}, {
  
  initialize() {
    self.scopes = []
  }
  
  defaultVisitOrder: 'NoOrder',
  
  Script(ast) -> self.visitCreatingScope(ast),
  Block(ast) -> self.visitCreatingScope(ast),
  Rule(ast) -> self.visitCreatingScope(ast, true),
  visitCreatingScope(ast, hasSelf) {
    self.scopes.push(ast)
    ast.variables = []
    ast.declareVariables = []
    
    if (hasSelf) {
      ast.variables.push('self')
    }
    
    if (ast.parameters != null) {
      ast.variables.pushAll(ast.parameters.map((p) -> p.name))
    }
    
    self.visitChildren(ast)
    
    ast.variables.pushAll(ast.declareVariables)
    
    self.scopes.pop()
  }
  
  VariableDeclaration(ast) {
    assert(self.scopes.top.type === 'Block' ||
           self.scopes.top.type === 'Script')
           
    return self.visitDeclaringVariable(ast)
  }
  BindPattern(ast) {
    assert(self.scopes.top.type === 'Rule')
           
    return self.visitDeclaringVariable(ast)
  }
  visitDeclaringVariable(ast) {
    if (!self.scopes.last.variables.include(ast.name)) {
      self.scopes.last.declareVariables.pushIfAbsent(ast.name)
    }
    
    self.visitChildren(ast)
  }
  
  Variable(ast) {
    // Note: If I add a strict module system I could do checking here, although
    // that would require the ability to also 'declare' globals that you wish
    // to have access to.
  }
  
  VariablePattern(ast) {
    assert(self.scopes.top.type === 'Rule')
    
    ast.containingScope = self.scopes.top
  }
  
})
