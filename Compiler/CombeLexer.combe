//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var CombeLexer = module.exports = LexicalGrammar.subclass({}, {
  
  name: 'CombeLexer'
  
  initialize(source, sourcename, position, limitPosition) {
    CombeLexer.prototype.__proto__.initialize.call(self, source, sourcename, position, limitPosition)
    
    self.emitNewline = false
  }
  
  rule nextToken {
    ws? newlineToken
    
    !(self.tokenPosition = self.position)
    ( identifier
    | number
    | operatorAssignment
    | punctuation
    | string
    | regex
    | eof emit('eof')
    | error('Lexer failed at position ' + self.positionString())
    )
  }
  
  newlineToken {
    var indentColumn = self.lineColumn()[1] - 1;
    if (self.emitNewline && 
        !self.isEof() &&
        (self.tokenPosition != 0 || indentColumn > 0)) {
      self.emit('newline', self.lineColumn()[1] - 1)
    }
    self.emitNewline = false
  }
  
  
  rule identifier {
    ~'r/' initialIdChar idChar*
    emit('identifier'):token
    !(token.reserved = self.ReservedWords.include(token.text))
    -> token
  }
  
  ReservedWords: [
    'var',
    // 'function', 'rule',
    'if', 'else', 'while', 'do', 'for',
    'return', 'break', 'continue',
    'try', 'catch', 'finally',
    'this', 'null', 'undefined', 'true', 'false'
  ],
  
  
  rule operatorAssignment {
    ( '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='
    | '<<=' | '>>>=' | '>>='
    )
    emit('operatorAssignment')
  }
  
  
  rule punctuation {
    ( '{' | '}' | '(' | ')' | '[' | ']' | ';' | ','
    | '<<' | '>>>' | '>>' | '<=' | '>=' | '<' | '>'
    | '===' | '!==' | '==' | '!=' | '!' | '='
    | '...' | '..' | '.' ~digit -> '.'
    | '->' | '#'
    | '&&' | '||' | '^^' | '&' | '|' | '^'
    | '++' | '--' | '+' | '-'
    | '*' | '/' | '%' | '~' | '?' | '::' | ':'
    ):text
    emit(text)
  }
  
  
  rule number {
    | decimal
    | hexInteger
  }
  
  rule decimal {
    matchedInput[
      | integerPart ('.' digit*)? exponentPart?
      | '.' digit+ exponentPart?
    ]:text ~idChar
    emit('number', parseFloat(text))
  }
  
  rule integerPart {
    | '0'
    | char('1'..'9') digit*
  }
  
  rule exponentPart {
    ('e'|'E') ('+'|'-'|nothing) digit+
  }
  
  rule hexInteger {
    ('0x'|'0X') matchedInput[hexDigit+]:text ~idChar
    emit('number', parseInt(text, 16))
  }
  
  
  rule string {
    singleLineString
  }
  
  rule singleLineString {
    | singleLineStringBody['\'']
    | singleLineStringBody['\"']
  }
  rule singleLineStringBody(delimiter) {
    delimiter (stringFragment(delimiter) | stringInterpolationFragment(delimiter))*:fragments delimiter
    !{
      if (fragments.length == 0) {
        self.emit('string', '')
      }
      else if (fragments.length == 1 && String.isClassOf(fragments[0])) {
        self.emit('string', fragments[0])
      }
      else {
        self.emit('beginString')
        fragments.each(function (f) {
          if (String.isClassOf(f)) {
            self.emit('string', f)
          }
          else {
            self.emit('expression', f)
          }
        })
        self.emit('endString')
      }
    }
  },
  
  rule unescapedStringFragment(delimiter) {
    (~delimiter ~newline char)+:cs -> cs.join('')
  }
  
  rule stringFragment(delimiter) {
    (~delimiter ~newline stringChar)+:cs -> cs.join('')
  }
  
  rule stringChar { '\\' stringEscapeSequence | ~'\\' char }
  
  rule stringEscapeSequence {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | 'b'  -> '\b'
    | 'f'  -> '\f'
    | 'n'  -> '\n'
    | 'r'  -> '\r'
    | 't'  -> '\t'
    | 'v'  -> '\v'
    | '0' ~digit -> '\0'
    | 'x' matchedInput[hexDigit hexDigit]:hs -> String.fromCodepoint(hs)
    | 'u' matchedInput[hexDigit hexDigit hexDigit hexDigit]:hs -> String.fromCodepoint(hs)
  }
  
  rule stringInterpolationFragment {
    '\\('
    embeddedParse(require('./CombeParser'), 'expression', self.stringInterpolationLimit):e
    ~newline ws? ')'
    -> e
  }
  rule stringInterpolationLimit {
    (~newline char)+
  }
  
  
  rule regex {
    'r/' matchedInput[~'*' regexChar*]:pattern '/' matchedInput[idChar*]:options
    emit('regex', Regex.new(pattern, options))
  }
  
  rule regexChar {
    | '\\' ~newline char
    | regexCharacterClass
    | ~( '/' | newline ) char
  }
  
  rule regexCharacterClass {
    '[' regexCharacterClassChar ']'
  }
  
  rule regexCharacterClassChar {
    | '\\' ~newline char
    | ~(']' | newline) char
  }
  
  
  rule initialIdChar { char('a'..'z', 'A'..'Z', '_', '$') }
  rule idChar        { char('a'..'z', 'A'..'Z', '_', '$', '0'..'9') }
  rule digit         { char('0'..'9') }
  rule hexDigit      { char('0'..'9', 'a'..'f', 'A'..'F') }
  
  rule ws {
    ( spaces 
    | comment
    | newline !(self.emitNewline = true)
    )+
  }
  
  rule spaces  { char(' ') }
  rule newline { '\r\n' | char('\n\r') }
  
  rule comment {
    | '//' (~newline char)* (&newline | eof)
    | '/*' (~'*/' char)* '*/'
  }
  
})
