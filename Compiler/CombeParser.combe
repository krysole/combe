//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var Ast = require('./CombeAst');
var CombeLexer = require('./CombeLexer');

var CombeParser = module.exports = TokenGrammar.subclass({}, {
  
  initialize(source, filename) {
    CombeParser.prototype.__proto__.initialize.call(this, source, filename);
    
    this.lexer = CombeLexer.new(source, filename);
    
    this.pushState('column', 0);
    this.pushState('enclosed', false);
  },
  
  rule start { script },
  
  rule script {
    statement*:stmts eof
    -> Ast.Script(stmts)
  },
  
  
  rule statement {
    | varStatement
    
    | ifStatement
    | whileStatement
    | doWhileStatement
    | forStatement
    
    | tryCatchStatement
    
    // Todo: Consider a do statment as a corollary to a do expression, since
    // it would still provide the opportunity to avoid naming collisions, or
    // shadow variables.
    
    | expressionStatement
    | emptyStatement
  },
  
  rule varStatement {
    id('var') delimited1[variableDeclaration, ',']:decls statementTerminator
    -> Ast.VarStatement(decls)
  },
  
  rule variableDeclaration {
    variableIdentifier:name ( '=' expression:expr )?
    -> Ast.VariableDeclaration(name, expr)
  },
  
  rule ifStatement {
    id('if') lparen expression:condition rparen
    statementBody:consiquent
    ( id('else') statementBody:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  },
  
  rule whileStatement {
    id('while') lparen expression:condition rparen statementBody:b
    -> Ast.While(condition, b)
  },
  
  rule doWhileStatement {
    id('do') statementBody:b
    id('while') lparen expression:condition rparen statementTerminator
    -> Ast.DoWhile(b, condition)
  },
  
  rule forStatement {
    | id('for') lparen
        expression?:initExpr ';'
        expression?:condExpr ';'
        expression?:incExpr rparen statementBody:b
      -> Ast.For(initExpr, condExpr, incExpr, b)
    | id('for') lparen
        id('var') delimited1[variableDeclaration, ',']:decls ';'
        expression?:condExpr ';'
        expression?:incExpr rparen statementBody:b
      -> Ast.ForDeclaring(decls, condExpr, incExpr, b)
  },
  
  rule tryCatchStatement {
    id('try') statementBody:tryBody
    ( id('catch') lparen variableIdentifier:catchBinding rparen statementBody:catchBody )?
    ( id('finally') statementBody:finallyBody )?
    !(if (catchBody == null) catchBinding = null)
    -> Ast.TryCatch(tryBody, catchBinding, catchBody, finallyBody)
  },
  
  rule expressionStatement {
    expression:expr statementTerminator
    -> expr
  },
  
  rule emptyStatement {
    ';' newlineTerminator? -> Ast.Literal(null)
  },
  
  
  rule expression {
    | ifExpression
    | whileExpression
    | doWhileExpression
    | forExpression
    
    // Todo: Add a 'doExpression' which is just for creating a new lexical
    // block scope.
    
    | tryCatchExpression
    | throwExpression
    
    | returnExpression
    | breakExpression
    | continueExpression
    
    | operatorExpression
  },
  
  rule ifExpression {
    id('if') lparen expression:condition rparen expressionBody:consiquent
    ( id('else') expressionBody:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  },
  
  rule whileExpression {
    id('while') lparen expression:condition rparen expressionBody?:b
    -> Ast.While(condition, b)
  },
  
  rule doWhileExpression {
    id('do') expressionBody:b id('while') lparen expression:condition rparen
    -> Ast.DoWhile(b, condition)
  },
  
  rule forExpression {
    | id('for') lparen
        expression?:initExpr ';'
        expression?:condExpr ';'
        expression?:incExpr rparen expressionBody?:b
      -> Ast.For(initExpr, condExpr, incExpr, b)
    | id('for') lparen
        id('var') delimited1[variableDeclaration, ',']:decls ';'
        expression?:condExpr ';'
        expression?:incExpr rparen expressionBody?:b
      -> Ast.ForDeclaring(decls, condExpr, incExpr, b)
  },
  
  rule tryCatchExpression {
    id('try') expressionBody:tryBody
    ( id('catch') lparen variableIdentifier:catchBinding rparen expressionBody:catchBody )?
    ( id('finally') expressionBody:finallyBody )?
    !(if (catchBody == null) catchBinding = null)
    -> Ast.TryCatch(tryBody, catchBinding, catchBody, finallyBody)
  },
  
  rule throwExpression {
    id('throw') expression:expr
    -> Ast.Throw(expr)
  },
  
  rule returnExpression {
    id('return') expression?:expr
    -> Ast.Return(expr)
  },
  
  rule breakExpression {
    id('break')
    -> Ast.Break()
  },
  
  rule continueExpression {
    id('continue')
    -> Ast.Continue()
  },
  
  
  rule statementBody {
    | block:b statementTerminator -> b
    | statement
  },
  
  rule expressionBody {
    | block
    | expression
  },
  
  rule block {
    | beginBlock statement*:stmts endBlock
      -> Ast.Block(stmts)
    | emptyBlock
      -> Ast.Block([])
  },
  
  
  rule operatorExpression {
    assignmentExpression
  },
  
  // Todo: Add support for assignment methods
  lvalueTypes: ['Variable', 'Subscript', 'Dot'],
  
  rule assignmentExpression {
    | secondaryExpression:lhs
      ?(this.lvalueTypes.include(lhs.type))
      ( '=' expression:rhs
        -> Ast.Assignment(lhs, rhs)
      | 'operatorAssignment':op expression:rhs
        -> Ast.OperatorAssignment(op, lhs, rhs)
      )
    | conditionalExpression
  },
  
  rule conditionalExpression {
    // Todo: Do I want to keep the conditional operator instead of favoring the
    // if expression for all conditionals. '?' and ':' could be useful for other
    // things.
    logicalOrExpression:condition
    ( '?' expression:consiquent
      ':' expression:alternative
      -> Ast.If(condition, consiquent, alternative)
    | -> condition
    )
  },
  
  rule logicalOrExpression {
    leftAssociative[logicalXorExpression, '||']
  },
  rule logicalXorExpression {
    leftAssociative[logicalAndExpression, '^^']
  },
  rule logicalAndExpression {
    leftAssociative[equalityExpression, '&&']
  },
  
  rule equalityExpression {
    leftAssociative[relationalExpression, ('=='|'!='|'==='|'!==')]
  },
  rule relationalExpression {
    leftAssociative[bitwiseOrExpression, ('<'|'<='|'>='|'>')]
  },
  
  rule bitwiseOrExpression {
    leftAssociative[bitwiseXorExpression, '|']
  },
  rule bitwiseXorExpression {
    leftAssociative[bitwiseAndExpression, '^']
  },
  rule bitwiseAndExpression {
    leftAssociative[shiftExpression, '&']
  },
  
  rule shiftExpression {
    leftAssociative[additiveExpression, ('<<'|'>>'|'>>>')]
  },
  rule additiveExpression {
    leftAssociative[multiplicativeExpression, ('+'|'-')]
  },
  rule multiplicativeExpression {
    leftAssociative[rangeExpression, ('*'|'/'|'%')]
  },
  
  rule rangeExpression {
    prefixExpression:expr
    ( '..' (rangeInfinity | prefixExpression):rhs
      -> Ast.InclusiveRange(expr, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast.ExclusiveRange(expr, rhs)
    | -> expr
    )
  },
  rule rangeInfinity {
    '*' -> Ast.Literal(null)
  },
  
  rule prefixExpression {
    | ('++'|'--'|'+'|'-'|'~'|'!'):op prefixExpression:expr
      -> Ast.PrefixOperator(op.text, expr)
    | postfixExpression
  },
  
  rule postfixExpression {
    secondaryExpression:expr
    ( ('++'|'--'):op
      -> Ast.PostfixOperator(op.text, expr)
    | -> expr
    )
  },
  
  
  rule leftAssociative(operand, operator) {
    operand:expr
    ( operator:op operand:rhs
      !(expr = Ast.InfixOperator(op.text, expr, rhs))
    )*
    -> expr
  },
  rule rightAssociative(operand, operator) {
    operand:expr
    ( operator:op rightAssociative(operand, operator):rhs
      -> Ast.InfixOperator(op.text, expr, rhs)
    | -> expr
    )
  },
  
  rule secondaryExpression {
    primaryExpression:expr
    ( secondaryExpressionFragment(expr):expr )*
    -> expr
  },
  rule secondaryExpressionFragment(subject) {
    | arguments:args
      -> Ast.Call(subject, args)
    | lbracket delimited[expression, ',']:args rbracket
      -> Ast.Subscript(subject, args)
    | '.' 'identifier':name arguments:args
      -> Ast.MethodCall(subject, name.text, args)
    | '.' 'identifier':name
      -> Ast.Dot(subject, name.text)
  },
  
  
  rule arguments {
    lparen delimited[expression, ',']:args rparen -> args
  },
  
  rule parameters {
    lparen delimited[variableIdentifier, ',']:args rparen -> args
  },
  
  rule functionBody {
    | '->' expression
    | block
  },
  
  
  rule primaryExpression {
    | valueLiteral
    | id('this') -> Ast.This()
    | variableIdentifier:name -> Ast.Variable(name)
    | arrayLiteral
    | objectLiteral
    | functionLiteral
    | ruleLiteral
    | subexpression
  },
  
  rule valueLiteral {
    ( id('null') -> null
    | id('undefined') -> undefined
    | id('true') -> true
    | id('false') -> false
    | 'number':n -> n.value
    | 'string':s -> s.value
    | 'regex':r -> r.value
    ):value
    -> Ast.Literal(value)
  },
  
  rule arrayLiteral {
    lbracket delimited[arrayElement, ',']:elems ','? rbracket
    -> Ast.Array(elems)
  },
  rule arrayElement {
    | expression
    | &',' -> Ast.Literal(null) // Elision
  },
  
  rule objectLiteral {
    lbrace delimited[property, ',']:decls ','? rbrace
    -> Ast.Object(decls)
  },
  
  rule property {
    (
    | propertyName:name propertyValue:pv
      -> Ast.ValueProperty(name, pv)
    | id('get') propertyName:name propertyValue:pv
      -> Ast.GetProperty(name, pv)
    | id('set') propertyName:name propertyValue:pv
      -> Ast.SetProperty(name, pv)
    | id('rule') propertyName:name parameters?:params ruleBody:body
      -> Ast.ValueProperty(name, Ast.Rule(params, body))
    | id('describe') propertyName:name ':' expression:expr
      -> Ast.DescribeProperty(name, expr)
    )
  },
  rule propertyValue {
    | ':' expression:expr
    | parameters?:params functionBody:body
      -> Ast.Function(params, body)
  },
  
  rule functionLiteral {
    | parameters?:params '->' expression:e
      -> Ast.Function(params, e)
    | variableIdentifier:p '->' expression:e
      -> Ast.Function([p], e)
    | id('function') parameters?:params functionBody:body
      -> Ast.Function(params, body)
  },
  
  rule ruleLiteral {
    id('rule') parameters?:params ruleBody:body
    -> Ast.Rule(params, body)
  },
  rule ruleBody {
    | lbrace pattern:p rbrace -> p
    | operatorPattern
  },
  
  rule subexpression {
    lparen expressionSequence:expr rparen -> expr
  },
  
  rule expressionSequence {
    delimited1[expression, ',']:exprs ','?
    ( ?(exprs.length == 1)
      -> exprs[0]
    | -> Ast.Sequence(exprs)
    )
  },
  
  
  rule pattern {
    choicePattern
  },
  
  rule choicePattern {
    '|'? returnPattern:p
    ( '|' returnPattern:p2
      !(p = Ast.ChoicePattern([p, p2]))
    )*
    -> p
  },
  
  rule returnPattern {
    | sequencePattern:p
      ( '->' actionBody:e
        -> Ast.SequencePattern([p, Ast.ActionPattern(e)])
      | -> p
      )
    | '->' actionBody:e
      -> Ast.ActionPattern(e)
  },
  
  rule sequencePattern {
    operatorPattern+:ps
    ( ?(ps.length > 1)
      -> Ast.SequencePattern(ps)
    | -> ps[0]
    )
  },
  
  rule operatorPattern {
    prefixOperatorPattern
  },
  
  rule prefixOperatorPattern {
    | '~' ~ws prefixOperatorPattern:p -> Ast.NotPattern(p)
    | '&' ~ws prefixOperatorPattern:p -> Ast.LookaheadPattern(p)
    | '#' ~ws prefixOperatorPattern:p -> Ast.HashOperatorPattern(p)
    | postfixOperatorPattern
  },
  
  rule postfixOperatorPattern {
    callPattern:p
    ( ~ws '*' !(p = Ast.RepeatPattern(p))
    | ~ws '+' !(p = Ast.NonZeroRepeatPattern(p))
    | ~ws '?' !(p = Ast.OptionalPattern(p))
    | ~ws ':' ~ws variableIdentifier:name !(p = Ast.BindPattern(p, name))
    )*
    -> p
  },
  
  rule callPattern {
    primaryPattern:p
    ( ~ws arguments:args
      !(p = Ast.CallPattern(p, args))
    | ~ws patternArguments:args
      !(p = Ast.CallPattern(p, args))
    )*
    -> p
  },
  rule patternArguments {
    lbracket delimited[pattern, ',']:args rbracket -> args
  },
  
  rule primaryPattern {
    | predicatePattern
    | actionPattern
    | immediateActionPattern
    | stringPattern
    | variablePattern
    | lparen pattern:p rparen -> p
  },
  
  rule predicatePattern {
    '?' ~ws actionBody:e -> Ast.PredicatePattern(e)
  },
  
  rule actionPattern {
    '!' ~ws actionBody:e -> Ast.ActionPattern(e)
  },
  
  rule immediateActionPattern {
    '%' ~ws actionBody:e -> Ast.ImmediateActionPattern(e)
  },
  
  rule actionBody {
    | secondaryExpression
    | lparen expression:e rparen -> e
    | block
  },
  
  rule stringPattern {
    'string':s -> Ast.StringPattern(s.value)
  },
  
  rule variablePattern {
    variableIdentifier:name -> Ast.VariablePattern(name)
  },
  
  
  rule id(expectedName) {
    'identifier':name ?(name.text == expectedName) -> name
  },
  
  rule variableIdentifier {
    'identifier':name ?(!name.reserved) -> name.text
  },
  
  rule propertyName {
    | 'identifier':t -> t.text
    | 'string':t     -> t.value
    | 'number':t     -> t.text
  },
  
  
  ws {
    if (this.last().is('newline') ||
        this.last().position + this.last().length !== this.peek().position) {
      return null;
    }
    else {
      this.fail();
    }
  },
  
  newline {
    // ignoreToken causes next to ignore sometimes ignore newlines we want
    var token = this.at(this.position++);
    if (token.is('newline')) return token
    else throw Backtrack;
  },
  
  ignoreToken(token) {
    // Ignore line continuations
    return (
      token.is('newline') &&
      (
        this.getState('enclosed') ||
        token.value > this.getState('column')
      )
    );
  },
  
  rule blockIndentation {
    // workaround to ignoreToken eating token it as a continuation line
    newline:nl ?(nl.value > this.getState('column'))
    pushState('column', nl.value)
    pushState('enclosed', false)
  },
  
  rule blockDedentation {
    ?(!this.getState('enclosed'))
    ( newline:nl ?(nl.value < this.getState('column'))
    | eof
    )
    popState('enclosed')
    popState('column')
  },
  
  rule emptyBlock {
    lbrace newline? rbrace
  },
  
  rule newlineTerminator {
    ?(!this.getState('enclosed'))
    ( newline:nl ?(nl.value == this.getState('column'))
    | &newline:nl ?(nl.value < this.getState('column'))
    | eof
    )
  },
  
  
  rule statementTerminator { ';' newlineTerminator? | newlineTerminator },
  
  rule beginBlock { lbrace blockIndentation | lbrace },
  rule endBlock   { blockDedentation rbrace | rbrace },
  
  rule lparen { '(' pushState('enclosed', true) },
  rule rparen { ?(this.getState('enclosed')) ')' popState('enclosed') },
  
  rule lbracket { '[' pushState('enclosed', true) },
  rule rbracket { ?(this.getState('enclosed')) ']' popState('enclosed') },
  
  rule lbrace { '{' pushState('enclosed', true) },
  rule rbrace { ?(this.getState('enclosed')) '}' popState('enclosed') },
  
});
