//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var Ast = require('./CombeAst')
var CombeLexer = require('./CombeLexer')

var CombeParser = module.exports = TokenGrammar.subclass({}, {
  
  name: 'CombeParser'
  
  initialize(source, filename) {
    CombeParser.prototype.__proto__.initialize.call(self, source, filename)
    
    self.pushState('column', 0)
    self.pushState('enclosed', false)
  }
  
  LexerClass: CombeLexer
  
  rule start { script }
  
  rule script {
    statement*:stmts eof
    -> Ast.Script(stmts)
  }
  
  
  rule statement {
    | varStatement
    
    | ifStatement
    | whileStatement
    | doWhileStatement
    | forStatement
    | doStatement
    
    | tryCatchStatement
    
    | expressionStatement
    | emptyStatement
  }
  
  rule varStatement {
    id('var') delimited1[variableDeclaration, ',']:decls statementTerminator
    -> Ast.VarStatement(decls)
  }
  
  rule variableDeclaration {
    variableIdentifier:name ( '=' expression:expr )?
    -> Ast.VariableDeclaration(name, expr)
  }
  
  rule ifStatement {
    id('if') lparen expression:condition rparen
    statementBody:consiquent
    ( id('else') statementBody:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  }
  
  rule whileStatement {
    id('while') lparen expression:condition rparen statementBody:b
    -> Ast.While(condition, b)
  }
  
  rule doWhileStatement {
    id('do') statementBody:b
    id('while') lparen expression:condition rparen statementTerminator
    -> Ast.DoWhile(b, condition)
  }
  
  rule forStatement {
    | id('for') lparen
        expression?:initExpr ';'
        expression?:condExpr ';'
        expression?:incExpr rparen statementBody:b
      -> Ast.For(initExpr, condExpr, incExpr, b)
    | id('for') lparen
        id('var') delimited1[variableDeclaration, ',']:decls ';'
        expression?:condExpr ';'
        expression?:incExpr rparen statementBody:b
      -> Ast.ForDeclaring(decls, condExpr, incExpr, b)
  }
  
  rule doStatement {
    id('do') statementBody:b
    -> Ast.Do(b)
  }
  
  rule tryCatchStatement {
    id('try') statementBody:tryBody
    ( id('catch') lparen variableIdentifier:catchBinding rparen statementBody:catchBody )?
    ( id('finally') statementBody:finallyBody )?
    !(if (catchBody == null) catchBinding = null)
    -> Ast.TryCatch(tryBody, catchBinding, catchBody, finallyBody)
  }
  
  rule expressionStatement {
    expression:expr statementTerminator
    -> expr
  }
  
  rule emptyStatement {
    ';' newlineTerminator? -> Ast.Literal(null)
  }
  
  
  rule expression {
    | ifExpression
    | whileExpression
    | doWhileExpression
    | forExpression
    | doExpression
    
    | tryCatchExpression
    | throwExpression
    
    | returnExpression
    | breakExpression
    | continueExpression
    
    | operatorExpression
  }
  
  rule ifExpression {
    id('if') lparen expression:condition rparen expressionBody:consiquent
    ( id('else') expressionBody:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  }
  
  rule whileExpression {
    id('while') lparen expression:condition rparen expressionBody?:b
    -> Ast.While(condition, b)
  }
  
  rule doWhileExpression {
    id('do') expressionBody:b id('while') lparen expression:condition rparen
    -> Ast.DoWhile(b, condition)
  }
  
  rule forExpression {
    | id('for') lparen
        expression?:initExpr ';'
        expression?:condExpr ';'
        expression?:incExpr rparen expressionBody?:b
      -> Ast.For(initExpr, condExpr, incExpr, b)
    | id('for') lparen
        id('var') delimited1[variableDeclaration, ',']:decls ';'
        expression?:condExpr ';'
        expression?:incExpr rparen expressionBody?:b
      -> Ast.ForDeclaring(decls, condExpr, incExpr, b)
  }
  
  rule doExpression {
    id('do') expressionBody:b
    -> Ast.Do(b)
  }
  
  rule tryCatchExpression {
    id('try') expressionBody:tryBody
    ( id('catch') lparen variableIdentifier:catchBinding rparen expressionBody:catchBody )?
    ( id('finally') expressionBody:finallyBody )?
    !(if (catchBody == null) catchBinding = null)
    -> Ast.TryCatch(tryBody, catchBinding, catchBody, finallyBody)
  }
  
  rule throwExpression {
    id('throw') expression:expr
    -> Ast.Throw(expr)
  }
  
  rule returnExpression {
    id('return') expression?:expr
    -> Ast.Return(expr)
  }
  
  rule breakExpression {
    id('break')
    -> Ast.Break()
  }
  
  rule continueExpression {
    id('continue')
    -> Ast.Continue()
  }
  
  
  rule statementBody {
    | block:b statementTerminator -> b
    | statement
  }
  
  rule expressionBody {
    | block
    | expression
  }
  
  rule block {
    | beginBlock statement*:stmts endBlock
      -> Ast.Block(stmts)
    | emptyBlock
      -> Ast.Block([])
  }
  
  
  rule operatorExpression {
    assignmentExpression
  }
  
  // Todo: Add support for assignment methods
  lvalueTypes: ['Variable', 'Subscript', 'Dot'],
  
  rule assignmentExpression {
    | secondaryExpression:lhs
      ?(self.lvalueTypes.include(lhs.type))
      ( '=' expression:rhs
        -> Ast.Assignment(lhs, rhs)
      | 'operatorAssignment':op expression:rhs
        -> Ast.OperatorAssignment(op, lhs, rhs)
      )
    | logicalOrExpression
  }
  
  rule logicalOrExpression {
    leftAssociative[logicalXorExpression, '||']
  }
  rule logicalXorExpression {
    leftAssociative[logicalAndExpression, '^^']
  }
  rule logicalAndExpression {
    leftAssociative[equalityExpression, '&&']
  }
  
  rule equalityExpression {
    leftAssociative[relationalExpression, ('=='|'!='|'==='|'!==')]
  }
  rule relationalExpression {
    leftAssociative[bitwiseOrExpression, ('<'|'<='|'>='|'>')]
  }
  
  rule bitwiseOrExpression {
    leftAssociative[bitwiseXorExpression, '|']
  }
  rule bitwiseXorExpression {
    leftAssociative[bitwiseAndExpression, '^']
  }
  rule bitwiseAndExpression {
    leftAssociative[shiftExpression, '&']
  }
  
  rule shiftExpression {
    leftAssociative[additiveExpression, ('<<'|'>>'|'>>>')]
  }
  rule additiveExpression {
    leftAssociative[multiplicativeExpression, ('+'|'-')]
  }
  rule multiplicativeExpression {
    leftAssociative[rangeExpression, ('*'|'/'|'%')]
  }
  
  rule rangeExpression {
    prefixExpression:expr
    ( '..' (rangeInfinity | prefixExpression):rhs
      -> Ast.InclusiveRange(expr, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast.ExclusiveRange(expr, rhs)
    | -> expr
    )
  }
  rule rangeInfinity {
    '*' -> Ast.Literal(null)
  }
  
  rule prefixExpression {
    | ('++'|'--'|'+'|'-'|'~'|'!'):op prefixExpression:expr
      -> Ast.PrefixOperator(op.text, expr)
    | postfixExpression
  }
  
  rule postfixExpression {
    secondaryExpression:expr
    ( ('++'|'--'):op
      -> Ast.PostfixOperator(op.text, expr)
    | -> expr
    )
  }
  
  
  rule leftAssociative(operand, operator) {
    operand:expr
    ( operator:op operand:rhs
      !(expr = Ast.InfixOperator(op.text, expr, rhs))
    )*
    -> expr
  }
  rule rightAssociative(operand, operator) {
    operand:expr
    ( operator:op rightAssociative(operand, operator):rhs
      -> Ast.InfixOperator(op.text, expr, rhs)
    | -> expr
    )
  }
  
  rule secondaryExpression {
    primaryExpression:expr
    ( secondaryExpressionFragment(expr):expr )*
    -> expr
  }
  rule secondaryExpressionFragment(subject) {
    | argumentList:args
      -> Ast.Call(subject, args)
    | bracketedArgumentList:args
      -> Ast.Subscript(subject, args)
      
    | '.' propertyName:name argumentList:args
      -> Ast.MethodCall(subject, name, args)
    | '.' propertyName:name
      -> Ast.Dot(subject, name)
      
    | '::' propertyName:name argumentList:args
      -> Ast.MethodCall(Ast.Dot(subject, '__proto__'), name, args)
    | '::' propertyName:name
      -> Ast.Dot(Ast.Dot(subject, '__proto__'), name)
      
    | ':' propertyName:name argumentList:args
      -> Ast.MethodCall(Ast.Dot(subject, 'prototype'), name, args)
    | ':' propertyName:name
      -> Ast.Dot(Ast.Dot(subject, 'prototype'), name)
  }
  
  
  rule bracketedArgumentList {
    lbracket delimited[argument, ', ']:args rbracket -> args
  }
  rule argumentList {
    lparen delimited[argument, ',']:args rparen -> args
  }
  rule argument {
    | '*' expression:e -> Ast.SplatArgument(e)
    | expression
  }
  
  rule parameterList {
    lparen delimited[parameter, ',']:args rparen -> args
  }
  rule parameter {
    | '*' variableIdentifier:name -> Ast.SplatParameter(name)
    | variableIdentifier:name -> Ast.Parameter(name)
  }
  
  rule functionBody {
    | '->' expression
    | block
  }
  
  
  rule primaryExpression {
    | functionLiteral
    
    | id('null') -> Ast.Literal(null)
    | id('undefined') -> Ast.Literal(undefined)
    | id('this') -> Ast.This()
    | booleanLiteral
    | numberLiteral
    | regexLiteral
    | stringLiteral
    
    | variableIdentifier:name -> Ast.Variable(name)
    | arrayLiteral
    | objectLiteral
    | ruleLiteral
    | subexpression
  }
  
  rule booleanLiteral {
    | id('true') -> Ast.Literal(true)
    | id('false') -> Ast.Literal(false)
  }
  
  rule numberLiteral {
    'number':n -> Ast.Literal(n.value)
  }
  
  rule regexLiteral {
    'regex':r -> Ast.Literal(r.value)
  }
  
  rule stringLiteral {
    'string':s -> Ast.Literal(s.value)
  }
  
  rule arrayLiteral {
    lbracket delimited[arrayElement, ',']:elems ','? rbracket
    -> Ast.Array(elems)
  }
  rule arrayElement {
    | argument
    | &',' -> Ast.Literal(null) // Elision
  }
  
  rule objectLiteral {
    | beginBlock delimited[property, propertyDelimiter]:decls propertyDelimiter? endBlock
      -> Ast.Object(decls)
    | emptyBlock
      -> Ast.Object([])
  }
  
  rule property {
    (
    | propertyName:name propertyValue:pv
      -> Ast.ValueProperty(name, pv)
    | id('get') propertyName:name propertyValue:pv
      -> Ast.GetProperty(name, pv)
    | id('set') propertyName:name propertyValue:pv
      -> Ast.SetProperty(name, pv)
    | id('rule') propertyName:name parameterList?:params ruleBody:body
      -> Ast.ValueProperty(name, Ast.Rule(params, body))
    | id('describe') propertyName:name ':' expression:expr
      -> Ast.DescribeProperty(name, expr)
    )
  }
  rule propertyValue {
    | ':' expression:expr
    | parameterList?:params functionBody:body
      -> Ast.Method(params, body)
  }
  
  rule functionLiteral {
    | parameterList?:params '->' expression:e
      -> Ast.Function(params, e)
    | variableIdentifier:p '->' expression:e
      -> Ast.Function([p], e)
    | id('function') parameterList?:params functionBody:body
      -> Ast.Function(params, body)
  }
  
  rule methodLiteral {
    id('method') parameterList?:params functionBody:body
    -> Ast.Method(params, body)
  }
  
  rule ruleLiteral {
    id('rule') parameterList?:params ruleBody:body
    -> Ast.Rule(params, body)
  }
  rule ruleBody {
    | lbrace pattern:p rbrace -> p
    | operatorPattern
  }
  
  rule subexpression {
    lparen expressionSequence:expr rparen -> expr
  }
  
  rule expressionSequence {
    delimited1[expression, ',']:exprs ','?
    ( ?(exprs.length == 1)
      -> exprs[0]
    | -> Ast.Sequence(exprs)
    )
  }
  
  
  rule pattern {
    choicePattern
  }
  
  rule choicePattern {
    '|'? returnPattern:p
    ( '|' returnPattern:p2
      !(p = Ast.ChoicePattern([p, p2]))
    )*
    -> p
  }
  
  rule returnPattern {
    | sequencePattern:p
      ( '->' actionBody:e
        -> Ast.SequencePattern([p, Ast.ActionPattern(e)])
      | -> p
      )
    | '->' actionBody:e
      -> Ast.ActionPattern(e)
  }
  
  rule sequencePattern {
    operatorPattern+:ps
    ( ?(ps.length > 1)
      -> Ast.SequencePattern(ps)
    | -> ps[0]
    )
  }
  
  rule operatorPattern {
    prefixOperatorPattern
  }
  
  rule prefixOperatorPattern {
    | '~' ~ws prefixOperatorPattern:p -> Ast.NotPattern(p)
    | '&' ~ws prefixOperatorPattern:p -> Ast.LookaheadPattern(p)
    | '#' ~ws prefixOperatorPattern:p -> Ast.HashOperatorPattern(p)
    | postfixOperatorPattern
  }
  
  rule postfixOperatorPattern {
    callPattern:p
    ( ~ws '*' !(p = Ast.RepeatPattern(p))
    | ~ws '+' !(p = Ast.NonZeroRepeatPattern(p))
    | ~ws '?' !(p = Ast.OptionalPattern(p))
    | ~ws ':' ~ws variableIdentifier:name !(p = Ast.BindPattern(p, name))
    )*
    -> p
  }
  
  rule callPattern {
    primaryPattern:p
    ( ~ws argumentList:args
      !(p = Ast.CallPattern(p, args))
    | ~ws patternArguments:args
      !(p = Ast.CallPattern(p, args))
    )*
    -> p
  }
  rule patternArguments {
    lbracket delimited[pattern, ',']:args rbracket -> args
  }
  
  rule primaryPattern {
    | predicatePattern
    | actionPattern
    | immediateActionPattern
    | stringPattern
    | variablePattern
    | lparen pattern:p rparen -> p
  }
  
  rule predicatePattern {
    '?' ~ws actionBody:e -> Ast.PredicatePattern(e)
  }
  
  rule actionPattern {
    '!' ~ws actionBody:e -> Ast.ActionPattern(e)
  }
  
  rule immediateActionPattern {
    '%' ~ws actionBody:e -> Ast.ImmediateActionPattern(e)
  }
  
  rule actionBody {
    | secondaryExpression
    | lparen expression:e rparen -> e
    | block
  }
  
  rule stringPattern {
    stringLiteral:s -> Ast.StringPattern(s)
  }
  
  rule variablePattern {
    variableIdentifier:name -> Ast.VariablePattern(name)
  }
  
  
  rule id(expectedName) {
    'identifier':name ?(name.text == expectedName) -> name
  }
  
  rule variableIdentifier {
    'identifier':name ?(!name.reserved) -> name.text
  }
  
  rule propertyName {
    | lparen expression:expr rparen -> expr
    | 'identifier':t -> Ast.Literal(t.text)
    | stringLiteral
    | numberLiteral
  }
  
  
  ws {
    if (self.last().is('newline') ||
        self.last().end !== self.peek().start) {
      return null
    }
    else {
      self.fail()
    }
  }
  
  newline {
    // ignoreToken causes next to ignore sometimes ignore newlines we want
    var token = self.at(self.position++)
    if (token.is('newline')) return token
    else throw Backtrack
  }
  
  ignoreToken(token) {
    // Ignore line continuations
    return (
      token.is('newline') &&
      (
        self.getState('enclosed') ||
        token.value > self.getState('column')
      )
    )
  }
  
  rule blockIndentation {
    // workaround to ignoreToken eating token it as a continuation line
    newline:nl ?(nl.value > self.getState('column'))
    pushState('column', nl.value)
    pushState('enclosed', false)
  }
  
  rule blockDedentation {
    ?(!self.getState('enclosed'))
    ( newline:nl ?(nl.value < self.getState('column'))
    | eof
    )
    popState('enclosed')
    popState('column')
  }
  
  rule emptyBlock {
    lbrace newline? rbrace
  }
  
  rule newlineTerminator {
    ?(!self.getState('enclosed'))
    ( newline:nl ?(nl.value == self.getState('column'))
    | &newline:nl ?(nl.value < self.getState('column'))
    | eof
    )
  }
  
  
  rule statementTerminator { ';' newlineTerminator? | newlineTerminator }
  
  rule propertyDelimiter { ',' newlineTerminator? | newlineTerminator }
  
  rule beginBlock { lbrace blockIndentation | lbrace }
  rule endBlock   { blockDedentation rbrace | rbrace }
  
  rule lparen { '(' pushState('enclosed', true) }
  rule rparen { ?(self.getState('enclosed')) ')' popState('enclosed') }
  
  rule lbracket { '[' pushState('enclosed', true) }
  rule rbracket { ?(self.getState('enclosed')) ']' popState('enclosed') }
  
  rule lbrace { '{' pushState('enclosed', true) }
  rule rbrace { ?(self.getState('enclosed')) '}' popState('enclosed') }
  
})
