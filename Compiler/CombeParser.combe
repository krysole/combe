//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var Ast = require('./CombeAst');
var CombeLexer = require('./CombeLexer');

var CombeParser = module.exports = TokenGrammar.subclass({}, {
  
  initialize(source, filename) {
    TokenGrammar.prototype.initialize.call(this, source, filename);
    
    this.lexer = CombeLexer.new(source, filename);
  },
  
  rule start { script },
  
  rule script {
    terminatedStatement*:stmts eof
    -> Ast.Script(stmts)
  },
  
  
  rule terminatedStatement {
    statement:stmt ';' -> stmt
  },
  
  rule statement {
    | varStatement
    
    | expressionStatement
    | emptyStatement
  },
  
  rule varStatement {
    id('var') delimited1[variableDeclaration, ',']:decls
    -> Ast.VarStatement(decls)
  },
  
  rule variableDeclaration {
    variableIdentifier:name ( '=' expression:expr )?
    -> Ast.VariableDeclaration(name, expr)
  },
  
  rule expressionStatement {
    expression:expr
    -> Ast.ExpressionStatement(expr)
  },
  
  rule emptyStatement {
    -> Ast.EmptyStatement()
  },
  
  
  rule expression {
    | ifExpression
    | whileExpression
    | doWhileExpression
    | forExpression
    
    // Todo: Add a 'doExpression' which is just for creating a new lexical
    // block scope.
    
    | tryCatchExpression
    | throwExpression
    
    | returnExpression
    | breakExpression
    | continueExpression
    
    | operatorExpression
  },
  
  rule ifExpression {
    id('if') '(' expression:condition ')' expressionBody?:consiquent
    ( ?(consiquent != null) id('else') expressionBody:alternative )?
    -> Ast.IfExpression(condition, consiquent, alternative)
  },
  
  rule whileExpression {
    id('while') '(' expression:condition ')' expressionBody?:b
    -> Ast.WhileExpression(condition, b)
  },
  
  rule doWhileExpression {
    id('do') expressionBody:b id('while') '(' expression:condition ')'
    -> Ast.DoWhileExpression(b, condition)
  },
  
  rule forExpression {
    | id('for') '('
        expression?:initExpr ';'
        expression?:condExpr ';'
        expression?:incExpr ')' expressionBody?:b
      -> Ast.ForExpression(initExpr, condExpr, incExpr, b)
    | id('for') '('
        id('var') delimited1[variableDeclaration, ',']:decls ';'
        expression?:condExpr ';'
        expression?:incExpr ')' expressionBody?:b
      -> Ast.ForDeclaringExpression(decls, condExpr, incExpr, b)
  },
  
  rule tryCatchExpression {
    id('try') expressionBody:tryBody
    ( id('catch') '(' variableIdentifier:catchBinding ')' expressionBody:catchBody
      ( id('finally') expressionBody:finallyBody )?
      -> Ast.TryCatchExpression(tryBody, catchBinding, catchBody, finallyBody)
    | id('finally') expressionBody:finallyBody
      -> Ast.TryCatchExpression(tryBody, null, null, finallyBody)
    )
  },
  
  rule throwExpression {
    id('throw') expression:expr
    -> Ast.ThrowExpression(expr)
  },
  
  rule returnExpression {
    id('return') expression?:expr
    -> Ast.ReturnExpression(expr)
  },
  
  rule breakExpression {
    id('break')
    -> Ast.BreakExpression()
  },
  
  rule continueExpression {
    id('continue')
    -> Ast.ContinueExpression()
  },
  
  
  rule expressionBody {
    | expression
    | block
  },
  
  rule block {
    '{' terminatedStatement*:stmts '}'
    -> Ast.Block(stmts)
  },
  
  
  rule operatorExpression {
    assignmentExpression
  },
  
  // Todo: Add support for assignment methods
  lvalueTypes: ['Variable', 'Subscript', 'Dot'],
  
  rule assignmentExpression {
    | secondaryExpression:lhs
      ?(this.lvalueTypes.include(lhs.type))
      ( '=' expression:rhs
        -> Ast.Assignment(lhs, rhs)
      | 'operatorAssignment':op expression:rhs
        -> Ast.OperatorAssignment(op, lhs, rhs)
      )
    | conditionalExpression
  },
  
  rule conditionalExpression {
    // Todo: Do I want to keep the conditional operator instead of favoring the
    // if expression for all conditionals. '?' and ':' could be useful for other
    // things.
    logicalOrExpression:condition
    ( '?' expression:consiquent
      ':' expression:alternative
      -> Ast.IfExpression(condition, consiquent, alternative)
    | -> condition
    )
  },
  
  rule logicalOrExpression {
    leftAssociative[logicalXorExpression, '||']
  },
  rule logicalXorExpression {
    leftAssociative[logicalAndExpression, '^^']
  },
  rule logicalAndExpression {
    leftAssociative[equalityExpression, '&&']
  },
  
  rule equalityExpression {
    leftAssociative[relationalExpression, ('=='|'!='|'==='|'!==')]
  },
  rule relationalExpression {
    leftAssociative[bitwiseOrExpression, ('<'|'<='|'>='|'>')]
  },
  
  rule bitwiseOrExpression {
    leftAssociative[bitwiseXorExpression, '|']
  },
  rule bitwiseXorExpression {
    leftAssociative[bitwiseAndExpression, '^']
  },
  rule bitwiseAndExpression {
    leftAssociative[shiftExpression, '&']
  },
  
  rule shiftExpression {
    leftAssociative[additiveExpression, ('<<'|'>>'|'>>>')]
  },
  rule additiveExpression {
    leftAssociative[multiplicative, ('+'|'-')]
  },
  rule multiplicativeExpression {
    leftAssociative[rangeExpression, ('*'|'/'|'%')]
  },
  
  rule rangeExpression {
    prefixExpression:expr
    ( '..' (rangeInfinity | prefixExpression):rhs
      -> Ast.InclusiveRange(expr, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast.ExclusiveRange(expr, rhs)
    | -> expr
    )
  },
  rule rangeInfinity {
    '*' -> Ast.Literal(null)
  },
  
  rule prefixExpression {
    | ('++'|'--'|'+'|'-'|'~'|'!'):op prefixExpression:expr
      -> Ast.PrefixOperator(op.text, expr)
    | postfixExpression
  },
  
  rule postfixExpression {
    secondaryExpression:expr
    ( ('++'|'--'):op
      -> Ast.PostfixOperator(op.text, expr)
    | -> expr
    )
  },
  
  
  rule leftAssociative(operand, operator) {
    operand:expr
    ( operator:op operand:rhs
      !(expr = Ast.InfixOperator(op.text, expr, rhs))
    )*
    -> expr
  },
  rule rightAssociative(operand, operator) {
    operand:expr
    ( operator:op rightAssociative(operand, operator):rhs
      -> Ast.InfixOperator(op.text, expr, rhs)
    | -> expr
    )
  },
  
  rule secondaryExpression {
    primaryExpression:expr
    ( secondaryExpressionFragment(expr):expr )*
    -> expr
  },
  rule secondaryExpressionFragment(subject) {
    | arguments:args
      -> Ast.Call(subject, args)
    | '[' delimited[expression, ',']:args ']'
      -> Ast.Subscript(subject, args)
    | '.' 'identifier':name arguments:args
      -> Ast.MethodCall(subject, name.text, args)
    | '.' 'identifier':name
      -> Ast.Dot(subject, name.text)
  },
  
  
  rule arguments {
    '(' delimited[expression, ',']:args ')' -> args
  },
  
  rule parameters {
    '(' delimited[variableIdentifier, ',']:args ')' -> args
  },
  
  rule functionBody {
    | '->' expression
    | block
  },
  
  
  rule primaryExpression {
    | valueLiteral
    | id('this') -> Ast.This()
    | variableIdentifier:name -> Ast.Variable(name)
    | arrayLiteral
    | objectLiteral
    | functionLiteral
    | ruleLiteral
    | subexpression
  },
  
  rule valueLiteral {
    ( id('null') -> null
    | id('undefined') -> undefined
    | id('true') -> true
    | id('false') -> false
    | 'number':n -> n.value
    | 'string':s -> s.value
    | 'regex':r -> r.value
    ):value
    -> Ast.Literal(value)
  },
  
  rule arrayLiteral {
    '[' delimited[arrayElement, ',']:elems ','? ']'
    -> Ast.Array(elems)
  },
  rule arrayElement {
    | expression
    | -> Ast.Litearl(null) // Elision
  },
  
  rule objectLiteral {
    '{' delimited[property, ',']:decls ','? '}'
    -> Ast.Object(decls)
  },
  
  rule property {
    | propertyName:name propertyValue:pv
      -> Ast.ValueProperty(name, pv)
    | id('get') propertyName:name propertyValue:pv
      -> Ast.GetProperty(name, pv)
    | id('set') propertyName:name propertyValue:pv
      -> Ast.SetProperty(name, pv)
    | id('rule') propertyName:name parameters?:params ruleBody:body
      -> Ast.ValueProperty(name, Ast.Rule(params, body))
    | id('describe') propertyName:name ':' expression:expr
      -> Ast.DescribeProperty(name, expr)
  },
  rule propertyValue {
    | ':' expression:expr
    | parameters?:params functionBody:body
      -> Ast.Function(params, body)
  },
  
  rule functionLiteral {
    | parametes?:params '->' expression:e
      -> Ast.Function(params, e)
    | variableIdentifier:p '->' expression:e
      -> Ast.Function([p], e)
    | id('function') parameters?:params functionBody:body
      -> Ast.Function(params, body)
  },
  
  rule ruleLiteral {
    id('rule') parameters?:params ruleBody:body
    -> Ast.Rule(params, body)
  },
  rule ruleBody {
    | '{' pattern:p '}' -> p
    | operatorPattern
  },
  
  rule subexpression {
    '(' expressionSequence:expr ')' -> expr
  },
  
  rule expressionSequence {
    delimited1[expression, ',']:expr ','?
    ( ?(exprs.length == 1)
      -> exprs[0]
    | -> Ast.SequenceExpression(exprs)
    )
  },
  
  
  rule pattern {
    choicePattern
  },
  
  rule choicePattern {
    '|'? returnPattern:p
    ( '|' returnPattern:p2
      !(p = Ast.ChoicePattern([p, p2]))
    )*
    -> p
  },
  
  rule returnPattern {
    | sequencePattern:p
      ( '->' actionBody:e
        -> Ast.SequencePattern([p, Ast.ActionPattern(e)])
      | -> p
      )
    | '->' actionBody:e
      -> Ast.ActionPattern(e)
  },
  
  rule sequencePattern {
    operatorPattern+:ps
    ( ?(ps.length > 1) -> ps
    | -> ps[0]
    )
  },
  
  rule operatorPattern {
    prefixOperatorPattern
  },
  
  rule prefixOperatorPattern {
    | '~' prefixOperatorPattern:p -> Ast.NotPattern(p)
    | '&' prefixOperatorPattern:p -> Ast.LookaheadPattern(p)
    | '#' prefixOperatorPattern:p -> Ast.HashOperatorPattern(p)
    | postfixOperatorPattern
  },
  
  rule postfixOperatorPattern {
    callPattern:p
    ( '*' !(p = Ast.RepeatPattern(p))
    | '+' !(p = Ast.NonZeroRepeatPattern(p))
    | '?' !(p = Ast.OptionalPattern(p))
    | ':' variableIdentifier:name !(p = Ast.BindPattern(p, name))
    )*
    -> e
  },
  
  rule callPattern {
    primaryPattern:p
    ( arguments:args
      !(p = Ast.CallPattern(p, args))
    | patternArguments:args
      !(p = Ast.CallPattern(p, args))
    )*
    -> p
  },
  rule patternArguments {
    '[' delimited[pattern, ',']:args ']' -> args
  },
  
  rule primaryPattern {
    | predicatePattern
    | actionPattern
    | immediateActionPattern
    | stringPattern
    | variablePattern
    | '(' pattern:p ')' -> p
  },
  
  rule predicatePattern {
    '?' actionBody:e -> Ast.PredicatePattern(e)
  },
  
  rule actionPattern {
    '!' actionBody:e -> Ast.ActionPattern(e)
  },
  
  rule immediateActionPattern {
    '%' actionBody:e -> Ast.ImmediateActionPattern(e)
  },
  
  rule actionBody {
    | secondaryExpression
    | '(' expression:e ')' -> e
    | block
  },
  
  rule stringPattern {
    'string':s -> Ast.StringPattern(s.value)
  },
  
  rule variablePattern {
    variableIdentifier:name -> Ast.VariablePattern(name)
  },
  
  
  rule id(expectedName) {
    'identifier':name ?(name.text == expectedName) -> name
  },
  
  rule variableIdentifier {
    'identifier':name ?(!name.reserved) -> name.text
  },
  
  rule propertyName {
    | 'identifier':t -> t.text
    | 'string':t     -> t.value
    | 'number':t     -> t.text
  },
  
});
