//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var crypto = require('crypto')

var AstVisitor = require('./AstVisitor')

var CombeAst = require('./CombeAst')

var CombeAst_GenerateCode = module.exports = AstVisitor.subclass('CombeAst_GenerateCode', {}, {
  
  recurseOverUnspecifiedTypes: false,
  
  
  Script(ast) { // [ statements ]
    var stmts = ast.statements.map(function (stmt) {
      return [stmt.code, ';\n']
    })
    
    ast.code = [
      '// Generated by Combe compiler (', CombeVersion, ')\n',
      '"use strict";\n',
      'if (!__combe_runtimeLoaded) throw new Error("Combe runtime not loaded");\n',
      '(function () {\n',
        'var __combe_this = null;\n',
        'var __combe_return = null;\n',
        'try {\n',
          stmts,
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})();'
    ]
  }
  
  VarStatement(ast) { // [ declarations ]
    var decls = ast.declarations.map(function (decl) {
      return decl.code
    }).separatedBy(', ')
    
    ast.code = [
      'var ', decls
    ]
  }
  
  
  If(ast) { // [ condition, consiquent, alternative ]
    var alt = if (ast.alternative != null) ast.alternative.code
              else 'null'
    
    ast.code = [
      '(/* if */ ', ast.condition.code, '\n',
      '? /* then */ ', ast.consiquent.code, '\n',
      ': /* else */ ', alt, ')'
    ]
  }
  
  While(ast) { // [ condition, body ]
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        'while (', ast.condition.code, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '}\n',
      '})()'
    ]
  }
  
  DoWhile(ast) { // [ body, condition ]
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        'do {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '} while (', ast.condition.code, ');\n',
      '})()'
    ]
  }
  
  For(ast) { // [ initialize, condition, increment, body ]
    var init = if (ast.initialize != null) ast.initialize.code
               else null
    
    var cond = if (ast.condition != null) ast.condition.code
               else null
    
    var inc = if (ast.increment != null) ast.increment.code
              else null
    
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        'for (', init, '; ', cond, '; ', inc, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '}\n',
      '})()'
    ]
  }
  
  ForDeclaring(ast) { // [ declarations, condition, increment, body ]
    var decls = ['var ', ast.declarations.map(function (decl) {
      return decl.code
    }).separatedBy(', ')]
    
    var names = []
    var inits = []
    for (var i = 0; i < ast.declarations.length; i++) {
      var decl = ast.declarations[i]
      names.push(decl.name)
      inits.push(decl.expression.code)
    }
    names.separatedBy(', ')
    inits.separatedBy(', ')
    
    var cond = if (ast.condition != null) ast.condition.code
               else null
    
    var inc = if (ast.increment != null) ast.increment.code
              else null
    
    var body = self.unwrapBlockAsStatements(ast.body, true)
    
    ast.code = [
      '(function (', names, ') {\n',
        'while (', cond, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e !== __combe_continue) throw __combe_e;\n',
          '}\n',
          inc, ';\n',
        '}\n',
      '})(', inits, ')'
    ]
  }
  
  Do(ast) { // [ body ]
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        '/* do */ {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '}\n',
      '})()'
    ]
  }
  
  TryCatch(ast) { // [ tryBody, catchVariable, catchBody, finallyBody ]
    var tryFragment = [
      'try {\n',
        ast.tryBody.code, ';\n',
      '}\n'
    ]
    
    var catchFragment = null
    if (ast.catchBody != null) {
      catchFragment = [
        'catch (', ast.catchVariable, ') {\n',
          ast.catchBody.code, ';\n',
        '}\n'
      ]
    }
    
    var finallyBody = null
    if (ast.finallyBody != null) {
      finallyBody = [
        'finally {\n',
          ast.finallyBody.code, ';\n',
        '}\n'
      ]
    }
    
    ast.code = [
      '(function () {\n', 
        tryFragment,
        catchFragment,
        finallyBody,
      '})()'
    ]
  }
  
  Throw(ast) { // [ argument ]
    ast.code = [
      '(function () { throw ', ast.argument.code, '; })()'
    ]
  }
  
  Return(ast) { // [ argument ]
    var valueCode = if (ast.argument != null) ast.argument.code
                    else 'undefined'
    
    ast.code = [
      '(function () { throw (__combe_return = { value: ', valueCode, ' }); })()'
    ]
  }
  
  Break(ast) { // [ ]
    ast.code = [
      '(function () { throw __combe_break; })()'
    ]
  }
  
  Continue(ast) { // [ ]
    ast.code = [
      '(function () { throw __combe_continue; })()'
    ]
  }
  
  Sequence(ast) { // [ expressions ]
    var exprs = ast.expressions.map(function (expr) {
      return expr.code
    }).separatedBy(', ')
    
    if (exprs.isEmpty()) {
      exprs = 'null'
    }
    
    ast.code = [
      '(', exprs, ')'
    ]
  }
  
  
  Assignment(ast) { // [ lhs, rhs ]
    ast.code = [
      '(', ast.lhs.code, ' = ', ast.rhs.code, ')'
    ]
  }
  
  OperatorAssignment(ast) { // [ name, lhs, rhs ]
    ast.code = [
      '(', ast.lhs.code, ' ', ast.name, ' ', ast.rhs.code, ')'
    ]
  }
  
  PrefixOperator(ast) { // [ name, argument ]
    ast.code = [
      '(', ast.name, ast.argument.code, ')'
    ]
  }
  
  PostfixOperator(ast) { // [ name, argument ]
    ast.code = [
      '(', ast.argument.code, ast.name, ')'
    ]
  }
  
  InfixOperator(ast) { // [ name, lhs, rhs ]
    if (['==', '!=', '<', '<=', '>', '>=', '<=>'].include(ast.name)) {
      ast.code = [
        '__combe_infixOperators[', ast.name.quote(), '](',
          ast.lhs.code, ', ',
          ast.rhs.code,
        ')'
      ]
    }
    else {
      ast.code = [
        '(', ast.lhs.code, ' ', ast.name, ' ', ast.rhs.code, ')'
      ]
    }
  }
  
  
  Call(ast) { // [ function, arguments ]
    ast.code = self.generateCall(ast.function.code, ast.arguments)
  }
  
  Subscript(ast) { // [ subject, arguments ]
    ast.code = self.generateMethodCall(ast.subject.code, CombeAst.Literal('subscript'), ast.arguments)
  }
  
  MethodCall(ast) { // [ subject, name, arguments ]
    ast.code = self.generateMethodCall(ast.subject.code, ast.name, ast.arguments)
  }
  
  Dot(ast) { // [ subject, name ]
    if (ast.name.is('Literal') &&
        String.isClassOf(ast.name.value) &&
        ast.name.value.isJavaScriptPropertyName()) {
      ast.code = [ast.subject.code, '.', ast.name.value]
    }
    else {
      ast.code = [ast.subject.code, '[', ast.name.code, ']']
    }
  }
  
  
  InclusiveRange(ast) { // [ lhs, rhs ]
    ast.code = [
      'Range.inclusive(',
        ast.lhs.code, ', ',
        ast.rhs.code,
      ')'
    ]
  }
  
  ExclusiveRange(ast) { // [ lhs, rhs ]
    ast.code = [
      'Range.exclusive(',
        ast.lhs.code, ', ',
        ast.rhs.code,
      ')'
    ]
  }
  
  This(ast) { // [ ]
    ast.code = '__combe_this'
  }
  
  Variable(ast) { // [ name ]
    ast.code = ast.name
  }
  
  Literal(ast) { // [ value ]
    ast.code = String.toSourceString(ast.value)
  }
  
  Array(ast) { // [ arguments ]
    if (ast.arguments == null) ast.arguments = []
    
    var argumentsVariable = self.generateArgumentsVariable(ast.arguments)
    if (argumentsVariable != null) {
      ast.code = [
        '(function () {\n',
          argumentsVariable,
          'return __combe_arguments;\n',
        '})()'
      ]
    }
    else {
      ast.code = ['[', ast.arguments.map((a) -> a.code).separatedBy(', '), ']']
    }
  }
  
  Object(ast) { // [ properties ]
    var prologue = [
      'var __combe_object = {};\n'
    ]
    
    var decls = ast.properties.map(function (pdecl) {
      return [pdecl.code, ';\n']
    })
    
    var epilogue = [
      'return __combe_object;\n'
    ]
    
    ast.code = [
      '(function () {\n',
        prologue,
        decls,
        epilogue,
      '})()'
    ]
  }
  
  
  Function(ast) { // [ parameters, body ]
    var p = self.generateParameters(ast.parameters)
    
    ast.code = [
      '(function (', p.jsParams, ') {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        p.restParams,
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
  }
  
  Method(ast) { // [ parameters, body ]
    var p = self.generateParameters(ast.parameters)
    
    ast.code = [
      '(function (', p.jsParams, ') {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'var self = this;\n',
        p.restParams,
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
  }
  
  Rule(ast) { // [ parameters, body ]
    var p = self.generateParameters(ast.parameters)
    
    var declareVars = null
    if (ast.declareVariables.length >= 1) {
      declareVars = [
        'var ', ast.declareVariables.separatedBy(', '), ';\n'
      ]
    }
    
    if (p.jsParams == null && p.restParams == null) {
      var innerFunction = [
        '(function () {\n',
          'var self = this;\n',
          declareVars,
          'return ', ast.body.code, '.call(this);\n',
        '})'
      ]
      
      var innerFunctionCode = Array.deepJoinIOList(innerFunction)
      var hash = crypto.createHash('md5')
      hash.update(innerFunctionCode)
      var digest = hash.digest('base64').slice(0, -2); // without base64 suffix
      
      ast.code = [
        '(function () {\n',
          'return this.__combe_memoize(', digest.quote(), ', ', innerFunction, ');\n',
        '})'
      ]
    }
    else {
      ast.code = [
        '(function (', p.jsParams, ') {\n',
          p.restParams,
          'var self = this;\n',
          declareVars,
          'return ', ast.body.code, '.call(this);\n',
        '})'
      ]
    }
  }
  
  VariableDeclaration(ast) { // [ name, expression ]
    // Note: These should always be attached to a JS var statement...
    if (ast.expression != null) {
      ast.code = [ast.name, ' = ', ast.expression.code]
    }
    else {
      ast.code = ast.name
    }
  }
  
  
  Block(ast) { // [ statements ]
    var stmts = ast.statements.map(function (stmt) {
      return [stmt.code, ';\n']
    })
    
    ast.code = [
      '(function () {\n',
        stmts, // no default result
      '})()'
    ]
  }
  
  
  SplatArgument(ast) { // [ argument ]
    ast.code = ast.argument.code;
  }
  
  Parameter(ast) { // [ name ]
    // Do nothing
  }
  
  SplatParameter(ast) { // [ name ]
    // Do nothing
  }
  
  
  ValueProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe_defineValueProperty(', 
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  GetProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe_defineGetProperty(', 
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  SetProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe.defineSetProperty(',
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  DescribeProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe.defineDescribedProperty(', 
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  ChoicePattern(ast) { // [ patterns ]
    var ps = ast.patterns.map(function (p) {
      return p.code
    }).separatedBy(', ')
    
    ast.code = [
      '(function () {\n',
        'return this.__combe_choice(', ps, ');\n',
      '})'
    ]
  }
  
  SequencePattern(ast) { // [ patterns ]
    var ps = ast.patterns.slice(0, ast.patterns.length - 1).map(function (p) {
      return [p.code, '.call(this);\n']
    })
    ps.push([
      'return ', ast.patterns.last.code, '.call(this);\n'
    ])
    
    ast.code = [
      '(function () {\n',
        ps,
      '})'
    ]
  }
  
  NotPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_not(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  LookaheadPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_lookahead(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  HashOperatorPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.handleHashPattern(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  RepeatPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_repeat(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  NonZeroRepeatPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_nonZeroRepeat(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  OptionalPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_optional(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  BindPattern(ast) { // [ pattern, name ]
    ast.code = [
      '(function () {\n',
        'return (', ast.name, ' = ', ast.pattern.code, '.call(this));\n',
      '})'
    ]
  }
  
  CallPattern(ast) { // [ pattern, arguments ]
    var argumentsVariable = self.generateArgumentsVariable(ast.arguments);
    if (argumentsVariable != null) {
      ast.code = [
        '(function () {\n',
          'var __combe_this = this;\n', // Needed for argumentsVariable
          'var __combe_subject = ', ast.pattern.code, ';\n',
          argumentsVariable,
          'return __combe_subject.apply(__combe_this, __combe_arguments);\n',
        '})'
      ]
    }
    else {
      var as = ast.arguments.map((a) -> a.code).separatedBy(', ')
      ast.code = [
        '(function () {\n',
          'var __combe_this = this;\n', // Needed for arguments
          'return ', ast.pattern.code, '.call(this, ', as, ');\n',
        '})'
      ]
    }
  }
  
  PredicatePattern(ast) { // [ body ]
    var pattern = [
      '(function () {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
    
    ast.code = [
      '(function () {\n',
        'return this.__combe_predicate(', pattern, ');\n',
      '})'
    ]
  }
  
  ActionPattern(ast) { // [ body ]
    ast.code = [
      '(function () {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
  }
  
  ImmediateActionPattern(ast) { // [ body ]
    var pattern = [
      '(function () {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
    
    ast.code = [
      pattern, '.call(this)'
    ]
  }
  
  StringPattern(ast) { // [ argument ]
    ast.code = [
      '(function () {\n',
        'return this.handleStringPattern(', ast.argument.code, ');\n',
      '})'
    ]
  }
  
  VariablePattern(ast) { // [ name ]
    if (ast.containingScope.variables.include(ast.name)) {
      ast.code = [ ast.name ]
    }
    else {
      ast.code = [ 'this.', ast.name ]
    }
  }
  
  
  unwrapBlockAsStatements(ast, ignoreDefAndVarTest) {
    if (ignoreDefAndVarTest == null) ignoreDefAndVarTest = false
    
    if (ast == null) {
      return null
    }
    else if (ast.type === 'Block') {
      var stmts = ast.statements.map(function (stmt) {
        return [stmt.code, ';\n']
      })
      
      if (ast.statements.some(function (stmt) {
        return ['VarStatement'].include(stmt.type)
      }) || ignoreDefAndVarTest) {
        return stmts
      }
      else {
        return [
          '(function () {\n',
            stmts,
          '})()'
        ]
      }
    }
    else {
      return [ast.code, ';\n']
    }
  }
  
  generateArgumentsVariable(args) {
    if (args == null || args.length == 0) {
      return null
    }
    else if (args.length === 1 && args[0].is('SplatArgument')) {
      return ['var __combe_arguments = ', args[0].code, ';\n']
    }
    else if (args.any((a) -> a.is('SplatArgument'))) {
      var splatIndex = args.indexOfPredicate((a) -> a.is('SplatArgument'));
      
      var code = [
        'var __combe_arguments = [', args.slice(0, splatIndex).map((a) -> a.code).separatedBy(', '), '];\n'
      ]
      
      while (splatIndex != null) {
        code.push(
          '__combe_arguments.pushAll(', args[splatIndex].code, ');\n'
        )
        args = args.slice(splatIndex + 1)
        splatIndex = args.indexOfPredicate((a) -> a.is('SplatArgument'));
        if (splatIndex > 0 || (splatIndex == null && args.length > 0)) {
          code.push(
            '__combe_arguments.push(', args.slice(0, splatIndex).map((a) -> a.code).separatedBy(', '), ');\n'
          )
        }
      }
      return code;
    }
    else {
      return null;
    }
  }
  
  generateCall(functionCode, args) {
    if (args == null) args = []
    
    var argumentsVariable = self.generateArgumentsVariable(args);
    if (argumentsVariable != null) {
      return [
        '(function () {\n',
          'var __combe_subject = ', functionCode, ';\n',
          argumentsVariable,
          'return __combe_subject.apply(null, __combe_arguments);\n',
        '})()'
      ]
    }
    else {
      return [
        functionCode, '(', args.map((a) -> a.code).separatedBy(', '), ')'
      ]
    }
  }
  
  generateMethodCall(subjectCode, name, args) {
    if (args == null) args = []
    
    var argumentsVariable = self.generateArgumentsVariable(args);
    if (argumentsVariable != null) {
      return [
        '(function () {\n',
          'var __combe_subject = ', subjectCode, ';\n',
          'var __combe_name = ', name.code, ';\n',
          argumentsVariable,
          'return __combe_subject[__combe_name].apply(__combe_subject, __combe_arguments);\n',
        '})()'
      ]
    }
    else {
      args = args.map((a) -> a.code).separatedBy(', ')
      if (name.is('Literal') &&
          String.isClassOf(name.value) &&
          name.value.isJavaScriptPropertyName()) {
        return [subjectCode, '.', name.value, '(', args, ')']
      }
      else {
        return [subjectCode, '[', name.code, '](', args, ')']
      }
    }
  }
  
  generateParameters(params) {
    if (params == null || params.length == 0) return {
      jsParams: null,
      restParams: null,
    }
    
    assert(params.count((p) -> p.is('SplatParameter')) <= 1)
    
    var jsParams = null
    var restParams = null
    if (params.any((p) -> p.is('SplatParameter'))) {
      if (params.length == 1) {
        restParams = [
          'var ', params[0].name, ' = Array.slice(arguments);\n'
        ]
      }
      else if (params.last.is('SplatParameter')) {
        jsParams = params.dropLast(1).map((p) -> p.name).separatedBy(', ')
        restParams = [
          'var ', params.last.name, ' = Array.slice(arguments, ', params.length, ');\n'
        ]
      }
      else {
        var splatIndex = params.indexOfPredicate((p) -> p.is('SplatParameter'))
        jsParams = params.take(splatIndex).map((p) -> p.name).separatedBy(', ')
        var remParams = params.drop(splatIndex + 1)
        restParams = [
          'var ', params[splatIndex].name, ' = Array.slice(arguments, ', splatIndex, 'arguments.length - ', remParams.length, ');\n'
        ]
        remParams.each(function (p, i) {
          restParams.push('var ', p.name, ' = arguments[', splatIndex + 1 + i, '];\n')
        })
      }
    }
    else {
      jsParams = params.map((p) -> p.name).separatedBy(', ')
    }
    
    return {
      jsParams: jsParams,
      restParams: restParams
    }
  }
    
  
  gensymIndex: 0,
  
  gensym(name) {
    if (name == null) name = '__unnamed'
    
    return '__combe_gensym_' + name + self.gensymIndex++
  }
  
})
