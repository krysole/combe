//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
'use strict';

var combe = require('combe');

var TextParser = combe.TextParser;

var Token = Class.new(Object, {}, {
  
  initialize: function (type, value, position, length, text) {
    this.type = type;
    this.value = value;
    this.position = position;
    this.length = length;
    this.text = text;
  },
  
  toString: function () {
    return '[[Token ' + this.type + ' ' + this.value + ' ' + this.text.quote() + ']]';
  },
  
  is: function (typename) {
    return this.type === typename;
  },
  
});


var CombeLexer = module.exports = Class.new(TextParser, {
  
  allTokens: function (source, filename) {
    var lexer = this.new(source, filename);
    var tokens = [];
    
    try {
      while (tokens.isEmpty() || !tokens.last.is('eof')) {
        tokens.push(lexer.nextToken());
      }
    }
    catch (e) {
      if (e === combe.BacktrackingException) {
        throw Error.new('Lexer failed at ' + lexer.positionString());
      }
      else {
        throw e;
      }
    }
    
    return tokens;
  },
  
}, {
  
  initialize: function (source, filename) {
    if (filename == null) filename = '(unnamed)';
    
    TextParser.prototype.initialize.call(this, source);
    
    this.source = source;
    this.filename = filename;
    this.furthestPosition = 0;
  },
  
  reset: function (position) {
    if (position == null) position = 0;
    
    this.position = position;
  },
  
  createToken: function (type, value) {
    var text = this.source.slice(this.tokenPosition, this.position);
    return Token.new(
      type,
      value,
      this.tokenPosition,
      text.length,
      text
    );
  },
  
  
  nextToken: rule {
    !(this.furthestPosition = this.position)
    ws?
    
    !(this.tokenPosition = this.position)
    ( identifier
    | number
    | operatorAssignment
    | punctuation
    | string
    | regex
    | eof createToken('eof')
    | !{ throw Error.new('Lexer failed at position ' + this.source.lineColumnAt(this.position).join(':')); }
    )
  },
  
  
  identifier: rule {
    initialIdChar idChar*
    createToken('identifier'):token
    !(token.reserved = this.ReservedWords.include(token.text))
    -> token
  },
  
  ReservedWords: [
    'var',
    'function', 'rule',
    'if', 'else', 'while', 'do', 'for',
    'for', 'break', 'continue', 
    'try', 'catch', 'finally',
    'this', 'null', 'undefined', 'true', 'false'
  ],

  
  operatorAssignment: rule {
    ( '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='
    | '<<=' | '>>>=' | '>>='
    )
    createToken('operatorAssignment')
  },
  
  
  punctuation: rule {
    ( '{' | '}' | '(' | ')' | '[' | ']' | ';' | ','
    | '<<' | '>>>' | '>>' | '<=' | '>=' | '<' | '>'
    | '===' | '!==' | '==' | '!=' | '!' | '='
    | '...' | '..' | '.' ~digit -> '.'
    | '->' | '#'
    | '&&' | '||' | '^^' | '&' | '|' | '^'
    | '++' | '--' | '+' | '-'
    | '*' | '/' | '%' | '~' | '?' | ':'
    ):text
    createToken(text)
  },
  
  
  number: rule {
    | decimal
    | hexInteger
  },
  
  decimal: rule {
    matchedInput[
      | integerPart ('.' digit*)? exponentPart?
      | '.' digit+ exponentPart?
    ]:text ~idChar
    createToken('number', parseFloat(text))
  },
  
  integerPart: rule {
    | '0'
    | char('1'..'9') digit*
  },
  
  exponentPart: rule {
    ('e'|'E') ('+'|'-'|nothing) digit+
  },
  
  hexInteger: rule {
    ('0x'|'0X') matchedInput[hexDigit+]:text ~idChar
    createToken('number', parseInt(text, 16))
  },
  
  
  string: rule {
    ( stringFragment['\''] | stringFragment['\"'] ):text
    createToken('string', text)
  },
  
  stringFragment: rule (quote) {
    quote (~quote stringChar)*:cs quote
    -> cs.join('')
  },
  
  stringChar: rule {
    | '\\' stringEscapeSequence
    | '\\' newline -> ''
    | ~newline char
  },
  
  stringEscapeSequence: rule {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | 'b'  -> '\b'
    | 'f'  -> '\f'
    | 'n'  -> '\n'
    | 'r'  -> '\r'
    | 't'  -> '\t'
    | 'v'  -> '\v'
    | '0' ~digit -> '\0'
    | 'x' repeat[hexDigit, %2]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %4]:hs -> String.fromCodepoint(hs.join(''))
    | ~(newline | digit) char
  },
  
  
  regex: rule {
    'r/' matchedInput[~'*' regexChar*]:pattern '/' matchedInput[idChar*]:options
    createToken('regex', RegExp.new(pattern, options))
  },
  
  regexChar: rule {
    | '\\' ~newline char
    | regexCharacterClass
    | ~( '/' | newline ) char
  },
  
  regexCharacterClass: rule {
    '[' regexCharacterClassChar ']'
  },
  
  regexCharacterClassChar: rule {
    | '\\' ~newline char
    | ~(']' | newline) char
  },
  
  
  
  
  initialIdChar: rule { char('a'..'z', 'A'..'Z', '_', '$') },
  idChar:        rule { char('a'..'z', 'A'..'Z', '_', '$', '0'..'9') },
  digit:         rule { char('0'..'9') },
  hexDigit:      rule { char('0'..'9', 'a'..'f', 'A'..'F') },
  
  ws: rule {
    ( spaces | comment | newline )+
  },
  
  spaces:        rule { char(' \t\v\f\u00a0\u200c\u200d\ufeff') },
  newline:       rule { '\r\n' | char('\n\r\u2028\u2029') },
  
  comment: rule {
    | '//' (~newline char)* (newline | eof)
    | '/*' (~'*/' char)* '*/'
  },
  
  
  next: function () {
    var c = TextParser.prototype.next.call(this);
    this.furthestPosition = Math.max(
      this.furthestPosition,
      this.position
    );
    return c;
  },
  
  nextIf: function () {
    var c = TextParser.prototype.nextIf.call(this, predicate);
    this.furthestPosition = Math.max(
      this.furthestPosition,
      this.position
    );
    return c;
  },
  
  lineColumnString: function (position) {
    if (position == null) position = this.position;
    
    return this.source.lineColumnAt(position).join(':');
  },
  
  positionString: function (position) {
    return this.filename + ':' + this.lineColumnString(position);
  },
  
  log: function (name) {
    var additionalMessages = Array.slice(arguments, 1);
    var out = 'CombeLexer::log() ' + this.positionString() + ':' + name;
    if (additionalMessages.length > 0) {
      out = out + '; ';
      out = out + additionalMessages.join('; ');
    }
    console.error(out);
  },
  
});
