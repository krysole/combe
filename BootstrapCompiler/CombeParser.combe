//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
'use strict';

var combe = require('combe');

var BaseParser = combe.BaseParser;

var Ast = require('./CombeAst');
var CombeLexer = require('./CombeLexer');

var CombeParser = module.exports = Class.new(BaseParser, {
  
  parseScript: function () {
    var parser = this.new();
    return parser.parseScript.apply(parser, arguments);
  },
  
  parse: function () {
    var parser = this.new();
    return parser.parse.apply(parser, arguments);
  },
  
}, {
  
  parseScript: function (source, filename) {
    return this.parse(source, filename, 'script');
  },
  
  parse: function (source, filename, rulename) {
    var rest = Array.slice(arguments, 3);
    if (filename == null) filename = '(unnamed)';
    
    this.source = source;
    this.filename = filename;
    
    this.lexer = CombeLexer.new(source, filename);
    this.tokens = [];
    
    this.ast = this.match.apply(this, [rulename].concat(rest));
    if (this.ast == null) {
      throw Error.new('Combe parser failed; futhest position was ' + this.positionString(this.furthestPosition));
    }
    
    return this.ast;
  },
  
  
  initialize: function (source, filename) {
    BaseParser.prototype.initialize.call(this, source);
    
    this.filename = filename;
    
    this.lexer = CombeLexer.new(source, filename);
    this.tokens = [];
    this.furthestPosition = -1;
  },
  
  
  script: rule {
    terminatedStatement*:stmts eof
    -> Ast.Script(stmts)
  },
  
  
  terminatedStatement: rule {
    statement:stmt ';' -> stmt
  },
  
  statement: rule {
    | varStatement
    
    | expressionStatement
    | emptyStatement
  },
  
  varStatement: rule {
    id('var') delimited1[variableDeclaration, ',']:decls
    -> Ast.VarStatement(decls)
  },
  
  variableDeclaration: rule {
    variableIdentifier:name ( '=' expression:expr )?
    -> Ast.VariableDeclaration(name, expr)
  },
  
  expressionStatement: rule {
    expression:expr
    -> Ast.ExpressionStatement(expr)
  },
  
  emptyStatement: rule {
    -> Ast.EmptyStatement()
  },
  
  
  expression: rule {
    | ifExpression
    | whileExpression
    | doWhileExpression
    | forExpression
    
    // Todo: Add a 'doExpression' which is just for creating a new lexical
    // block scope.
    
    | tryCatchExpression
    | throwExpression
    
    | returnExpression
    | breakExpression
    | continueExpression
    
    | operatorExpression
  },
  
  ifExpression: rule {
    id('if') '(' expression:condition ')' expressionBody?:consiquent
    ( ?(consiquent != null) id('else') expressionBody:alternative )?
    -> Ast.IfExpression(condition, consiquent, alternative)
  },
  
  whileExpression: rule {
    id('while') '(' expression:condition ')' expressionBody?:b
    -> Ast.WhileExpression(condition, b)
  },
  
  doWhileExpression: rule {
    id('do') expressionBody:b id('while') '(' expression:condition ')'
    -> Ast.DoWhileExpression(b, condition)
  },
  
  forExpression: rule {
    | id('for') '('
        expression?:initExpr ';' 
        expression?:condExpr ';'
        expression?:incExpr ')' expressionBody?:b
      -> Ast.ForExpression(initExpr, condExpr, incExpr, b)
    | id('for') '('
        id('var') delimited1[variableDeclaration, ',']:decls ';'
        expression?:condExpr ';'
        expression?:incExpr ')' expressionBody?:b
      -> Ast.ForDeclaringExpression(decls, condExpr, incExpr, b)
  },
  
  tryCatchExpression: rule {
    id('try') expressionBody:tryBody
    ( id('catch') '(' variableIdentifier:catchBinding ')' expressionBody:catchBody
      ( id('finally') expressionBody:finallyBody )?
      -> Ast.TryCatchExpression(tryBody, catchBinding, catchBody, finallyBody)
    | id('finally') expressionBody:finallyBody
      -> Ast.TryCatchExpression(tryBody, null, null, finallyBody)
    )
  },
  
  throwExpression: rule {
    id('throw') expression:expr
    -> Ast.ThrowExpression(expr)
  },
  
  returnExpression: rule {
    id('return') expression?:expr
    -> Ast.ReturnExpression(expr)
  },
  
  breakExpression: rule {
    id('break')
    -> Ast.BreakExpression()
  },
  
  continueExpression: rule {
    id('continue')
    -> Ast.ContinueExpression()
  },
  
  
  expressionBody: rule {
    | expression
    | block
  },
  
  block: rule {
    '{' terminatedStatement*:stmts '}'
    -> Ast.Block(stmts)
  },
  blockContents: rule {
    terminatedStatements*:stmts
    -> Ast.Block(stmts)
  },
  
  
  operatorExpression: rule {
    assignmentExpression
  },
  
  // Todo: Add support for assignment methods
  lvalueTypes: [
    'Variable', 'Subscript', 'Dot'
  ],
  
  assignmentExpression: rule {
    | secondaryExpression:lhs
      ?(this.lvalueTypes.include(lhs.type))
      ( '=' expression:rhs
        -> Ast.Assignment(lhs, rhs)
      | 'operatorAssignment':op expression:rhs
        -> Ast.OperatorAssignment(op, lhs, rhs)
      )
    | conditionalExpression
  },
  
  conditionalExpression: rule {
    logicalOrExpression:condition
    ( '?' expression:consiquent
      ':' expression:alternative
      -> Ast.IfExpression(condition, consiquent, alternative)
    | -> condition
    )
  },
  
  logicalOrExpression: rule {
    leftAssociative[logicalXorExpression, '||']
  },
  logicalXorExpression: rule {
    leftAssociative[logicalAndExpression, '^^']
  },
  logicalAndExpression: rule {
    leftAssociative[equalityExpression, '&&']
  },
  
  equalityExpression: rule {
    leftAssociative[relationalExpression, ('=='|'!='|'==='|'!==')]
  },
  relationalExpression: rule {
    leftAssociative[bitwiseOrExpression, ('<'|'<='|'>='|'>')]
  },
  
  bitwiseOrExpression: rule {
    leftAssociative[bitwiseXorExpression, '|']
  },
  bitwiseXorExpression: rule {
    leftAssociative[bitwiseAndExpression, '^']
  },
  bitwiseAndExpression: rule {
    leftAssociative[shiftExpression, '&']
  },
  
  shiftExpression: rule {
    leftAssociative[additiveExpression, ('<<'|'>>'|'>>>')]
  },
  additiveExpression: rule {
    leftAssociative[multiplicitiveExpression, ('+'|'-')]
  },
  multiplicitiveExpression: rule {
    leftAssociative[rangeExpression, ('*'|'/'|'%')]
  },
  
  rangeExpression: rule {
    prefixExpression:expr
    ( '..' (rangeInfinity | prefixExpression):rhs
      -> Ast.InclusiveRange(expr, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast.ExclusiveRange(expr, rhs)
    | -> expr
    )
  },
  rangeInfinity: rule {
    '*' -> Ast.Literal(null)
  },
  
  prefixExpression: rule {
    | ('++'|'--'|'+'|'-'|'~'|'!'):op prefixExpression:expr
      -> Ast.PrefixOperator(op.text, expr)
    | postfixExpression
  },
  
  postfixExpression: rule {
    secondaryExpression:expr
    ( ('++'|'--'):op
      -> Ast.PostfixOperator(op.text, expr)
    | -> expr
    )
  },
  
  
  leftAssociative: rule (operand, operator) {
    operand:expr
    ( operator:op operand:rhs
      !(expr = Ast.InfixOperator(op.text, expr, rhs))
    )*
    -> expr
  },
  rightAssociative: rule (operand, operator) {
    operand:expr
    ( operator:op rightAssociative(operand, operator):rhs
      -> Ast.InfixOperator(op.text, expr, rhs)
    | -> expr
    )
  },
  
  
  secondaryExpression: rule {
    primaryExpression:expr
    ( secondaryExpressionFragment(expr):expr )*
    -> expr
  },
  
  secondaryExpressionFragment: rule (subject) {
    | arguments:args
      -> Ast.Call(subject, args)
    | '[' delimited[expression, ',']:args ']'
      -> Ast.Subscript(subject, args)
    | '.' 'identifier':name arguments:args
      -> Ast.MethodCall(subject, name.text, args)
    | '.' 'identifier':name
      -> Ast.Dot(subject, name.text)
  },
  
  
  arguments: rule {
    '(' delimited[expression, ',']:args ')' -> args
  },
  
  parameters: rule {
    '(' delimited[variableIdentifier, ',']:args ')' -> args
  },
  
  functionBody: rule {
    | '->' expression
    | block
  },
  
  
  primaryExpression: rule {
    | valueLiteral
    | id('this') -> Ast.This()
    | variableIdentifier:name -> Ast.Variable(name)
    | arrayLiteral
    | objectLiteral
    | functionLiteral
    | ruleLiteral
    | subexpression
  },
  
  valueLiteral: rule {
    ( id('null')  -> null
    | id('undefined') -> undefined
    | id('true')  -> true
    | id('false') -> false
    | 'number':n  -> n.value
    | 'string':s  -> s.value
    | 'regex':r   -> r.value
    ):value
    -> Ast.Literal(value)
  },
  
  arrayLiteral: rule {
    '[' delimited[arrayElement, ',']:elems ','? ']'
    !{ if (elems.last.is('Elision')) elems.pop(); }
    -> Ast.Array(elems)
  },
  arrayElement: rule {
    | expression
    | -> Ast.Literal(null) // Elision
  },
  
  objectLiteral: rule {
    '{' delimited[property, ',']:decls ','? '}'
    -> Ast.Object(decls)
  },
  
  property: rule {
    | propertyName:name propertyValue:pv
      -> Ast.ValueProperty(name, pv)
    | id('get') propertyName:name propertyValue:pv
      -> Ast.GetProperty(name, pv)
    | id('set') propertyName:name propertyValue:pv
      -> Ast.SetProperty(name, pv)
    | id('rule') propertyName:name parameters?:params ruleBody:body
      -> Ast.ValueProperty(name, Ast.Rule(params, body))
    | id('describe') propertyName:name ':' expression:expr
      -> Ast.DescribeProperty(name, expr)
  },
  propertyValue: rule {
    | ':' expression:expr
    | parameters?:params functionBody:body
      -> Ast.Function(params, body)
  },
  
  functionLiteral: rule {
    | parameters?:params '->' expression:e
      -> Ast.Function(params, e)
    | variableIdentifier:p '->' expression:e
      -> Ast.Function([p], e)
    | id('function') parameters?:params functionBody:body
      -> Ast.Function(params, body)
  },
  
  ruleLiteral: rule {
    | id('rule') parameters?:params ruleBody:body
      -> Ast.Rule(params, body)
  },
  ruleBody: rule {
    | '{' pattern:p '}' -> p
    | operatorPattern
  },
  
  subexpression: rule {
    '(' expressionSequence:expr ')' -> expr
  },
  
  expressionSequence: rule {
    delimited1[expression, ',']:exprs ','?
    ( ?(exprs.length === 1)
      -> exprs[0]
    | -> Ast.SequenceExpression(exprs)
    )
  },
  
  
  pattern: rule {
    choicePattern
  },
  
  choicePattern: rule {
    '|'? returnPattern:p
    ( '|' returnPattern:p2
      !(p = Ast.ChoicePattern([p, p2]))
    )*
    -> p
  },
  
  returnPattern: rule {
    | sequencePattern:p
      ( '->' actionBody:e
        -> Ast.SequencePattern([p, Ast.ActionPattern(e)])
      | -> p
      )
    | '->' actionBody:e
      -> Ast.ActionPattern(e)
  },
  
  sequencePattern: rule {
    operatorPattern+:ps
    ( ?(ps.length > 1) -> ps
    | -> ps[0]
    )
  },
  
  operatorPattern: rule {
    prefixOperatorPattern
  },
  
  prefixOperatorPattern: rule {
    | '~' prefixOperatorPattern:p -> Ast.NotPatern(p)
    | '&' prefixOperatorPattern:p -> Ast.LookaheadPattern(p)
    | '#' prefixOperatorPattern:p -> Ast.HashOperatorPattern(p)
    | postfixOperatorPattern
  },
  
  postfixOperatorPattern: rule {
    callPattern:p
    ( '*' !(p = Ast.RepeatPattern(p))
    | '+' !(p = Ast.NonZeroRepeatPattern(p))
    | '?' !(p = Ast.OptionalPattern(p))
    | ':' variableIdentifier:name !(p = Ast.BindPattern(p, name))
    )*
    -> e
  },
  
  callPattern: rule {
    primaryPattern:p
    ( arguments:args
      !(p = Ast.CallPattern(p, args))
    | patternArguments:args
      !(p = Ast.CallPattern(p, args))
    )*
    -> p
  },
  patternArguments: rule {
    '[' delimited[pattern, ',']:args ']' -> args
  },
  
  primaryPattern: rule {
    | predicatePattern
    | actionPattern
    | immediateActionPattern
    | stringPattern
    | variablePattern
    | '(' pattern:p ')' -> p
  },
  
  predicatePattern: rule {
    '?' actionBody:e -> Ast.PredicatePattern(e)
  },
  
  actionPattern: rule {
    '!' actionBody:e -> Ast.ActionPattern(e)
  },
  
  immediateActionPattern: rule {
    '%' actionBody:e -> Ast.ImmediateActionPattern(e)
  },
  
  actionBody: rule {
    | secondaryExpression
    | '(' expression:e ')' -> e
    | block
  },
  
  stringPattern: rule {
    | 'string':s -> Ast.StringPattern(s.value)
  },
  
  variablePattern: rule {
    variableIdentifier:name -> Ast.VariablePattern(name)
  },
  
  
  id: rule (expectedName) {
    'identifier':name ?(name.text === expectedName) -> name
  },
  
  variableIdentifier: rule {
    'identifier':name ?(!name.reserved) -> name.text
  },
  
  propertyName: rule {
    | 'identifier':t -> t.text
    | 'string':t     -> t.value
    | 'number':t     -> t.text
  },
  
  
  t: function (typename) {
    var token = this.next();
    if (token.type === typename) {
      this.furthestPosition = Math.max(this.furthestPosition, this.position);
      return token;
    }
    else {
      this.fail();
    }
  },
  
  peekNext: function () {
    return this.tokenAt(this.position);
  },
  
  next: function () {
    return this.tokenAt(this.position++);
  },
  
  tokenAt: function (position) {
    var token;
    
    assert(position < this.tokens.length + 1);
    if (position >= this.tokens.length) {
      assert(this.tokens.isEmpty() || this.tokens.last.type !== 'eof');
      
      this.tokens.push(this.lexer.nextToken());
    }
    
    return this.tokens[position];
  },
  
  eof: rule {
    'eof'
  },
  
  stringPatternHandler: rule (string) {
    t(string)
  },
  
  
  lineColumnString: function (position) {
    if (position == null) position = this.position;
    
    if (position != -1) {
      var token = this.tokenAt(position);
    
      return this.source.lineColumnAt(token.position).join(':');
    }
    else {
      return '-:-';
    }
  },
  
  positionString: function (position) {
    var lcs = this.lineColumnString(position);
    
    return this.filename + ':' + lcs;
  },
  
  log: function (name) {
    var additionalMessages = Array.slice(arguments, 1);
    var out = 'CombeParser::log() ' + this.positionString() + ':' + name;
    if (additionalMessages.length > 0) {
      out = out + '; ';
      out = out + additionalMessages.join('; ');
    }
    console.error(out);
  },    

});
