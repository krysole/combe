//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
'use strict';
var combe = require('combe');

var Ast = require('./Ast');

var CombeAstToJS = module.exports = Class.new(Object, {
  
  translate: function (ast) {
    return Array.deepJoinIOList(this.translateToIOList(ast));
  },
  
  translateToIOList: function (ast) {
    ast.visit(this.new());
    
    return ast.code;
  },
  
}, {
  
  visitUnspecified: function (ast) {
    throw Error.new('Unrecognized Ast Node');
  },
  
  
  visitScript: function (ast) { // [ statements ]
    ast.visitChildren(this);
    
    var stmts = ast.statements.map(function (stmt) {
      return stmt.code;
    });
    
    ast.code = [
      '// Generated by Combe compiler\n',
      '"use strict";\n',
      '(function () {\n',
        'var __combe = require("newcombe/Runtime/__combe");\n',
        'var __combe$break = __combe.break;\n',
        'var __combe$continue = __combe.continue;\n',
        'var Range = __combe.Range;\n',
        '__combe$this = null;\n',
        '__combe$return = null;\n',
        'try {\n'
          stmts,
        '}\n',
        'catch (e) {\n',
          'if (__combe$return === e) return __combe$return;\n',
          'throw e;\n',
        '}\n',
      '})()'
    ];
  },
  
  
  visitDefStatement: function (ast) { // [ name, parameters, body ]
    ast.visitChildren(this);
    
    var params = ast.parameters.interpolate(', ');
    
    var body = this.unwrapBlockAsStatements(ast.body);
    
    ast.code = [
      'var ', ast.name, ' = function ', ast.name, '(', params, ') {\n',
        body,
      '};\n';
    ];
  },
  
  visitVarStatement: function (ast) { // [ declarations ]
    ast.visitChildren(this);
    
    var decls = ast.declarations.map(function (decl) {
      return decl.code;
    }).interpolate(', ');
    
    ast.code = [
      'var ', decls, ';\n';
    ];
  },
  
  visitExpressionStatement: function (ast) { // [ expression ]
    ast.visitChildren(this);
    
    ast.code = [ast.expression.code, ';\n'];
  },
  
  visitEmptyStatement: function (ast) { // [ ]
    ast.code = 'null;\n';
  },
  
  
  visitIfExpression: function (ast) { // [ condition, consiquent, alternative ]
    ast.visitChildren(this);
    
    var alt = ast.alternative != null ? ast.alternative.code : 'null';
    
    ast.code = [
      '(/* if */ ', ast.condition.code, '\n',
      '? /* then */ ', ast.consiquent.code, '\n',
      ': /* else */ ', alt, ')'
    ];
  },
  
  visitWhileExpression: function (ast) { // [ condition, body ]
    ast.visitChildren(this);
    
    var body = this.unwrapBlockAsStatements(ast.body);
    
    ast.code = [
      '(function () {\n',
        'while (', ast.condition.code, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (e) {\n',
            'if (e === __combe$break) break;\n',
            'if (e === __combe$continue) continue;\n',
            'throw e;\n',
          '}\n',
        '}\n',
      '})()'
    ];
  },
  
  visitDoWhile: function (ast) { // [ body, condition ]
    ast.visitChildren(this);
    
    var body = this.unwrapBlockAsStatements(ast.body);
    
    ast.code = [
      '(function () {\n',
        'do {\n',
          'try {\n',
            body,
          '}\n',
          'catch (e) {\n',
            'if (e === __combe$break) break;\n',
            'if (e === __combe$continue) continue;\n',
            'throw e;\n',
          '}\n',
        '} while (', ast.condition.code, ');\n',
      '})()'
    ];
  },
  
  visitForExpression: function (ast) { // [ initialize, condition, increment, body ]
    ast.visitChildren(this);
    
    var init = ast.initialize != null ? ast.initialize.code : null;
    
    var cond = ast.condition != null ? ast.condition.code : null;
    
    var inc = ast.increment != null ? ast.increment.code : null;
    
    var body = this.unwrapBlockAsStatements(ast.body);
    
    ast.code = [
      '(function () {\n',
        'for (', init, '; ', cond, '; ', inc, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (e) {\n',
            'if (e === __combe$break) break;\n',
            'if (e === __combe$continue) continue;\n',
            'throw e;\n',
          '}\n',
        '}\n',
      '})()'
    ];
  },
  
  visitForDeclaringExpression: function (ast) { // [ declarations, condition, increment, body ]
    ast.visitChildren(this);
    
    var decls = ['var ', ast.declarations.map(function (decl) {
      return decl.code;
    }).interpolate(', ')];
    
    var names = [];
    var inits = [];
    for (var i = 0; i < ast.declarations.length; i++) {
      var decl = ast.declarations[i];
      names.push(decl.name);
      inits.push(decl.expression.code);
    }
    names.interpolate(', ');
    inits.interpolate(', ');
    
    var cond = ast.condition != null ? ast.condition.code : null;
    
    var inc = ast.increment != null ? ast.increment.code : null;
    
    var body = this.unwrapBlockAsStatements(ast.body, true);
    
    ast.code = [
      '(function (', names, ') {\n',
        'while (', cond, ') {\n',
          body,
          inc, ';\n';
        '}\n',
      '})(', inits, ')'
    ];
    
    ast.code = [
      '(function (', names, ') {\n',
        'while (', cond, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (e) {\n',
            'if (e === __combe$break) break;\n',
            'if (e !== __combe$continue) throw e;\n',
          '}\n',
          inc, ';\n',
        '}\n',
      '})(', inits, ')'
    ];
  },
  
  visitTryCatchExpression: function (ast) { // [ tryBody, catchVariable, catchBody, finallyBody ]
    ast.visitChildren(this);
    
    var tryFragment = [
      'try {\n',
        ast.tryBody.code, ';\n',
      '}\n'
    ];
    
    if (catchBody != null) {
      var catchFragment = [
        'catch (', ast.catchVariable, ') {\n',
          ast.catchBody.code, ';\n',
        '}\n'
      ];
    }
    
    if (finallyBody != null) {
      var finallyBody = [
        'finally {\n',
          ast.finallyBody.code, ';\n',
        '}\n'
      ];
    }
    
    ast.code = [
      '(function () {\n', 
        tryFragment,
        catchFragment,
        finallyBody,
      '})()'
    ];
  },
  
  visitThrowExpression: function (ast) { // [ argument ]
    ast.visitChildren(this);
    
    ast.code = [
      '(function () { throw ', ast.argument.code, '; })()'
    ];
  },
  
  visitReturnExpression: function (ast) { // [ argument ]
    ast.visitChildren(this);
    
    ast.code = [
      '(function () { throw (__combe$return = { value: ', ast.argument.code, ' }); })()'
    ];
  },
  
  visitBreakExpression: function (ast) { // [ ]
    ast.code = [
      '(function () { throw __combe$break; })()'
    ];
  },
  
  visitContinueExpression: function (ast) { // [ ]
    ast.code = [
      '(function () { throw __combe$continue; })()'
    ];
  },
  
  visitSequenceExpression: function (ast) { // [ expressions ]
    ast.visitChildren(this);
    
    var exprs = ast.expressions.map(function (expr) {
      return expr.code;
    }).interpolate(', ');
    
    if (exprs.length === 0) {
      exprs = 'null';
    }
    
    ast.code = [
      '(', exprs, ')'
    ];
  },
  
  
  visitAssignment: function (ast) { // [ lhs, rhs ]
    ast.visitChildren(this);
    
    ast.code = [
      '(', ast.lhs.code, ' = ', ast.rhs.code, ')'
    ];
  },
  
  visitOperatorAssignment: function (ast) { // [ name, lhs, rhs ]
    ast.visitChildren(this);
    
    ast.code = [
      '(', ast.lhs.code, ' ', ast.name, ' ', ast.rhs.code, ')'
    ];
  },
  
  visitPrefixOperator: function (ast) { // [ name, argument ]
    ast.visitChildren(this);
    
    ast.code = [
      ast.name, '(', ast.argument.code, ')'
    ];
  },
  
  visitPostfixOperator: function (ast) { // [ name, argument ]
    ast.visitChildren(this);
    
    ast.code = [
      '(', ast.argument.code, ')', ast.name
    ];
  },
  
  visitInfixOperator: function (ast) { // [ name, lhs, rhs ]
    ast.visitChildren(this);
    
    ast.code = [
      '__combe.infixOperators[', ast.name.quote(), '](',
        ast.lhs.code, ', ',
        ast.rhs.code,
      ')'
    ];
  },
  
  
  visitCall: function (ast) { // [ subject, arguments ]
    ast.visitChildren(this);
    
    var args = ast.arguments.map(function (arg) {
      return arg.code;
    }).interpolate(', ');
    
    ast.code = [
      ast.function.code, '(', args, ')'
    ];
  },
  
  visitSubscript: function (ast) { // [ subject, arguments ]
    ast.visitChildren(this);
    
    var args = ast.arguments.map(function (arg) {
      return arg.code;
    }).interpolate(', ');
    
    ast.code = [
      ast.subject.code, '.subscript(', args, ')'
    ];
  },
  
  visitState: function (ast) { // [ subject, name ]
    ast.visitChildren(this);
    
    var name = '@' + ast.name;
    
    ast.code = [
      ast.subject.code, '[', name, ']'
    ];
  },
  
  visitMethodCall: function (ast) { // [ subject, name, arguments ]
    ast.visitChildren(this);
    
    var args = ast.arguments.map(function (arg) {
      return arg.code;
    }).interpolate(', ');
    
    ast.code = [
      ast.subject.code, '.', ast.name, '(', args, ')'
    ];
  },
  
  
  visitInclusiveRange: function (ast) { // [ lhs, rhs ]
    ast.visitChildren(this);
    
    ast.code = [
      '__combe.inclusiveRange(',
        ast.lhs.code, ', ',
        ast.rhs.code,
      ')'
    ];
  },
  
  visitExclusiveRange: function (ast) { // [ lhs, rhs ]
    ast.visitChildren(this);
    
    ast.code = [
      '__combe.exclusiveRange(',
        ast.lhs.code, ', ',
        ast.rhs.code,
      ')'
    ];
  },
  
  visitNull: function (ast) { // [ ]
    ast.code = 'null';
  },
  
  visitThis: function (ast) { // [ ]
    ast.code = '__combe$this';
  },
  
  visitVariable: function (ast) { // [ name ]
    ast.code = ast.name;
  },
  
  visitLiteral: function (ast) { // [ value ]
    if (ast.value == null) {
      ast.code = 'null';
    }
    else if (ast.value === true) {
      ast.code = 'true';
    }
    else if (ast.value === false) {
      ast.code = 'false';
    }
    else if (typeof ast.value === 'string') {
      ast.code = ast.value.quote();
    }
    else if (typeof ast.value === 'number') {
      ast.code = ast.value.toString();
    }
    else {
      throw Error.new('Unknown Ast (Literal) value type');
    }
  },
  
  visitArray: function (ast) { // [ elements ]
    ast.visitChildren(this);
    
    var elems = ast.elements.map(function (elem) {
      return elem.code;
    }).interpolate(', ');
    
    ast.code = [
      '[', elems, ']'
    ];
  },
  
  visitObject: function (ast) { // [ properties ]
    ast.visitChildren(this);
    
    var prologue = [
      'var __combe$object = {};\n'
    ];
    
    var decls = ast.properties.map(function (pdecl) {
      return pdecl.code + ';\n';
    });
    
    var epilogue = [
      'return __combe$object;\n';
    ];
    
    ast.code = [
      '(function () {\n',
        prologue,
        decls,
        epilogue,
      '})()'
    ];
  },
  
  
  visitFunction: function (ast) { // [ parameters, body ]
    ast.visitChildren(this);
    
    var params = ast.parameters.interpolate(', ');
    
    ast.code = [
      '(function (', params, ') {\n',
        '__combe$this = this;\n',
        '__combe$return = null;\n',
        'try {\n'
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (e) {\n',
          'if (e === __combe$return) return __combe$return;\n',
          'throw e;\n',
        '}\n',
      '})'
    ];
  },
  
  
  visitVariableDeclaration: function (ast) { // [ name, expression ]
    ast.visitChildren(this);
    
    // Note: These should always be attached to a JS var statement...
    if (ast.expression != null) {
      ast.code = [ast.name, ' = ', ast.expression.code];
    }
    else {
      ast.code = ast.name;
    }
  },
  
  
  visitBlock: function (ast) { // [ statements ]
    ast.visitChildren(this);
    
    var stmts = ast.statements.map(function (stmt) {
      return stmt.code;
    });
    
    ast.code = [
      '(function () {\n',
        stmts, // no default result
      '})()'
    ];
  },
  
  
  visitValueProperty: function (ast) { // [ name, value ]
    ast.visitChildren(this);
    
    ast.code = [
      '__combe.defineValueProperty(', 
        '__combe$object, ',
        ast.name.quote(), ', ',
        ast.value.code,
      ')'
    ];
  },
  
  visitGetProperty: function (ast) { // [ name, value ]
    ast.visitChildren(this);
    
    ast.code = [
      '__combe.defineGetProperty(', 
        '__combe$object, ',
        ast.name.quote(), ', ',
        ast.value.code,
      ')'
    ];
  },
  
  visitSetProperty: function (ast) { // [ name, value ]
    ast.visitChildren(this);
    
    ast.code = [
      '__combe.defineSetProperty(',
        '__combe$object, ',
        ast.name.quote(), ', ',
        ast.value.code,
      ')'
    ];
  },
  
  visitDescribeProperty: function (ast) { // [ name, value ]
    ast.visitChildren(this);
    
    ast.code = [
      '__combe.defineProperty(', 
        '__combe$object, ',
        ast.name.quote(), ', ',
        ast.value.code,
      ')'
    ];
  },
  
  
  unwrapBlockAsStatements: function (ast, ignoreDefAndVarTest) {
    if (ignoreDefAndVarTest == null) ignoreDefAndVarTest = false;
    
    if (ast == null) {
      return null;
    }
    else if (ast.type === 'Block') {
      var stmts = ast.statements.map(function (stmt) {
        return stmt.code;
      });
      
      if (ast.statetments.some(function (stmt) {
        return ['DefStatement', 'VarStatement'].include(stmt.type);
      }) || ignoreDefAndVarTest) {
        return stmts;
      }
      else {
        return [
          '(function () {\n',
            stmts,
          '})()'
        ];
      }
    }
    else {
      return [ast.code, ';\n'];
    }
  },
  
  gensymIndex: 0,
  
  gensym: function (name) {
    if (name == null) name = 'unnamed';
    
    return '__combe$gensym$' + name + this.gensymIndex++;
  },
  
});
