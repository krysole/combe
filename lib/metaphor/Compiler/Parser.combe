/*
  The Combe Programming Language
  
  Copyright 2011 Lorenz Pretterhofer

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
'use strict';

var combe = require('combe');

var Ast = require('./Ast');

var Parser = module.exports = Class.new(combe.TextParser, {
  
  parse: function (source) {
    var parser = this.new(source);
    var result = parser.match('file');
    if (result == null) {
      var lc = source.lineColumnAt(parser.furthestPosition);
      throw new Error('Parse failed with furthest position ' + lc[0] + ':' + lc[1]);
    }
    return result;
  },
  
}, {
  
  // Syntactic Rules
  
  file: rule {
    delimited[statement, statementTerminator]:stmts ws? eof
    -> Ast.File(Ast.Block(stmts))
  },
  
  // Todo: I think I need to move some things form the statement level down
  // into the expression level, like return, break and continue, for example.
  // 
  // Basically anything that doesn't cause the creation of block scope can
  // probably be used freely in other situations. Block scope may in fact be
  // the very definition of the statement level of Metaphor's notation.

  statement: rule {
    | ifStatement
    | whileStatement
    | doWhileStatement
    | loopStatement
    | letStatement
    | varStatement
    | defStatement
    | returnStatement
    | breakStatement
    | continueStatement
    | expression
  },
  
  expression: rule {
    | ifExpression
    | whileExpression
    | doWhileExpression
    | loopExpression
    | defExpression
    | operatorExpression
  },
  
  ifStatement: rule {
    id('if') expression:condition statementTerminator
      blockBody:consiquent
    id('else') statementTerminator
      blockBody:alternative
    id('end')
    -> Ast.If(condition, consiquent, alternative)
  },
  
  ifExpression: rule {
    id('if') expression:condition 
    id('then') expression:consiquent 
    ( id('else') expression:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  },
  
  whileStatement: rule {
    id('while') expression:condition statementTerminator
      blockBody:body
    id('end')
    -> Ast.While(condition, body)
  },
  
  whileExpression: rule {
    id('while') expression:condition
    id('do') expression:body
    -> Ast.While(condition, body)
  },
  
  doWhileStatement: rule {
    id('do') statementTerminator
      blockBody:body
    id('while') expression:condition
    -> Ast.DoWhile(body, condition)
  },
  
  doWhileExpression: rule {
    id('do') expression:body id('while') expression:condition
    -> Ast.DoWhile(body, condition)
  },
  
  loopStatement: rule {
    id('loop') statementTerminator
      blockBody:body
    id('end')
    -> Ast.Loop(body)
  },
  
  loopExpression: rule {
    id('loop') expression:body
    -> Ast.Loop(body)
  },
  
  letStatement: rule {
    id('let') lexicalIdentifier:name op('<-') assignmentExpression:rvalue
    -> Ast.Let(name, rvalue)
  },
  
  varStatement: rule {
    id('var') lexicalIdentifier:name ( op('<-') assignmentExpression:rvalue )?
    -> Ast.Var(name, rvalue)
  },
  
  defExpression: rule {
    id('def') lexicalIdentifier:name parameterList?:params op('->') expression:body
    -> Ast.Def(name, params, body)
  },
  
  defStatement: rule {
    id('def') lexicalIdentifier:name parameterList?:params statementTerminator
      blockBody:body
    id('end')
    -> Ast.Def(name, params, body)
  },
  
  returnStatement: rule {
    id('return') expression?:arg
    -> Ast.Return(arg)
  },
  
  breakStatement: rule {
    id('break') expression?:arg
    -> Ast.Break(arg)
  },
  
  continueStatement: rule {
    id('continue')
    -> Ast.Continue()
  },
  
  
  doBlock: rule {
    id('do') statementTerminator
      blockBody:body
    id('end')
    -> body
  },
  
  blockBody: rule {
    | (
        indent
        delimited[statement, statementTerminator]:stmts
        dedent
      )
      -> Ast.Block(stmts)
    | -> Ast.Noop()
  },
  
  
  operatorExpression: rule {
    assignmentExpression
  },
  
  assignmentExpression: rule {
    | lexicalMessageSendAssignment
    | MessageSendAssignment
    | logicalOperator
  },
  
  
  lexicalMessageSendAssignment: rule {
    lexicalMessageSend:mes op('<-') assignmentExpression:rvalue
    -> Ast.AssignmentMessageSend(mes, rvalue)
  },
  
  methodCallAssignment: rule {
    primaryExpression:expr ( messageSendFragment(expr):expr )+ op('<-') assignmentExpression:rvalue
    -> Ast.AssignmentMessageSend(expr, rvalue)
  },
  
  
  logicalOperator: rule {
    wordedLogicalOr
  },
  
  wordedLogicalOr: rule {
    wordedLogicalXor:expr
    ( id('or') wordedLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalXor: rule {
    wordedLogicalAnd:expr
    ( id('xor') wordedLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalAnd: rule {
    wordedLogicalNot:expr
    ( id('and') wordedLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalNot: rule {
    | id('not') wordedLogicalNot:expr
      -> Ast.Not(expr)
    | symbolicLogicalOr
  },
  
  symbolicLogicalOr: rule {
    symbolicLogicalXor:expr
    ( op('||') symbolicLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalXor: rule {
    symbolicLogicalAnd:expr
    ( op('^^') symbolicLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalAnd: rule {
    symbolicLogicalNot:expr
    ( op('&&') symbolicLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalNot: rule {
    | op('!') symbolicLogicalNot:expr
      -> Ast.Not(expr)
    | equalityOperator
  },
  
  equalityOperator: rule {
    // Todo: Allow Math style sequences of equality operators (i.e., 0 <= i < length) 
    comparisonOperator:expr
    ( (op('=') | op('/=') | op('<=') | op('<') | op('>=') | op('>') ):opname
      comparisonOperator:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
  },
  
  comparisonOperator: rule {
    association:expr
    ( op('<>'):opname association:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  association: rule {
    | ( string | identifier ):lhs op(':') bitwiseOr:rhs
      -> Ast.Association(Ast.String(lhs), rhs)
    | bitwiseOr:lhs op('=>') bitwiseOr:rhs
      -> Ast.Association(lhs, rhs)
  },
  
  bitwiseOr: rule {
    leftAssocOperator[bitwiseXor op('|')]
  },
  bitwiseXor: rule {
    leftAssocOperator[bitwiseAnd op('^')]
  },
  bitwiseAnd: rule {
    leftAssocOperator[shiftOperator op('&')]
  },
  
  shiftOperator: rule {
    leftAssocOperator[additionOperator, ( op('<<') | op('>>') | op('>>>') )]
  },
  additionOperator: rule {
    leftAssocOperator[multiplicationOperator, ( op('+') | op('-') )]
  },
  multiplicationOperator: rule {
    leftAssocOperator[exponentiationOperator, ( op('*') | op('/') | op('//') | op('%') )]
  },
  exponentiationOperator: rule {
    rightAssocOperator[prefixOperatorExpression, op('**')]
  },
  
  leftAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname term:rhs
      !(expr = Ast.Operator(opname, expr, rhs))
    )*
    -> expr
  },
  rightAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname rightAssocOperator(term, operator):rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  prefixOperatorExpression: rule {
    | ( op('+') | op('-') | op('~') ):opname prefixOperatorExpression:expr
      -> Ast.PrefixOperator(opname, expr)
    | secondaryExpression
  },
  
  
  secondaryExpression: rule {
    primaryExpression:expr ( messageSendFragment(expr):expr )*
    -> expr
  },
  
  messageSendFragment: rule (receiver) {
    | op('.') identifier:name argumentsList?:args
      -> Ast.MessageSend(receiver, name, args)
    | argumentsList:args
      -> Ast.ApplyMessageSend(receiver, args)
    | squareArgumentsList:args
      -> Ast.ApplyMessageSend(receiver, args)
  },
  
  
  argumentsList: rule {
    '(' delimited[expansion[expression], ',']:args ','? ')'
    -> args
  },
  
  squareArgumentsList: rule {
    '[' delimited[expansion[expression], ',']:args ','? ']'
    -> args
  },
  
  expansion: rule (alternative) {
    | op('..') expression:expr
      -> Ast.Expansion(expr)
    | alternative
  },
  
  
  primaryExpression: rule {
    | psuedoVariable
    | lexicalMessageSend
    | stringLiteral
    | numberLiteral
    | collectionLiteral
    | procedureLiteral
    | subexpression
  },
  
  psuedoVariable: rule {
    | id('self')  -> Ast.Self() // A compiler provided lexical binding
    | id('this')  -> Ast.This() // Current lexical context
    
    | id('nil')   -> Ast.Nil()
    | id('true')  -> Ast.True()
    | id('false') -> Ast.False()
  },
  
  lexicalMessageSend: rule {
    lexicalIdentifier:name argumentsList?:args
    -> Ast.LexicalMessageSend(name, args)
  },
  
  stringLiteral: rule {
    string:s
    -> Ast.String(s)
  },
  
  numberLiteral: rule {
    number:n
    -> Ast.Number(n)
  },
  
  collectionLiteral: rule {
    | '[' delimited[expansion[association], ',']:elems ','? ']'
      -> Ast.OrderedMap(elems)
    | '[' delimited[expansion[~association expression], ',']:elems ','? ']'
      -> Ast.Array(elems)
    | '{' delimited[expansion[expression], ',']:elems ','? ']'
      -> Ast.Map(elems)
    | '{' delimited[expansion[~association expression], ',']:elems ','? ']'
      -> Ast.Set(elems)
  },
  
  procedureLiteral: rule {
    parameterList?:ps op('->') expression:body
    -> Ast.Procedure(ps, body)
  },
  
  parameterList: rule {
    '(' delimited[contractionParameter, ',']:ps ','? ')' -> ps
  },
  
  constractionParameter: rule {
    | op('..') lexicalIdentifier:name
      -> Ast.ContractionParameter(name)
    | parameter
  },
  
  parameter: rule {
    | lexicalIdentifier:name -> Ast.Parameter(name)
    | id('_') -> Ast.IgnoredParameter()
  },
  
  subexpression: rule {
    '(' expression:expr ')'
    -> expr
  },
  
  
  // Token rules
  
  InvalidLexicalIdentifiers: [
    'self', 'true', 'false', 'nil', '_',
    
    'or', 'and', 'xor', 'not',
    
    'if', 'then', 'else', 'while', 'do', 'loop',
    'let', 'var',
    'return', 'break', 'continue',
    'end'
  ],
  
  lexicalIdentifier: rule {
    identifier:name ?(!this.InvalidLexicalIdentifiers.include(name)) -> name
  },
  
  number: rule {
    | decimalNumber
    | hexNumber
  },
  
  decimalNumber: rule {
    ws?
    matchedInput[ digit+ ('.' digit*)? (('e'|'E') digit+)? ]:text ~idChar
    -> parseFloat(text)
  },
  
  hexNumber: rule {
    ws?
    ('0x'|'0X') matchedInput[ hexDigit+ ]:text ~idChar
    -> parseFloat(text)
  },
  
  string: rule {
    ws?
    ( '\'' (~'\'' stringChar)*:cs '\''
    | '\"' (~'\"' stringChar)*:cs '\"'
    ) -> cs.join('')
  },
  
  stringChar: rule (delimiter) {
    | '\\' stringEscapeSequence
    | ~newline char
  },
  
  stringEscapeSequence: rule {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | '0'  -> '\x00' // ^@  Null Character
    | 'a'  -> '\x07' // ^G  Alarm/Bell
    | 'b'  -> '\x08' // ^H  Backspace
    | 't'  -> '\x09' // ^I  Tab
    | 'n'  -> '\x0a' // ^J  Line Feed
    | 'v'  -> '\x0b' // ^K  Vertical Tab
    | 'f'  -> '\x0c' // ^L  Form Feed
    | 'r'  -> '\x0d' // ^M  Carriage Return
    | 'e'  -> '\x1b' // ^[  Escape
    | 'x' repeat[hexDigit, %2]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %4]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' '(' hexDigit*:hs ')' -> String.fromCodepoint(hs.join(''))
    | error('Unsupported escape sequence')
  },
  
  id: rule (expectedName) {
    identifier:name ?(name === expectedName) -> name
  },
  
  identifier: rule {
    ws? matchedInput[initialIdChar idChar*]
  },
  
  op: rule (expectedOpname) {
    operator:opname ?(opname === expectedOpname) -> opname
  },
  
  operator: rule {
    ws?
    ( '<<' | '>>>' | '>>' | '<>' | '<=' | '>=' | '<' | '>'
    | '/=' | '=' | '!'
    | '||' | '|' | '^^' | '^' | '&&' | '&'
    | '+' | '-' | '**' | '*' | '//' | '/' | '%' | '~'
    | '->' | '=>' | '<-' | '..' | '.'
    ):text
    -> text
  },
  
  ws: rule {
    (
      ( spaces | comment )+
      continuationLine
    )+
  },
  
  statementTerminator: rule {
    | ws? blankline* newline &( currentIndentation ~ws )
    | ws? ';'
  },
  
  blankline: rule {
    newline ( spaces | comment )+ &newline
  },
  
  continuationLine: rule {
    | '\\' newline ( spaces | comment )+
    | newline currentIndentation ( spaces | comment )+
  },
  
  currentIndentation: function () {
    for (var i = 0; i < this.state.indentationLevelStack.last; i++) {
      this.space()
    }
  },
  
  indent: rule {
    currentIndentation spaces:ss
    !(this.state.indentationLevelStack.push(this.state.indentationLevelStack.last + ss.length);
  },
  
  dedent: rule { // Only dedents a single level!
    ~currentIndentation
    !(this.state.indentationLevelStack.pop())
    currentIndentation
  },
  
  dedentMany: rule {
    (
      ~currentIndentation
      !(this.state.indentationLevelStack.pop())
    )+
    currentIndentation
  },
  
  comment: rule {
    | delimitedComment
    | lineComment
  },
  
  delimitedComment: rule {
    '{-' &(space | newline | '-}')
    ( ~'-}' (delimitedComment | char) )*
    ('-}' | eof)
  },
  
  lineComment: rule {
    '--' (~newline char)* newline
  },
  
  newline: rule { '\r\n' | '\n' | '\r' | eof },
  
  digit: rule { char('0'..'9') },
  
  hexDigit: rule { char('0'..'9', 'a'..'f', 'A'..'F') },
  
  idChar:        rule { char('a'..'z', 'A'..'Z', '_', '0'..'9') },
  initialIdChar: rule { char('a'..'z', 'A'..'Z', '_') },
  
  space: rule { ' ' },
  spaces: rule { space+ },
  
  
  // Basic Parser Functionality
  
  next: function () {
    var c = TextParser.prototype.next.call(this);
    this.furthestPosition = Math.max(
      this.futhestPosition,
      this.state.position
    );
    return c;
  },
  
  nextIf: function (predicate) {
    var c = TextParser.prototype.next.call(this);
    if (predicate.call(this, c)) {
      this.furthestPosition = Math.max(
        this.furthestPosition,
        this.state.position
      );
      return c;
    }
    else {
      return this.fail();
    }
  },
  
  emptyState: function () {
    return {
      position: 0,
      indentationLevelStack: [0],
    };
  },
  
  copyState: function () {
    return {
      position: this.state.position,
      indentationLevelStack: this.state.indentationLevelStack.copy(),
    };
  },
  
  stringPatternHandler: rule (string) {
    ws? eachChar(string)
  },
  
  tokenOperatorHandler: rule (parser) {
    ws? parser
  },
  
  // Layout rules
  // 1. A line terminator followed by an indentation level the same length as the
  //    current block's indentation level is considered a statement terminator.
  // 2. If a line has an indentation level deeper than the current blocks, it
  //    is considered a continuation line of the current statement.
  // 3. Only a block scope changes the current block indentation level. Respectively
  //    all blocks are terminated by an 'end' token at the beginning of a line and
  //    are begun by either a 'do' token at the end of a line or a special syntactic
  //    case, i.e., if statements.
  // 4. Semicolons may be used to add additional statements to a line. These may
  //    still be used to denote blocks, and the same layout rules apply treating
  //    the semicolons as newlines, but not changing the indentation level until
  //    a fresh line is provided at the new indentation level.
  // 5. Trailing semicolons on a line are ignored and do not affect the above rules.
  
});
