/*
  The Metaphor Programming Language
  
  Copyright 2011 Lorenz Pretterhofer

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
'use strict';

var combe = require('combe');
var TextParser = combe.TextParser;

var Ast = require('./Ast');

var Parser = module.exports = Class.new(TextParser, {
  
  parseFile: function (source, filename) {
    return this.parse(source, filename, 'file');
  },
  
  parse: function (source, filename, rulename) {
    var rest = Array.slice(arguments, 3);
    if (filename == null) filename = '(unnamed)';
    
    var parser = this.new(source, filename);
    var result = parser.match.apply(parser, [rulename].concat(rest));
    if (!result) {
      var lc = source.lineColumnAt(parser.furthestPosition);
      throw Error.new('Combe/Newlang Parser Failed: Furthest position was ' + filename + ':' + lc[0] + ':' + lc[1]);
    }
    return result;
  },
  
}, {
  
  initialize: function (source, filename) {
    if (filename == null) filename = '(unnamed)';
    
    this.source = source;
    this.filename = filename;
    TextParser.prototype.initialize.call(this, source);
  },
  
  
  // Syntactic Rules
  
  file: rule {
    delimited[statement, statementTerminator]:stmts ws? eof
    -> Ast.File(Ast.Block(stmts))
  },
  
  statement: rule {
    | ifStatement
    | expression
  },
  
  expression: rule {
    | ifExpression
    | varExpression
    | returnExpression
    | throwExpression
    | operatorExpression
  },
  
  ifStatement: rule {
    id('if') expression:c statementTerminator
      blockBody:b
    !(Ast.If(c, b, null)):ast !(ast):tail
    (
      id('else') id('if') expression:c statementTerminator
        blockBody:b
      !(tail.alternative = Ast.If(c, b, null)) !(tail.alternative):tail
    )*
    (
      id('else') statementTerminator
        blockBody:b
      !(tail.alternative = b)
    )?
    id('end')
    -> ast
  },
  
  ifExpression: rule {
    id('if') expression:condition
    id('then') expression:consiquent
    ( id('else') expression:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  },
  
  varExpression: rule {
    id('var') variableIdentifier:name ( op('=') assignmentExpression:rvalue )?
    -> Ast.Var(name, rvalue)
  },
  
  returnExpression: rule {
    id('return') expression?:arg
    -> Ast.Return(arg)
  },
  
  throwExpression: rule {
    id('throw') expression?:arg
    -> Ast.Throw(arg)
  },
  
  
  blockBody: rule {
    | (
        indent
        delimited[statement, statementTerminator]:stmts
        dedent
      )
      -> Ast.Block(stmts)
    | -> Ast.Noop()
  },
  
  
  operatorExpression: rule {
    assignmentExpression
  },
  
  assignmentExpression: rule {
    | lvalueExpression:lvalue op('=') assignmentExpression:rvalue
      -> {
        if (lvalue.is('VariableLookup')) {
          return Ast.VariableAssignment(lvalue.name, rvalue);
        }
        else if (lvalue.is('PropertyLookup')) {
          return Ast.PropertyAssignment(lvalue.object, lvalue.name, rvalue);
        }
        else if (lvalue.is('PrototypePropertyAssignment')) {
          return Ast.PrototypePropertyAssignment(lvalue.object, lvalue.name, rvalue);
        }
        else assert(false);
      }
    | logicalOperator
  },
  
  
  lvalueExpression: rule {
    | lvalueSecondaryExpression
    | lvaluePrimaryExpression
  },
  
  lvaluePrimaryExpression: rule {
    variableLookup
  },
  
  lvalueSecondaryExpression: rule {
    primaryExpression:expr ( lvalueSecondaryExpressionFragment(expr):expr )+
    -> expr
  },
  
  lvalueSecondaryExpressionFragment: rule (expr) {
    | op('.') propertyName:pname
      -> Ast.PropertyLookup(expr, pname)
    | op(':') propertyName:pname
      -> Ast.PrototypePropertyLookup(expr, pname)
  },
  
  
  logicalOperator: rule {
    wordedLogicalOr
  },
  
  wordedLogicalOr: rule {
    wordedLogicalXor:expr
    ( id('or') wordedLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalXor: rule {
    wordedLogicalAnd:expr
    ( id('xor') wordedLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalAnd: rule {
    wordedLogicalNot:expr
    ( id('and') wordedLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalNot: rule {
    | id('not') wordedLogicalNot:expr
      -> Ast.Not(expr)
    | symbolicLogicalOr
  },
  
  symbolicLogicalOr: rule {
    symbolicLogicalXor:expr
    ( op('||') symbolicLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalXor: rule {
    symbolicLogicalAnd:expr
    ( op('^^') symbolicLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalAnd: rule {
    symbolicLogicalNot:expr
    ( op('&&') symbolicLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalNot: rule {
    | op('!') symbolicLogicalNot:expr
      -> Ast.Not(expr)
    | equalityOperator
  },
  
  equalityOperator: rule {
    // Todo: Allow Math style sequences of equality operators (i.e., 0 <= i < length) 
    comparisonOperator:expr
    ( (op('==') | op('!=') | op('<=') | op('<') | op('>=') | op('>') ):opname
      comparisonOperator:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  comparisonOperator: rule {
    association:expr
    ( op('<>'):opname association:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  association: rule {
    | propertyName:lhs op(':') bitwiseOr:rhs
      -> Ast.Association(lhs, rhs)
    | bitwiseOr:lhs op('=>') bitwiseOr:rhs
      -> Ast.Association(lhs, rhs)
  },
  
  bitwiseOr: rule {
    leftAssocOperator[bitwiseXor op('|')]
  },
  bitwiseXor: rule {
    leftAssocOperator[bitwiseAnd op('^')]
  },
  bitwiseAnd: rule {
    leftAssocOperator[shiftOperator op('&')]
  },
  
  shiftOperator: rule {
    leftAssocOperator[additionOperator, ( op('<<') | op('>>') | op('>>>') )]
  },
  additionOperator: rule {
    leftAssocOperator[multiplicationOperator, ( op('+') | op('-') )]
  },
  multiplicationOperator: rule {
    leftAssocOperator[exponentiationOperator, ( op('*') | op('/') | op('//') | op('%') )]
  },
  exponentiationOperator: rule {
    rightAssocOperator[prefixOperatorExpression, op('**')]
  },
  
  leftAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname term:rhs
      !(expr = Ast.Operator(opname, expr, rhs))
    )*
    -> expr
  },
  rightAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname rightAssocOperator(term, operator):rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  prefixOperatorExpression: rule {
    | ( op('+') | op('-') | op('~') ):opname prefixOperatorExpression:expr
      -> Ast.PrefixOperator(opname, expr)
    | secondaryExpression
  },
  
  
  secondaryExpression: rule {
    primaryExpression:expr ( secondaryExpressionFragment(expr):expr )*
    -> expr
  },
  
  secondaryExpressionFragment: rule (expr) {
    | op('.') propertyName:pname argumentsList:ad
      -> Ast.MethodCall(expr, pname, ad.this, ad.arguments)
    | op('.') propertyName:pname
      -> Ast.PropertyLookup(expr, pname)
    | op(':') propertyName:pname argumentsList:ad
      -> Ast.PrototypeMethodCall(expr, pname, ad.this, ad.arguments)
    | op(':') propertyName:pname
      -> Ast.PrototypePropertyLookup(expr, pname)
    | argumentsList:ad
      -> Ast.Call(expr, ad.this, ad.arguments)
    | subscript:args
      -> Ast.Subscript(expr, args)
  },
  
  
  argumentsList: rule {
    #'(' 
      ( expression:t #';' )?
      delimited[expansion[expression], #',']:args #','?
    #')'
    -> { this: t, arguments: args }
  },
  
  subscript: rule {
    #'[' delimited[expansion[expression], #',']:args #','? #']'
    -> args
  },
  
  expansion: rule (alternative) {
    | op('..') expression:expr
      -> Ast.ExpandArguments(expr)
    | alternative
  },
  
  
  primaryExpression: rule {
    | psuedoVariable
    | variableLookup
    | stringLiteral
    | numberLiteral
    | objectLiteral
    | functionLiteral
    | subexpression
  },
  
  psuedoVariable: rule {
    | id('this')      -> Ast.This()
    
    | id('null')      -> Ast.Null()
    | id('undefined') -> Ast.Undefined()
    | id('true')      -> Ast.True()
    | id('false')     -> Ast.False()
  },
  
  variableLookup: rule {
    variableIdentifier:name
    -> Ast.VariableLookup(name)
  },
  
  stringLiteral: rule {
    string:s
    -> Ast.String(s)
  },
  
  numberLiteral: rule {
    number:n
    -> Ast.Number(n)
  },
  
  objectLiteral: rule {
    #'{'
      ( expression:proto #';' )?
      delimited[propertyDeclaration, #',']:pdecls #','? 
    #'}'
    -> Ast.Object(proto, pdecls)
  },
  
  functionLiteral: rule {
    | optParameterList:pd op('->') expression:body
      -> Ast.Function(pd.this, pd.parameters, body)
    | id('fn') optParameterList:pd functionBody:body
      -> Ast.Function(pd.this, pd.parameters, body)
  },
  
  functionBody: rule {
    | op('->') expression:body -> body
    | statementTerminator
        blockBody:body
      id('end')
      -> body
  },
    
  
  subexpression: rule {
    #'(' expression:expr #')'
    -> expr
  },
  
  
  optParameterList: rule {
    parameterList:pd
    -> (pd != null ? pd : { this: null, parameters: [] })
  },
  parameterList: rule {
    #'('
      ( parameter:t #';' )?
      delimited[contractionParameter, #',']:params #','?
    #')'
    -> { this: t, parameters: params }
  },
  
  contractionParameter: rule {
    | op('..') variableIdentifier:name
      -> Ast.ContractParameters(name)
    | parameter
  },
  
  parameter: rule {
    | variableIdentifier:name -> Ast.Parameter(name)
    | id('_') -> Ast.IgnoredParameter()
  },
  
  
  propertyDeclaration: rule {
    | valuePropertyDeclaration
    | getPropertyDeclaration
    | setPropertyDeclaration
    | methodPropertyDeclaration
    | describePropertyDeclaration
  },
  
  valuePropertyDeclaration: rule {
    propertyName:name op(':') expression:value
    -> Ast.ValuePropertyDeclaration(name, value)
  },
  
  getPropertyDeclaration: rule {
    id('get') propertyName:name optParameterList:pd functionBody:body
    -> Ast.GetPropertyDeclaration(name, pd.this, pd.parameters, body)
  },
  
  setPropertyDeclaration: rule {
    id('set') propertyName:name optParameterList:pd functionBody:body
    -> Ast.SetPropertyDeclaration(name, pd.this, pd.parameters, body)
  },
  
  methodPropertyDeclaration: rule {
    id('method') propertyName:name optParameterList:pd functionBody:body
    -> Ast.MethodPropertyDeclaration(name, pd.this, pd.parameters, body)
  },
  
  describePropertyDeclaration: rule {
    id('describe') propertyName:name op(':') expression:dict
    -> Ast.DescribePropertyDeclaration(name, dict)
  },
  
  
  propertyName: rule {
    | identifier:name -> Ast.String(name)
    | stringLiteral
  },
  
  
  // Token rules
  
  // Todo: The strings used here are sometimes treated as string patterns, 
  // which means that their whitespace handling may not be setup correctly.
  // I'm probably going to want to figure out a better way of implementing
  // separated lexers without the problems of maintaining separate state
  // (i.e., like some sort of quasi-lexer/parser pair which replace the usage
  // of 'this' for state with monad style state management?)
  
  InvalidVariableIdentifiers: [
    'this', 'true', 'false', 'null', 'undefined', '_',
    
    'or', 'and', 'xor', 'not',
    
    'if', 'then', 'else',
    'var',
    'return', 'throw',
    'do', 'end'
  ],
  
  variableIdentifier: rule {
    identifier:name ?(!this.InvalidVariableIdentifiers.include(name)) -> name
  },
  
  number: rule {
    | decimalNumber
    | hexNumber
  },
  
  decimalNumber: rule {
    ws?
    matchedInput[ digit+ ('.' digit*)? (('e'|'E') digit+)? ]:text ~idChar
    -> parseFloat(text)
  },
  
  hexNumber: rule {
    ws?
    ('0x'|'0X') matchedInput[ hexDigit+ ]:text ~idChar
    -> parseFloat(text)
  },
  
  string: rule {
    ws?
    ( '\'' (~'\'' stringChar)*:cs '\''
    | '\"' (~'\"' stringChar)*:cs '\"'
    ) -> cs.join('')
  },
  
  stringChar: rule (delimiter) {
    | '\\' stringEscapeSequence
    | ~newline char
  },
  
  stringEscapeSequence: rule {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | '0'  -> '\x00' // ^@  Null Character
    | 'a'  -> '\x07' // ^G  Alarm/Bell
    | 'b'  -> '\x08' // ^H  Backspace
    | 't'  -> '\x09' // ^I  Tab
    | 'n'  -> '\x0a' // ^J  Line Feed
    | 'v'  -> '\x0b' // ^K  Vertical Tab
    | 'f'  -> '\x0c' // ^L  Form Feed
    | 'r'  -> '\x0d' // ^M  Carriage Return
    | 'e'  -> '\x1b' // ^[  Escape
    | 'x' repeat[hexDigit, %2]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %4]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' '(' hexDigit*:hs ')' -> String.fromCodepoint(hs.join(''))
    | error('Unsupported escape sequence')
  },
  
  id: rule (expectedName) {
    identifier:name ?(name === expectedName) -> name
  },
  
  identifier: rule {
    ws? matchedInput[initialIdChar idChar*]
  },
  
  op: rule (expectedOpname) {
    operator:opname ?(opname === expectedOpname) -> opname
  },
  
  operator: rule {
    ws?
    ( '<<' | '>>>' | '>>' | '<>' | '<=' | '>=' | '<' | '>'
    | '!=' | '==' | '!' | '='
    | '||' | '|' | '^^' | '^' | '&&' | '&'
    | '+' | '-' | '**' | '*' | '//' | '/' | '%' | '~'
    | '->' | '=>' | '<-' | '..' | '.'
    ):text
    -> text
  },
  
  ws: rule {
    (
      ( spaces | comment )+
      continuationLine
    )+
  },
  
  statementTerminator: rule {
    | ws? blankline* newline &( currentIndentation ~ws )
    | ws? ';'
  },
  
  blankline: rule {
    newline ( spaces | comment )+ &newline
  },
  
  continuationLine: rule {
    | '\\' newline ( spaces | comment )+
    | newline currentIndentation ( spaces | comment )+
  },
  
  currentIndentation: function () {
    for (var i = 0; i < this.state.indentationLevelStack.last; i++) {
      this.space();
    }
  },
  
  indent: rule {
    currentIndentation spaces:ss
    !(this.state.indentationLevelStack.push(this.state.indentationLevelStack.last + ss.length))
  },
  
  dedent: rule { // Only dedents a single level!
    ~currentIndentation
    !(this.state.indentationLevelStack.pop())
    currentIndentation
  },
  
  dedentMany: rule {
    (
      ~currentIndentation
      !(this.state.indentationLevelStack.pop())
    )+
    currentIndentation
  },
  
  comment: rule {
    | delimitedComment
    | lineComment
  },
  
  delimitedComment: rule {
    '{-' &(space | newline | '-}')
    ( ~'-}' (delimitedComment | char) )*
    ('-}' | eof)
  },
  
  lineComment: rule {
    '--' (~newline char)* newline
  },
  
  newline: rule { '\r\n' | '\n' | '\r' | eof },
  
  digit: rule { char('0'..'9') },
  
  hexDigit: rule { char('0'..'9', 'a'..'f', 'A'..'F') },
  
  idChar:        rule { char('a'..'z', 'A'..'Z', '_', '$', '0'..'9') },
  initialIdChar: rule { char('a'..'z', 'A'..'Z', '_', '$') },
  
  space: rule { ' ' },
  spaces: rule { space+ },
  
  
  // Basic Parser Functionality
  
  next: function () {
    var c = TextParser.prototype.next.call(this);
    this.furthestPosition = Math.max(
      this.futhestPosition,
      this.state.position
    );
    return c;
  },
  
  nextIf: function (predicate) {
    var c = TextParser.prototype.next.call(this);
    if (predicate.call(this, c)) {
      this.furthestPosition = Math.max(
        this.furthestPosition,
        this.state.position
      );
      return c;
    }
    else {
      return this.fail();
    }
  },
  
  emptyState: function () {
    return {
      position: 0,
      indentationLevelStack: [0],
    };
  },
  
  copyState: function () {
    return {
      position: this.state.position,
      indentationLevelStack: this.state.indentationLevelStack.copy(),
    };
  },
  
  stringPatternHandler: rule (string) {
    eachChar(string)
  },
  
  tokenOperatorHandler: rule (parser) {
    ws? parser
  },
  
  // Layout rules
  // 1. A line terminator followed by an indentation level the same length as the
  //    current block's indentation level is considered a statement terminator.
  // 2. If a line has an indentation level deeper than the current blocks, it
  //    is considered a continuation line of the current statement.
  // 3. Only a block scope changes the current block indentation level. Respectively
  //    all blocks are terminated by an 'end' token at the beginning of a line and
  //    are begun by either a 'do' token at the end of a line or a special syntactic
  //    case, i.e., if statements.
  // 4. Semicolons may be used to add additional statements to a line. These may
  //    still be used to denote blocks, and the same layout rules apply treating
  //    the semicolons as newlines, but not changing the indentation level until
  //    a fresh line is provided at the new indentation level.
  // 5. Trailing semicolons on a line are ignored and do not affect the above rules.
  
});
