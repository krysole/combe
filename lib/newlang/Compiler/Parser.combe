/*
  The Metaphor Programming Language
  
  Copyright 2011 Lorenz Pretterhofer

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
'use strict';

var combe = require('combe');
var TextParser = combe.TextParser;

var Ast = require('./Ast');

var Parser = module.exports = Class.new(TextParser, {
  
  parseFile: function (source, filename) {
    return this.parse(source, filename, 'file');
  },
  
  parse: function (source, filename, rulename) {
    var rest = Array.slice(arguments, 3);
    if (filename == null) filename = '(unnamed)';
    
    var parser = this.new(source, filename);
    var result = parser.match.apply(parser, [rulename].concat(rest));
    if (!result) {
      var lc = source.lineColumnAt(parser.furthestPosition);
      throw Error.new('Combe/Newlang Parser Failed: Furthest position was ' + filename + ':' + lc[0] + ':' + lc[1]);
    }
    return result;
  },
  
}, {
  
  initialize: function (source, filename) {
    if (filename == null) filename = '(unnamed)';
    
    this.source = source;
    this.filename = filename;
    this.furthestPosition = 0;
    TextParser.prototype.initialize.call(this, source);
  },
  
  
  // Syntactic Rules
  
  file: rule {
    blankline*
    delimited[statement, statementTerminator]:stmts statementTerminator?
    eof
    -> Ast.File(Ast.Block(stmts))
  },
  
  statement: rule {
    | emptyStatement
    | ifStatement
    | expression
  },
  
  expression: rule {
    | ifExpression
    | varExpression
    | returnExpression
    | throwExpression
    | operatorExpression
  },
  
  emptyStatement: rule {
    &( ( spaces | comment )* ';' )
  },
  
  ifStatement: rule {
    specialBlock[
      id('if') expression
    ]:sb
    !(Ast.If(sb.header, sb.body, null)):ast !(ast):tail
    (
      specialBlock[
        id('else') id('if') expression
      ]:sb
      !(tail.alternative = Ast.If(sb.header, sb.body, null)) !(tail.alternative):tail
    )*
    ( specialBlock[
        id('else')
      ]:sb
      !(tail.alternative = sb.body)
    | !(tail.alternative = Ast.Noop())
    )?
    id('end')
    -> ast
  },
  
  ifExpression: rule {
    id('if') expression:condition
    id('then') expression:consiquent
    ( id('else') expression:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  },
  
  varExpression: rule {
    id('var') variableIdentifier:name ( op('=') assignmentExpression:rvalue )?
    -> Ast.Var(name, rvalue)
  },
  
  returnExpression: rule {
    id('return') expression?:arg
    -> Ast.Return(arg)
  },
  
  throwExpression: rule {
    id('throw') expression?:arg
    -> Ast.Throw(arg)
  },
  
  
  specialBlock: rule (header) {
    blockHeader(header):h
    
    ( &increasedIndentation withIncreasedIndentation[
        delimited[statement, statementTerminator]:stmts statementTerminator?
      ]
      -> { header: h, body: Ast.Block(stmts) }
    | -> { header: h, body: Ast.Noop() }
    )
  },
  
  
  operatorExpression: rule {
    assignmentExpression
  },
  
  assignmentExpression: rule {
    | lvalueExpression:lvalue op('=') assignmentExpression:rvalue
      -> {
        if (lvalue.is('VariableLookup')) {
          return Ast.VariableAssignment(lvalue.name, rvalue);
        }
        else if (lvalue.is('PropertyLookup')) {
          return Ast.PropertyAssignment(lvalue.object, lvalue.name, rvalue);
        }
        else if (lvalue.is('PrototypePropertyAssignment')) {
          return Ast.PrototypePropertyAssignment(lvalue.object, lvalue.name, rvalue);
        }
        else assert(false);
      }
    | logicalOperator
  },
  
  
  lvalueExpression: rule {
    | lvalueSecondaryExpression
    | lvaluePrimaryExpression
  },
  
  lvaluePrimaryExpression: rule {
    variableLookup
  },
  
  lvalueSecondaryExpression: rule {
    primaryExpression:expr ( lvalueSecondaryExpressionFragment(expr):expr )+
    -> expr
  },
  
  lvalueSecondaryExpressionFragment: rule (expr) {
    | op('.') propertyName:pname
      -> Ast.PropertyLookup(expr, pname)
    | op(':') propertyName:pname
      -> Ast.PrototypePropertyLookup(expr, pname)
  },
  
  
  logicalOperator: rule {
    wordedLogicalOr
  },
  
  wordedLogicalOr: rule {
    wordedLogicalXor:expr
    ( id('or') wordedLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalXor: rule {
    wordedLogicalAnd:expr
    ( id('xor') wordedLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalAnd: rule {
    wordedLogicalNot:expr
    ( id('and') wordedLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalNot: rule {
    | id('not') wordedLogicalNot:expr
      -> Ast.Not(expr)
    | symbolicLogicalOr
  },
  
  symbolicLogicalOr: rule {
    symbolicLogicalXor:expr
    ( op('||') symbolicLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalXor: rule {
    symbolicLogicalAnd:expr
    ( op('^^') symbolicLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalAnd: rule {
    symbolicLogicalNot:expr
    ( op('&&') symbolicLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalNot: rule {
    | op('!') symbolicLogicalNot:expr
      -> Ast.Not(expr)
    | equalityOperator
  },
  
  equalityOperator: rule {
    // Todo: Allow Math style sequences of equality operators (i.e., 0 <= i < length) 
    comparisonOperator:expr
    ( (op('==') | op('!=') | op('<=') | op('<') | op('>=') | op('>') ):opname
      comparisonOperator:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  comparisonOperator: rule {
    associationOperator:expr
    ( op('<>'):opname association:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  associationOperator: rule {
    | association
    | bitwiseOr
  },
  association: rule {
    | propertyName:lhs op(':') bitwiseOr:rhs
      -> Ast.Association(lhs, rhs)
    | bitwiseOr:lhs op('=>') bitwiseOr:rhs
      -> Ast.Association(lhs, rhs)
  },
  
  bitwiseOr: rule {
    leftAssocOperator[bitwiseXor, op('|')]
  },
  bitwiseXor: rule {
    leftAssocOperator[bitwiseAnd, op('^')]
  },
  bitwiseAnd: rule {
    leftAssocOperator[shiftOperator, op('&')]
  },
  
  shiftOperator: rule {
    leftAssocOperator[additionOperator, ( op('<<') | op('>>') | op('>>>') )]
  },
  additionOperator: rule {
    leftAssocOperator[multiplicationOperator, ( op('+') | op('-') )]
  },
  multiplicationOperator: rule {
    leftAssocOperator[exponentiationOperator, ( op('*') | op('/') | op('//') | op('%') )]
  },
  exponentiationOperator: rule {
    rightAssocOperator[prefixOperatorExpression, op('**')]
  },
  
  leftAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname term:rhs
      !(expr = Ast.Operator(opname, expr, rhs))
    )*
    -> expr
  },
  rightAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname rightAssocOperator(term, operator):rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  prefixOperatorExpression: rule {
    | ( op('+') | op('-') | op('~') ):opname prefixOperatorExpression:expr
      -> Ast.PrefixOperator(opname, expr)
    | secondaryExpression
  },
  
  
  secondaryExpression: rule {
    primaryExpression:expr ( secondaryExpressionFragment(expr):expr )*
    -> expr
  },
  
  secondaryExpressionFragment: rule (expr) {
    | op('.') propertyName:pname argumentsList:ad
      -> Ast.MethodCall(expr, pname, ad.this, ad.arguments)
    | op('.') propertyName:pname
      -> Ast.PropertyLookup(expr, pname)
    | op(':') propertyName:pname argumentsList:ad
      -> Ast.PrototypeMethodCall(expr, pname, ad.this, ad.arguments)
    | op(':') propertyName:pname
      -> Ast.PrototypePropertyLookup(expr, pname)
    | argumentsList:ad
      -> Ast.Call(expr, ad.this, ad.arguments)
    | subscript:args
      -> Ast.Subscript(expr, args)
  },
  
  
  argumentsList: rule {
    #'('
    ignoringIndentation[
      ( expression:t #';' )?
      delimited[expansion[expression], #',']:args #','?
    ]
    #')'
    -> { this: t, arguments: args }
  },
  
  subscript: rule {
    #'['
    ignoringIndentation[
      delimited[expansion[expression], #',']:args #','?
    ]
    #']'
    -> args
  },
  
  expansion: rule (alternative) {
    | op('..') expression:expr
      -> Ast.ExpandArguments(expr)
    | alternative
  },
  
  
  primaryExpression: rule {
    | psuedoVariable
    | variableLookup
    | stringLiteral
    | numberLiteral
    | objectLiteral
    | functionLiteral
    | subexpression
  },
  
  psuedoVariable: rule {
    | id('this')      -> Ast.This()
    
    | id('null')      -> Ast.Null()
    | id('undefined') -> Ast.Undefined()
    | id('true')      -> Ast.True()
    | id('false')     -> Ast.False()
  },
  
  variableLookup: rule {
    variableIdentifier:name
    -> Ast.VariableLookup(name)
  },
  
  stringLiteral: rule {
    string:s
    -> Ast.String(s)
  },
  
  numberLiteral: rule {
    number:n
    -> Ast.Number(n)
  },
  
  objectLiteral: rule {
    #'{'
    ignoringIndentation[
      ( expression:proto #';' )?
      delimited[propertyDeclaration, #',']:pdecls #','? 
    ]
    #'}'
    -> Ast.Object(proto, pdecls)
  },
  
  functionLiteral: rule {
    | id('fn')? optParameterList:pd op('->') expression:body
      -> Ast.Function(pd.this, pd.parameters, body)
    | specialBlock[ id('fn') optParameterList:pd ]:sb
      id('end')
      -> Ast.Function(pd.this, pd.parameters, sb.body)
  },
    
  
  subexpression: rule {
    #'(' ignoringIndentation[ expression:expr ] #')'
    -> expr
  },
  
  
  optParameterList: rule {
    parameterList:pd
    -> (pd != null ? pd : { this: null, parameters: [] })
  },
  parameterList: rule {
    #'('
    ignoringIndentation[
      ( parameter:t #';' )?
      delimited[contractionParameter, #',']:params #','?
    ]
    #')'
    -> { this: t, parameters: params }
  },
  
  contractionParameter: rule {
    | op('..') variableIdentifier:name
      -> Ast.ContractParameters(name)
    | parameter
  },
  
  parameter: rule {
    | variableIdentifier:name -> Ast.Parameter(name)
    | id('_') -> Ast.IgnoredParameter()
  },
  
  
  propertyDeclaration: rule {
    | valuePropertyDeclaration
    | getPropertyDeclaration
    | setPropertyDeclaration
    | methodPropertyDeclaration
    | describePropertyDeclaration
  },
  
  valuePropertyDeclaration: rule {
    propertyName:name op(':') expression:value
    -> Ast.ValuePropertyDeclaration(name, value)
  },
  
  getPropertyDeclaration: rule {
    id('get') propertyName:name optParameterList:pd functionBody:body
    -> Ast.GetPropertyDeclaration(name, pd.this, pd.parameters, body)
  },
  
  setPropertyDeclaration: rule {
    id('set') propertyName:name optParameterList:pd functionBody:body
    -> Ast.SetPropertyDeclaration(name, pd.this, pd.parameters, body)
  },
  
  methodPropertyDeclaration: rule {
    id('method') propertyName:name optParameterList:pd functionBody:body
    -> Ast.MethodPropertyDeclaration(name, pd.this, pd.parameters, body)
  },
  
  describePropertyDeclaration: rule {
    id('describe') propertyName:name op(':') expression:dict
    -> Ast.DescribePropertyDeclaration(name, dict)
  },
  
  
  propertyName: rule {
    | identifier:name -> Ast.String(name)
    | stringLiteral
  },
  
  
  // Token rules
  
  InvalidVariableIdentifiers: [
    'this', 'true', 'false', 'null', 'undefined', '_',
    
    'or', 'and', 'xor', 'not',
    
    'if', 'then', 'else',
    'var',
    'return', 'throw',
    'do', 'end'
  ],
  
  variableIdentifier: rule {
    identifier:name ?(!this.InvalidVariableIdentifiers.include(name)) -> name
  },
  
  number: rule {
    | decimalNumber
    | hexNumber
  },
  
  decimalNumber: rule {
    ws?
    matchedInput[ digit+ ('.' digit*)? (('e'|'E') digit+)? ]:text ~idChar
    -> parseFloat(text)
  },
  
  hexNumber: rule {
    ws?
    ('0x'|'0X') matchedInput[ hexDigit+ ]:text ~idChar
    -> parseFloat(text)
  },
  
  string: rule {
    ws?
    ( '\'' (~'\'' stringChar)*:cs '\''
    | '\"' (~'\"' stringChar)*:cs '\"'
    ) -> cs.join('')
  },
  
  stringChar: rule (delimiter) {
    | '\\' stringEscapeSequence
    | ~newline char
  },
  
  stringEscapeSequence: rule {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | '0'  -> '\x00' // ^@  Null Character
    | 'a'  -> '\x07' // ^G  Alarm/Bell
    | 'b'  -> '\x08' // ^H  Backspace
    | 't'  -> '\x09' // ^I  Tab
    | 'n'  -> '\x0a' // ^J  Line Feed
    | 'v'  -> '\x0b' // ^K  Vertical Tab
    | 'f'  -> '\x0c' // ^L  Form Feed
    | 'r'  -> '\x0d' // ^M  Carriage Return
    | 'e'  -> '\x1b' // ^[  Escape
    | 'x' repeat[hexDigit, %2]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %4]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' '(' hexDigit*:hs ')' -> String.fromCodepoint(hs.join(''))
    | error('Unsupported escape sequence')
  },
  
  id: rule (expectedName) {
    identifier:name ?(name === expectedName) -> name
  },
  
  identifier: rule {
    ws? matchedInput[initialIdChar idChar*]
  },
  
  op: rule (expectedOpname) {
    operator:opname ?(opname === expectedOpname) -> opname
  },
  
  operator: rule {
    ws?
    ( '<<' | '>>>' | '>>' | '<>' | '<=' | '>=' | '<' | '>'
    | '!=' | '==' | '!' | '='
    | '||' | '|' | '^^' | '^' | '&&' | '&'
    | '+' | '-' | '**' | '*' | '//' | '/' | '%' | '~'
    | '->' | '=>' | '<-' | '..' | '.'
    ):text
    -> text
  },
  
  comment: rule {
    | delimitedComment
    | lineComment
  },
  
  delimitedComment: rule {
    '{-' &(space | newline | eof | '-}')
    ( ~'-}' (delimitedComment | char) )*
    ('-}' | eof)
  },
  
  lineComment: rule {
    '--' (~newline char)* &( newline | eof )
  },
  
  newline: rule { '\r\n' | '\n' | '\r' },
  
  digit: rule { char('0'..'9') },
  
  hexDigit: rule { char('0'..'9', 'a'..'f', 'A'..'F') },
  
  idChar:        rule { char('a'..'z', 'A'..'Z', '_', '$', '0'..'9') },
  initialIdChar: rule { char('a'..'z', 'A'..'Z', '_', '$') },
  
  space: rule { ' ' },
  spaces: rule { space+ },
  
  
  // Basic Parser Functionality
  
  next: function () {
    var c = TextParser.prototype.next.call(this);
    this.furthestPosition = Math.max(
      this.furthestPosition,
      this.state.position
    );
    return c;
  },
  
  nextIf: function (predicate) {
    var c = TextParser.prototype.next.call(this);
    if (predicate.call(this, c)) {
      this.furthestPosition = Math.max(
        this.furthestPosition,
        this.state.position
      );
      return c;
    }
    else {
      return this.fail();
    }
  },
  
  emptyState: function () {
    return {
      position: 0,
      blocks: [
        {
          ignoreIndentation: false,
          columnCount: 0,
        }
      ],
    };
  },
  
  copyState: function () {
    return {
      position: this.state.position,
      blocks: this.state.blocks.copy(),
    };
  },
  
  stringPatternHandler: rule (string) {
    eachChar(string)
  },
  
  tokenOperatorHandler: rule (parser) {
    ws? parser
  },
  
  debuglog: function (name, index) {
    var lc = this.source.lineColumnAt(this.state.position);
    var output = 'Debug point ' + this.filename + ':' + lc[0] + ':' + lc[1] +
      ' ' + name + ':' + index;
    console.log(output);
  },
  
  
  // Layout Handling
  
  // Rules:
  //
  // 1. Statement defines current indentation level, or inherits from the
  //    block that contains it.
  //
  // 2. A statement is terminated if a newline followed by a statement line
  //    (not a blank line) which is at the statements current level of
  //    indentation, or is dedented further.
  //
  // 3. A statement is continued by a continuation line, if any non-empty line
  //    of code is indented. This does not change the indentation level, and
  //    the indentation of the continuation lines may vary, so long as they
  //    are still further indented compared to the statements indentation level.
  //
  // 4. Any code explicitely delimited by parentheses, braces or brackets
  //    will disable the layout rules for the host statement until the closing
  //    delimiter is found. New indentation levels may still be created by
  //    nesting blocks in the enclosed expressions.
  //
  // 5. A block closing delimiter must be dedented compared to the indentation
  //    level of statements contained by the block, even if there is no 
  //    indentation level associated with the statement containing the block.
  //    Block closing delimiters must not be below a currently active indentation
  //    level of the host statement.
  
  statementTerminator: rule {
    | newlineStatementTerminator
    | semicolonStatementTerminator
  },
  
  semicolonStatementTerminator: rule {
    ( spaces | comment )* ';' ~( ( spaces | comment )* newline )
  },
  
  newlineStatementTerminator: rule {
    ( spaces | comment )* ';'? ( spaces | comment )* newline
    blankline*
    &( currentIndentation | decreasedIndentation | eof )
  },
  
  blockHeaderTerminator: rule {
    | semicolonStatementTerminator
    | blockHeaderNewlineTerminator
  },
  
  blockHeaderNewlineTerminator: rule {
    ( spaces | comment )* ';'? ( spaces | comment )* newline
    blankline*
  }
  
  withIncreasedIndentation: rule (parser) {
    &increasedIndentation:count
    !(this.state.blocks.push({
      singleLine: false,
      ignoreLayout: false,
      columnCount: count
    })
    
    parser:result
    
    &decreasedIndentation !(this.state.blocks.pop())
    &currentIndentation
    
    -> result
  },
  
  ignoringIndentation: rule (parser) {
    !(this.state.blocks.push({
      singleLine: this.state.blocks.last.singleLine,
      ignoreLayout: true,
      columnCount: this.state.blocks.last.columnCount,
    })
    parser:result
    !(this.state.blocks.pop())
    -> result
  },
  
  blockHeader: rule (parser) {
    !(this.state.blocks.push({
      singleLine: true,
      ignoreLayout: this.state.blocks.last.ignoreLayout,
      columnCount: this.state.blocks.last.columnCount,
    })
    
    parser:result
    
    !(this.state.blocks.pop())
    
    blockHeaderTerminator
    
    -> result
  },
  
  ws: rule {
    ( spaces | comment | continuationLine | ignoredNewline )*
  },
  
  ignoredNewline: rule {
    ?(this.state.blocks.last.ignoreLayout) newline
  },
  
  continuationLine: rule {
    ?(!this.state.blocks.last.singleLine)
    ( spaces | comment )* newline
    blankline*
    &increasedIndentation
  },
  
  ignoredLayout: rule {
    ?(this.state.blocks.last.ignoreLayout) newline
  },
  
  currentIndentation: rule {
    !(this.state.blocks.last):b
    indentation:count ?(b.ignoreIndentation || count === b.columnCount)
  },
  
  increasedIndentation: rule {
    !(this.state.blocks.last):b
    indentation:count ?(b.ignoreIndentation || count > b.columnCount)
    -> count
  },
  
  decreasedIndentation: rule {
    !(this.state.blocks.last):b
    indentation:count ?(count < b.columnCount)
    -> count
  },
  
  indentation: rule {
    !(0):count
    ( spaces:s !(count + s.length):count
    | comment // We completely disregard comments right now...
    )*
    -> count
  },
  
  blankline: rule {
    ( spaces | comment )* newline
  },
  
  eof: rule {
    ( spaces | comment | newline )* %TextParser.prototype.eof
  },
  
  // Todo: Add support layout sensitive delimited comment handling.
  
});
