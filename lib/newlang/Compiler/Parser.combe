/*
  The Metaphor Programming Language
  
  Copyright 2011 Lorenz Pretterhofer

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
'use strict';

var combe = require('combe');

var Ast = require('./Ast');

var Parser = module.exports = Class.new(combe.TextParser, {
  
  parse: function (source) {
    var parser = this.new(source);
    var result = parser.match('file');
    if (result == null) {
      var lc = source.lineColumnAt(parser.furthestPosition);
      console.error('Parse failed with furthest position ' + lc[0] + ':' + lc[1]);
      throw new Error('Parse Failure');
    }
    return result;
  },
  
}, {
  
  // Todo: I believe that this dialect of Combe may be served by providing
  // Ruby style do-end delimited in addition to the parentheses delimitiers.
  // This would also allow the layout rule to exist as more a minor improvement
  // in Ruby's notation (real continuation lines, block indentation, and less semicolons).
  
  file: rule {
    expressionSequence:expr eof
    -> Ast.File(expr)
  },
  
  expressionSequence: rule {
    delimited[expression, ';']:es ';'?
    -> Ast.Sequence(es)
  },
  
  expression: rule {
    operatorExpression
  },
  
  operatorExpression: rule {
    assignmentExpression
  },
  
  assignmentExpression: rule {
    | variableAssignment
    | memberAssignment
    | logicalOr
  },
  
  variableAssigment: rule {
    variableName:name op('=') assignmentExpression:rvalue
    -> Ast.VariableAssignment(name, rvalue)
  },
  
  memberAssignment: rule {
    secondaryExpression:expr ?(expr.is('MethodCall')) op('=') assignmentExpression:rvalue
    -> Ast.MethodCallAssignment(expr.receiver, expr.name, expr.arguments, rvalue)
  },
  
  logicalOr: rule {
    logicalXor:expr
    ( id('or'):opname logicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  logicalXor: rule {
    logicalAnd:expr
    ( id('xor'):opname logicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  logicalAnd: rule {
    logicalNot:expr
    ( id('and'):opname logicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  logicalNot: rule {
    | id('not'):opname logicalNot:expr
      -> Ast.Not(expr)
    | equalityOperator
  },
  
  equalityOperator: rule {
    // Todo: Change this from left-associative to math-like notation.
    comparisonOperator:expr
    ( (op('==') | op('!=') | op('<=') | op('<') | op('>=') | op('>')):opname
      comparisonOperator:rhs
      !(expr = Ast.Operator(opname, expr, rhs))
    )*
    -> expr
  },
  
  comparisonOperator: rule {
    // Non-Associative (can only appear once)
    association:expr
    ( op('<=>'):opname association:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  association: rule {
    associationLValue:k op(':') associationRValue:v
    -> Ast.Association(k, v)
  },
  associationLValue: rule { unionOperator },
  associationRValue: rule { unionOperator },
  
  unionOperator: rule { // lhs OR rhs
    leftAssocOperator[symmetricDifferenceOperator, op('|')]
  },
  symmetricDifferenceOperator: rule { // lhs XOR rhs
    leftAssocOperator[intersectOperator, op('^')]
  },
  intersectOperator: rule { // lhs AND rhs
    leftAssocOperator[differenceOperator, op('&')]
  },
  differenceOperator: rule { // lhs AND (NOT rhs)
    leftAssocOperator[shiftOperator, op('\\')]
  },
  
  shiftOperator: rule {
    leftAssocOperator[addOperator, (op('<<') | op('>>') | op('>>>'))]
  },
  addOperator: rule {
    leftAssocOperator[multiplyOperator, (op('+') | op('-'))]
  },
  multiplyOperator: rule {
    leftAssocOperator[exponentOperator, (op('*') | op('/') | op('//') | op('%'))]
  },
  exponentOperator: rule {
    rightAssocOperator[prefixOperatorExpression, op('**')]
  },
  
  leftAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname term:rhs
      !(expr = Ast.Operator(opname, expr, rhs))
    )*
    -> expr
  },
  
  rightAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname rightAssocOperator(term, operator):rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  prefixOperatorExpression: rule {
    | (op('+') | op('-') | op('~')):opname prefixOperatorExpression:e
      -> Ast.PrefixOperator(opname, e)
    | secondaryExpression
  },
  
  secondaryExpression: rule {
    primaryExpression:expr ( secondaryExpressionFragment(expr):expr )*
    -> expr
  },
  
  seconaryExpressionFragment: rule (receiver) {
    | op('.') propertyName:name argumentsList?:args
      -> Ast.MethodCall(receiver, name, (args != null ? args : []))
    | op('::') propertyName:name argumentsList?:args
      -> Ast.MethodCall(Ast.LookupPrototype(receiver), name, (args != null ? args : []))
    | argumentList:args
      -> Ast.Call(receiver, null, args)
  },
  
  argumentList: rule {
    '(' delimited[splatExpression[expression], ',']:args ','? ')' -> args
  },
  
  splatExpression: rule (alternative) {
    | op('*') expression:expr
      -> Ast.Splat(expr)
    | alternative
  },
  
  primaryExpression: rule {
    | keywordExpression
    | psuedoVariable
    | lookupVariable
    | uninterpolatedStringLiteral
    | numberLiteral
    | collectionLiteral
    | functionLiteral
    | subexpression
  },
  
  keywordExpression: rule {
    | returnExpression
    | declareVariableExpression
    | ifExpression
    | whileExpression
    | loopExpression
    | newExpression
    | extendExpression
    | classExpression
  },
  
  returnExpression: rule {
    id('return') expression:e
    -> Ast.Return(e)
  },
  
  declareVariableExpression: rule {
    id('var') delimited1[declvarFragment, ',']:decls
    -> {
      if (decls.length > 1) {
        return Ast.Sequence(decls);
      }
      else {
        return decls[0];
      }
    }
  },
  
  declvarFragment: rule {
    | variableName:name '=' assignmentExpression:rvalue
      -> Ast.DeclareVariable(name, rvalue)
    | variableName:name
      -> Ast.DeclareVariable(name, null)
  },
  
  ifExpression: rule {
    id('if') expression:c id('then') expression:t
    ( id('else') expression:e
      -> Ast.If(c, t, e)
    | -> Ast.If(c, t, null)
    )
  },
  
  whileExpression: rule {
    id('while') expression:cond id('do') expression:body
    -> Ast.While(cond, body)
  },
  
  loopExpression: rule {
    id('loop') expression:body
    -> Ast.Loop(body)
  },
  
  newExpression: rule {
    | 'new' primaryExpression:expr argumentList?:args
      ( '{' propertyDeclarationsBody:pdecls '}'
        -> Ast.New(expr, (args != null ? args : []), pdecls)
      | ~'{'
        -> Ast.new(expr, (args != null ? args : []), null)
      )
    | 'new' '{' propertyDeclarationsBody:pdecls '}'
      -> Ast.new(null, [], pdecls)
  }
  
  extendExpression: rule {
    'extend' expression:subject '{' propertyDeclarationsBody:pdecls '}'
    -> Ast.Extend(subject, pdecls)
  },
  
  classExpression: rule {
    'class' subexpression?:superclass propertyDeclarationsBody:pdecls
    -> Ast.Class(superclass, pdecls)
  },
  
  propertyDeclarations: rule {
    '{' delimited[propertyDeclaration, ',']:elems '}'
    -> elems
  },
  
  propertyDeclaration: rule {
    | slotPropertyDeclaration
    | primitivePropertyDeclaration
    | methodPropertyDeclaration
    | doExpressionPropertyDeclaration
    // | describePropertyDeclaration // Todo: Provide support for JS property descriptor maps
  },
  
  slotPropertyDeclaration: rule {
    | id('const') propertyName:name op('=') assignmentExpression:rvalue
      -> Ast.ConstantSlotPropertyDeclaration(name, rvalue)
    | propertyName:name op('=') assignmentExpression:rvalue
      -> Ast.SlotPropertyDeclaration(name, rvalue)
  },
  
  primitivePropertyDeclaration: rule {
    propertyName:name op(':') expression:rvalue
    -> Ast.PrimitivePropertyDeclaration(name, rvalue)
  },
  
  methodPropertyDeclaration: rule {
    | propertyName:name parameterList?:ps op('->') expression:body
      -> Ast.MethodPropertyDeclaration(name, (ps != null ? ps : []), body)
    | propertyName:name parameterList?:ps op('=') parameter:rvname op('->') expression:body
      -> {
        ps = (ps != null ? ps : []);
        var realname = name + '='
        var realparams = ps.concat([rvname]);
        return Ast.MethodPropertyDeclaration(realname, realparams, body)
      }
  },
  
  doExpressionPropertyDeclaration: rule {
    id('do') expression:body
    -> Ast.DoExpressionPropertyDeclaration(body)
  },
  
  propertyName: rule {
    | identifier:name -> Ast.String(name)
    | string
  },
  
  psuedoVariable: rule {
    | id('null')  -> Ast.Null()
    | id('true')  -> Ast.True()
    | id('false') -> Ast.False()
    | id('this')  -> Ast.This()
    | id('_')     -> Ast.Underscore()
  },
  
  lookupVariable: rule {
    variableName:name
    -> Ast.VariableLookup(name)
  },
  
  collectionLiteral: rule {
    | '[' delimited[splatExpression[association], ',']:elems ','? ']'
      -> Ast.OrderedMap(elems)
    | '[' delimited[splatExpression[~association expression], ',']:elems ','? ']'
      -> Ast.Array(elems)
    | '{' delimited[splatExpression[association], ',']:elems ','? '}'
      -> Ast.Map(elems)
    | '{' delimited[splatExpression[~association expression], ',']:elems ','? '}'
      -> Ast.Set(elems)
  },
  
  functionLiteral: rule {
    parameterList?:ps op('->') expression:body
    -> Ast.Function((ps != null ? ps : []), body)
  }
  
  parameterList: rule {
    '(' delimited[splatParameter, ',']:ps ','? ')' -> ps
  },
  
  splatParameter: rule {
    | op('*') parameter:p
      -> Ast.SplatParameter(p.name)
    | parameter
  },
  
  parameter: rule {
    | variableName:name -> Ast.Parameter(name)
    | id('_') -> Ast.Parameter(null)
  },
  
  subexpression: rule {
    '(' expressionSequence:expr ')'
    -> expr
  },
  
  numberLiteral: rule {
    | decimal
    | hexInteger
  },
  
  PsuedoVariableNames: [
    'new', 'extend', 'class', 'this',  'true', 'false', 'null', '_'
  ],
  
  variableName: rule {
    identifier:name ?(!this.PsuedovariableNames.include(name.value))
    -> name
  },
  
  decimal: rule {
    ws?
    matchedInput[
      | integerPart ('.' digit*)? exponentPart?
      | '.' digit+ exponentPart?
    ]:text ~idChar
    -> Ast.Number(parseFloat(text));
  },
  
  hexInteger: rule {
    ws?
    ('0x'|'0X') matchedInput[hexDigit+]:text ~idChar
    -> Ast.Number(parseFloat(text))
  },
  
  // interpolatedStringLiteral: rule { 
  //   ws?
  //   openString:delimiter
  //   ( stringFragment(delimiter)
  //   | stringInterpolatedExpression(delimiter)
  //   )*:es
  //   delimiter
  //   -> {
  //     if (es.length === 0) {
  //       return Ast.String('');
  //     }
  //     else if (es.length === 1 && es[0].is('String')) {
  //       return es[0];
  //     }
  //     else {
  //       return Ast.InterpolatedString(es);
  //     }
  //   }
  // },
  
  uninterpolatedStringLiteral: rule {
    ws?
    openString:delimiter
    ( stringFragment(delimiter)
    | -> Ast.String('')
    ):s
    delimiter
    -> s
  },
  
  openString: rule {
    | '\'' -> rule { '\'' }
    | '\"' -> rule { '\"' }
  },
  
  stringFragment: rule (delimiter) {
    basicStart
    stringChar(delimiter)+:cs -> Ast.String(cs.join(''))
  },
  
  stringChar: rule (delimiter) {
    ~delimiter
    ( '\\' stringEscapeSequence
    | ~newline char
    )
  },
  
  stringEscapeSequence: rule {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | '0'  -> '\x00' // ^@  Null Character
    | 'a'  -> '\x07' // ^G  Alarm/Bell
    | 'b'  -> '\x08' // ^H  Backspace
    | 't'  -> '\x09' // ^I  Tab
    | 'n'  -> '\x0a' // ^J  Line Feed
    | 'v'  -> '\x0b' // ^K  Vertical Tab
    | 'f'  -> '\x0c' // ^L  Form Feed
    | 'r'  -> '\x0d' // ^M  Carriage Return
    | 'e'  -> '\x1b' // ^[  Escape
    | 'x' repeat[hexDigit, %2]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %4]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' '(' hexDigit*:hs ')' -> String.fromCodepoint(hs.join(''))
    | error('Unsupported escape sequence')
  },
  
  regex: rule {
    ws? fail // Todo
  },
  
  id: rule (expectedName) {
    identifier:name ?(name.value === expectedName) -> name
  },
  
  identifier: rule {
    ws? matchedInput[initialIdChar idChar*]
  },
  
  op: rule (expectedOpname) {
    operator:opname ?(opname.value === expectedOpname) -> opname
  },
  
  operator: rule {
    ws?
    ( '<<' | '>>>' | '>>' | '<=>' | '<=' | '>=' | '<' | '>'
    | '==' | '!=' | '='
    | '||' | '|' | '^^' | '^' | '&&' | '&' | '\\\\' | '\\'
    | '+' | '-' | '**' | '*' | '//' | '/' | '%' | '~'
    | '->'
    ):text
    -> text
  },
  
  ws: rule {
    ( spaces | comment | newline )+
  },
  
  spaces: rule {
    ' '+
  },
  
  comment: rule {
    | delimitedComment
    | lineComment
  },
  
  delimitedComment: rule {
    '/*' &( spaces | newline | eof | '*/' )
    ( ~'*/' (delimitedComment | char) )*
    ('*/' | eof)
  },
  
  lineComment: rule {
    '//' (~newline char)* (newline | eof)
  },
  
  newline: rule {
    '\r\n' | '\n' | '\r'
  },
  
  digit: rule {
    char('0'..'9')
  },
  
  hexDigit: rule {
    char('0'..'9', 'a'..'f', 'A'..'F')
  },
  
  idChar: rule {
    char('a'..'z', 'A'..'Z', '0'..'9', '_', '$')
  },
  
  initialIdChar: rule {
    char('a'..'z', 'A'..'Z', '_', '$')
  },
  
  stringPatternHandler: rule (string) {
    ws? eachChar(string)
  },
  
  tokenOperatorHandler: rule (parser) {
    ws? parser
  },
  
  next: function () {
    var c = TextParser.prototype.next.call(this);
    this.furthestPosition = Math.max(
      this.furthestPosition,
      this.state.position
    );
    return c;
  },
  
  nextIf: function (predicate) {
    var c = TextParser.prototype.next.call(this);
    if (predicate.call(this, c)) {
      this.furthestPosition = Math.max(
        this.furthestPosition,
        this.state.position
      );
      return c;
    }
    else {
      return this.fail();
    }
  },
  
  stringPatternHandler: rule (string) {
    ws? eachChar(string)
  },
  
});
