/*
  The Metaphor Programming Language
  
  Copyright 2011 Lorenz Pretterhofer

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
'use strict';

var combe = require('combe');
var BaseParser = combe.BaseParser;

var Lexer = require('./Lexer');

var Ast = require('./Ast');

var Parser = module.exports = Class.new(BaseParser, {
  
  parseFile: function (source, filename, tokens) {
    return this.parse(source, filename, tokens, 'file');
  },
  
  parse: function (source, filename, tokens, rulename) {
    var rest = Array.slice(arguments, 4);
    if (filename == null) filename = '(unnamed)';
    
    var parser = this.new(source, filename, tokens);
    var result = parser.match.apply(parser, [rulename].concat(rest));
    if (!result) {
      var t = parser.tokens.last;
      var lc = (t != null ? source.lineColumnAt(t.position).join(':') : '-1');
      var text = (t != null ? '[' + t.text + '] ' : '');
      throw Error.new('Combe/Newlang Parser Failed: Furthest position was ' + text + filename + ':' + lc);
    }
    return result;
  },
  
}, {
  
  initialize: function (source, filename, tokens) {
    if (filename == null) filename = '(unnamed)';
    
    this.source = source;
    this.filename = filename;
    BaseParser.prototype.initialize.call(this, source);
    
    this.lexer = Lexer.new(source, filename);
    this.tokens = (tokens != null ? tokens : []);
  },
  
  
  
  // Syntactic Rules
  
  file: rule {
    leadingNewlines
    delimited[statement, statementTerminator]:stmts ';'?
    eof
    -> Ast.File(Ast.Block(stmts))
  },
  
  statement: rule {
    | ifStatement
    | tryCatchStatement
    | defStatement
    | functionStatement
    | expression
  },
  
  expression: rule {
    | ifExpression
    | tryCatchExpression
    | varExpression
    | returnExpression
    | throwExpression
    | operatorExpression
  },
  
  ifStatement: rule { // Handle layout rules
    block[ id('if') expression:condition ]:consiquent
    !(Ast.If(condition, consiquent, null)):ast:tail
    
    (
      block[ id('else') id('if') expression:condition ]:consiquent
      !(tail.alternative = Ast.If(condition, consiquent, null))
      !(tail = tail.alternative)
    )*
    
    (
      block[ id('else') ]:alternative
      !(tail.alternative = alternative)
    )?
    
    id('end')
    -> ast
  },
  
  ifExpression: rule {
    id('if') expression:condition
    id('then') expression:consiquent
    ( id('else') expression:alternative )?
    -> Ast.If(condition, consiquent, alternative)
  },
  
  tryCatchStatement: rule {
    block[ id('try') ]:tryBlock
    block[ id('catch') variableIdentifier:name ]:catchBlock
    id('end')
    -> Ast.TryCatch(tryBlock, name, catchBlock)
  },
  
  functionStatement: rule {
    | functionBlock[ id('def') propertyName:name ]:b
      -> Ast.Function(name, b.parameters, b.body)
    | functionBlock[ id('method') propertyName:name ]:b
      -> Ast.Method(null, name, b.parameters, b.body)
    | functionBlock[ id('method') methodDefLvalue:lval ]:b
      -> Ast.Method(lval.object, lval.name, b.parameters, b.body)
  },
  
  methodDefLvalue: rule (o) {
    | op('.') propertyName:name &( optParameterList op('->') )
      -> { object: o, name: name }
    | op('.') propertyName:name &( optParameterList 
        ?(!this.state.allowContinuationLines && !this.state.ignoreNewlines)
        // In block header
        newline
      )
      -> { object: o, name: name }
    | ?(object != null) secondaryExpressionFragment(o):o methodDefLvalue(o)
    | primaryExpression:o methodDefLvalue(o)
  },
  
  varExpression: rule {
    id('var') variableIdentifier:name ( op('=') expression:rvalue )?
    -> Ast.Var(name, rvalue)
  },
  
  returnExpression: rule {
    id('return') expression?:arg
    -> Ast.Return(arg)
  },
  
  throwExpression: rule {
    id('throw') expression?:arg
    -> Ast.Throw(arg)
  },
  
  
  block: rule (header) {
    layoutBlock[
      header,
      delimited[statement, statementTerminator]:stmts ';'?
    ]
    -> Ast.Block(stmts != null ? stmts : [])
  },
  
  functionBlock: rule (header) {
    | header optParameterList:p op('->') expression:body
      -> Ast.Function(null, p, body)
    | block[ header optParameterList:p ]:body
      id('end')
      -> Ast.Function(null, p, body)
  },
  
  
  operatorExpression: rule {
    assignmentExpression
  },
  
  assignmentExpression: rule {
    | lvalueExpression:lvalue op('=') assignmentExpression:rvalue
      -> {
        if (lvalue.is('VariableLookup')) {
          return Ast.VariableAssignment(lvalue.name, rvalue);
        }
        else if (lvalue.is('MethodCall')) {
          lvalue.arguments.rvalue = rvalue;
          return lvalue;
        }
        else if (lvalue.is('Subscript')) {
          lvalue.arguments.rvalue = rvalue;
          return lvalue;
        }
        else assert(false);
      }
    | logicalOperator
  },
  
  lvalueExpression: rule {
    | lvalueSecondaryExpression
    | lvaluePrimaryExpression
  },
  
  lvalueSecondaryExpression: rule {
    primaryExpression:expr ( secondaryExpressionFragment(expr):expr )+
    -> expr
  },
  
  lvaluePrimaryExpression: rule {
    | variableLookup
  },
  
  
  logicalOperator: rule {
    wordedLogicalOr
  },
  
  wordedLogicalOr: rule {
    wordedLogicalXor:expr
    ( id('or') wordedLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalXor: rule {
    wordedLogicalAnd:expr
    ( id('xor') wordedLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalAnd: rule {
    wordedLogicalNot:expr
    ( id('and') wordedLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  wordedLogicalNot: rule {
    | id('not') wordedLogicalNot:expr
      -> Ast.Not(expr)
    | symbolicLogicalOr
  },
  
  symbolicLogicalOr: rule {
    symbolicLogicalXor:expr
    ( op('||') symbolicLogicalXor:rhs
      !(expr = Ast.Or(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalXor: rule {
    symbolicLogicalAnd:expr
    ( op('^^') symbolicLogicalAnd:rhs
      !(expr = Ast.Xor(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalAnd: rule {
    symbolicLogicalNot:expr
    ( op('&&') symbolicLogicalNot:rhs
      !(expr = Ast.And(expr, rhs))
    )*
    -> expr
  },
  symbolicLogicalNot: rule {
    | op('!') symbolicLogicalNot:expr
      -> Ast.Not(expr)
    | equalityOperator
  },
  
  equalityOperator: rule {
    // Todo: Allow Math style sequences of equality operators (i.e., 0 <= i < length) 
    comparisonOperator:expr
    ( (op('==') | op('!=') | op('<=') | op('<') | op('>=') | op('>') ):opname
      comparisonOperator:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  comparisonOperator: rule {
    associationOperator:expr
    ( op('<>'):opname association:rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  associationOperator: rule {
    | association
    | bitwiseOr
  },
  association: rule {
    | propertyName:lhs op(':') bitwiseOr:rhs
      -> Ast.Association(lhs, rhs)
    | bitwiseOr:lhs op('=>') bitwiseOr:rhs
      -> Ast.Association(lhs, rhs)
  },
  
  bitwiseOr: rule {
    leftAssocOperator[bitwiseXor, op('|')]
  },
  bitwiseXor: rule {
    leftAssocOperator[bitwiseAnd, op('^')]
  },
  bitwiseAnd: rule {
    leftAssocOperator[shiftOperator, op('&')]
  },
  
  shiftOperator: rule {
    leftAssocOperator[additionOperator, ( op('<<') | op('>>') | op('>>>') )]
  },
  additionOperator: rule {
    leftAssocOperator[multiplicationOperator, ( op('+') | op('-') )]
  },
  multiplicationOperator: rule {
    leftAssocOperator[exponentiationOperator, ( op('*') | op('/') | op('//') | op('%') )]
  },
  exponentiationOperator: rule {
    rightAssocOperator[prefixOperatorExpression, op('**')]
  },
  
  leftAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname term:rhs
      !(expr = Ast.Operator(opname, expr, rhs))
    )*
    -> expr
  },
  rightAssocOperator: rule (term, operator) {
    term:expr
    ( operator:opname rightAssocOperator(term, operator):rhs
      -> Ast.Operator(opname, expr, rhs)
    | -> expr
    )
  },
  
  prefixOperatorExpression: rule {
    | ( op('+') | op('-') | op('~') ):opname prefixOperatorExpression:expr
      -> Ast.PrefixOperator(opname, expr)
    | secondaryExpression
  },
  
  
  secondaryExpression: rule {
    primaryExpression:expr ( secondaryExpressionFragment(expr):expr )*
    -> expr
  },
  
  secondaryExpressionFragment: rule (expr) {
    | op('.') propertyName:name optArgumentsList:a
      -> Ast.MethodCall(expr, name, a)
    | argumentsList:a
      -> Ast.Call(expr, a)
    | subscriptArguments:a
      -> Ast.Subscript(expr, a)
  },
  
  optArgumentsList: rule {
    | argumentsList
    | -> Ast.Arguments(null, [], null, null)
  },
  argumentsList: rule {
    '('
    ignoringNewlines[
      ( expression:expr ';' -> expr )?:ta
      delimited[mainArgument, ',']:main ','?
      ')'
    ]
    functionBlock[ id('do') ]?:b
    -> Ast.Arguments(ta, main, b, null)
  },
  subscriptArguments: rule {
    '['
    ignoringNewlines[
      delimited[mainArgument, ',']:main ','?
      ']'
    ]
    -> Ast.Arguments(null, main, null, null)
  },
  mainArgument: rule {
    | expansionArgument
    | blockArgument
    | expression
  },
  blockArgument: rule {
    op('&') expression:expr
    -> Ast.BlockArgument(expr)
  },
  expansionArgument: rule {
    op('..') expression:expr
    -> Ast.ExpansionArgument(expr)
  },
  
  
  primaryExpression: rule {
    | psuedoVariable
    | variableLookup
    | stringLiteral
    | numberLiteral
    | objectLiteral
    | functionLiteral
    | subexpression
  },
  
  psuedoVariable: rule {
    | id('this')      -> Ast.This()
    
    | id('null')      -> Ast.Null()
    | id('undefined') -> Ast.Undefined()
    | id('true')      -> Ast.True()
    | id('false')     -> Ast.False()
  },
  
  variableLookup: rule {
    variableIdentifier:name
    -> Ast.VariableLookup(name)
  },
  
  stringLiteral: rule {
    'string':s
    -> Ast.String(s.value)
  },
  
  numberLiteral: rule {
    'number':n
    -> Ast.Number(n.value)
  },
  
  functionLiteral: rule {
    | optParameterList:p op('->') expression:body
      -> Ast.Function(null, p, body)
    | functionBlock[ id('def') ]:fb
      -> Ast.Function(null, fb.parameters, fb.body)
    | functionBlock[ id('method') ]:fb
      -> Ast.Method(null, null, fb.parameters, fb.body)
  },
  
  
  subexpression: rule {
    '(' ignoringNewlines[ expression:expr ')' ]
    -> expr
  },
  
  
  optParameterList: rule {
    | parameterList
    | -> Ast.Parameters(null, [], null, null)
  },
  parameterList: rule {
    '('
    ignoringNewlines[
      ( parameter:p ';' -> p )?:tp
      delimited[mainParameter, ',']:main ','?
      ')'
    ]
    ( op('=') parameter )?:rp
    -> Ast.Parameters(tp, main, bp, rp)
  },
  
  mainParameter: rule {
    | contractionParameter
    | blockParameter
    | parameter
  },
  contractionParameter: rule {
    op('..') variableIdentifier:name
    -> Ast.ContractionParameter(name)
  },
  blockParameter: rule {
    op('&') variableIdentifier:name
    -> Ast.BlockParameter(name)
  },
  parameter: rule {
    | variableIdentifier:name -> Ast.Parameter(name)
    | id('_') -> Ast.IgnoredParameter()
  },
  
  
  propertyName: rule {
    | 'identifier':name -> Ast.String(name.text)
    | stringLiteral
  },
  
  
  
  // Layout Handling
  
  leadingNewlines: function () {
    var column = this.t('newline').value;
    if (column !== 0) {
      this.fail();
    }
  },
  
  statementTerminator: function () {
    if (this.state.ignoreNewlines) {
      this.t(';');
      return;
    }
    else {
      this._choice(function () {
        this.t(';');
        this._optional(function () {
          var column = this.t('newline').value;
          if (column === this.state.column) {
            return;
          }
          else {
            this.fail();
          }
        });
      }, function () {
        var column = this.t('newline').value;
        if (column === this.state.column) {
          return;
        }
        else {
          this.fail();
        }
      });
    }
  },
  
  layoutBlock: function (header, body) {
    if (!this.state.allowContinuationLines && !this.state.ignoreNewlines) {
      // We're already in a layoutBlock header, nesting isn't allowed unless
      // contained in layout ignoring delimiters like subexpressions.
      this.fail();
    }
    
    var oldState = this.copyState();
    var headerColumn = oldState.column;
    this.state.allowContinuationLines = false;
    this.state.ignoreNewlines = false;
    if (oldState.ignoreNewlines) {
      var headerColumn = this._optional(function () {
        return this.t('newline').value;
      });
    }
    
    header.call(this);
    
    var bodyColumn = this.t('newline').value;
    if (headerColumn != null && bodyColumn < headerColumn) {
      this.fail();
    }
    else if (headerColumn != null && bodyColumn == headerColumn) {
      // No body
      
      this.state.allowContinuationLines = oldState.allowContinuationLines;
      this.state.ignoreNewlines = oldState.ignoreNewlines;
      this.state.column = oldState.column;
    }
    else {
      this.state.column = bodyColumn;
      this.state.allowContinuationLines = true;
    
      this._choice(function () {
        body.call(this);
    
        var dedentColumn = this.t('newline').value;
        if (headerColumn != null && dedentColumn !== headerColumn ||
            oldState.ignoreNewlines && dedentColumn >= bodyColumn) {
          this.fail();
        }
        
        this.state.allowContinuationLines = oldState.allowContinuationLines;
        this.state.ignoreNewlines = oldState.ignoreNewlines;
        this.state.column = oldState.column;
      }, function () {
        // No body
        
        if (headerColumn == null) { // We don't need to dedent to any particular level
          this.state.allowContinuationLines = oldState.allowContinuationLines;
          this.state.ignoreNewlines = oldState.ignoreNewlines;
          this.state.column = oldState.column;
        }
        else {
          this.fail();
        }
      });
    }
  },
  
  ignoringNewlines: function (parser) {
    var oldIgnoreNewlines = this.state.ignoreNewlines;
    this.state.ignoreNewlines = true;
    var result = parser.call(this);
    this.state.ignoreNewlines = oldIgnoreNewlines;
    return result;
  },
  
  
  
  // Basic Parsing Functionality
  
  t: function (typename) {
    var token = this.next();
    
    while (token.type === 'newline') {
      if (this.state.ignoreNewlines) {
        token = this.next();
        continue;
      }
      else if (this.state.allowContinuationLines && 
               token.value > this.state.column) {
        token = this.next();
        continue;
      }
      else {
        break; // Statement delimiter or indent/dedent
      }
    }
    
    if (token.type === typename) {
      return token;
    }
    else {
      this.fail();
    }
  },
  
  id: rule (expectedName) {
    'identifier':name ?(name.text === expectedName) -> name.text
  },
  
  variableIdentifier: rule {
    'identifier':name ?(!name.invalidVariableIdentifier) -> name.text
  },
  
  op: rule (expectedOpname) {
    'operator':opname ?(opname.text === expectedOpname) -> opname.text
  },
  
  tokenAt: function (position) {
    var token;
    
    assert(position < this.tokens.length + 1);
    if (position >= this.tokens.length) {
      assert(this.tokens.isEmpty() || this.tokens.last.type !== 'eof');
      
      this.tokens.push(this.lexer.nextToken());
    }
    
    return this.tokens[position];
  },
  
  peekNext: function () {
    return this.tokenAt(this.position);
  },
  
  next: function () {
    return this.tokenAt(this.position++);
  },
  
  eof: rule {
    'eof'
  },
  
  stringPatternHandler: rule (string) {
    t(string)
  },
  
  lineColumnString: function (position) {
    if (position == null) position = this.position;
    
    var token = this.tokenAt(position);
    
    return this.source.lineColumnAt(token.position).join(':');
  },
  
  positionString: function (position) {
    if (position == null) position = this.position;
    
    var token = this.tokenAt(position);
    
    return this.filename + ':' + this.source.lineColumnAt(token.position).join(':');
  },
  
  get position()      { return this.state.position;  },
  set position(value) { this.state.position = value; },
  
  get state()         { return this._state;  },
  set state(value)    { this._state = value; },
  
  emptyState: function () {
    return {
      position:               0,
      ignoreNewlines:         false,
      allowContinuationLines: true,
      column:                 0,
    };
  },
  copyState: function () {
    return {
      position:               this.state.position,
      ignoreNewlines:         this.state.ignoreNewlines,
      allowContinuationLines: this.state.allowContinuationLines,
      column:                 this.state.column,
    };
  },
  
  log: function (name) {
    var messages = Array.slice(arguments, 1);
    console.log('Parser::log() '
      + this.positionString() + ':' + name + ' - '
      + messages.join('; ')
    );
  },
  
});
