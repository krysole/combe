/*
  The Metaphor Programming Language
  
  Copyright 2011 Lorenz Pretterhofer

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
'use strict';

var combe = require('combe');
var TextParser = combe.TextParser;

var Token = Class.new(Object, {}, {
  
  initialize: function (type, value, position, length, text) {
    this.type = type;
    this.value = value;
    this.position = position;
    this.length = length;
    this.text = text;
  },
  
  toString: function () {
    return '[[Token ' + this.type + ' ' + this.value + ' ' + this.text.quote() + ']]';
  },
  
});

var Lexer2 = module.exports = Class.new(TextParser, {
  
  parseAllTokens: function (source, filename) {
    var lexer = this.new(source, filename);
    var tokens = [];
    
    try {
      while (tokens.isEmpty() || tokens.last.type !== 'eof') {
        tokens.push(lexer.nextToken());
      }
    }
    catch (e) {
      if (e == combe.BacktrackingException) {
        throw Error.new('Lexer failed at ' + lexer.positionString());
      }
      else {
        throw e;
      }
    }
    
    return tokens;
  },
  
}, {
  
  initialize: function (source, filename) {
    if (filename == null) filename = '(unnamed)';
    
    this.source = source;
    this.filename = filename;
    this.furthestPosition = 0;
    TextParser.prototype.initialize.call(this, source);
  },
  
  nextToken: rule {
    !(this.furthestPosition = this.position, this.isNewline = false, this.newlinePosition = null)
    ws?
    
    !(this.tokenPosition = this.position)
    ( eofToken
    | newlineToken
    | identifier
    | operator
    | punctuation
    | number
    | string
    )
  },
  
  reset: function (position) {
    this.position = position;
  },
  
  createToken: function (type, value) {
    var text = this.source.slice(this.tokenPosition, this.position);
    return Token.new(
      type,               // Type
      value,              // Value
      this.tokenPosition, // Position
      text.length,        // Length
      text                // text
    );
  },
  
  
  
  // Lexical Parsing Rules
  
  eofToken: rule {
    eof
    createToken('eof')
  },
  
  
  newlineToken: function () {
    if (this.isNewline) {
      // We've already skipped all the whitespace and ruled out the eof condition
      var column = this.position - this.lineStart;
      return Token.new(
        'newline',            // Type
        column,               // Value
        this.newlinePosition, // Position
        this.position,        // Length
        '<newline>'           // Text
      );
      // Todo: Have the position and length report the newline position and
      // the length should run to the beginning of the next token.
      // This way we can use the position to understand which line was terminated
      // and respectively, how many lines were ignored.
    }
    else {
      this.fail();
    }
  },
  
  
  identifier: rule {
    initialIdChar idChar*
    createToken('identifier'):t
    !{
      if (this.InvalidVariableIdentifiers.include(t.text)) {
        t.invalidVariableIdentifier = true;
      }
    }
    -> t
  },
  
  InvalidVariableIdentifiers: [
    'this', 'true', 'false', 'null', 'undefined', '_',
    
    'or', 'xor', 'and', 'not',
    
    'if', 'then', 'else', 
    'try', 'catch', 
    'var', 'return', 'throw',
    'do', 'end'
  ],
  
  initialIdChar: rule { char('a'..'z', 'A'..'Z', '_', '$') },
  idChar:        rule { char('a'..'z', 'A'..'Z', '_', '$', '0'..'9') },
  
  
  operator: rule {
    ( '<<' | '>>>' | '>>' | '<>' | '<=' | '>=' | '<' | '>'
    | '!=' | '==' | '!' | '='
    | '||' | '|' | '^^' | '^' | '&&' | '&'
    | '->' | '=>' | '<-' | '..' | '.' | ':'
    | '++' | '--' | '+' | '-' 
    | '**' | '*' | '//' | '/' | '%' | '~'
    )
    createToken('operator')
  },
  
  
  punctuation: rule {
    ( '(' | ')' | '[' | ']' | '{' | '}'
    | ',' | ';'
    ):text
    createToken(text)
  },
  
  
  number: rule {
    | decimalNumber
    | hexNumber
  },
  
  decimalNumber: rule {
    digit+ ('.' digit*)? (('e'|'E') digit+)? ~idChar
    createToken('number'):t
    !(t.value = parseFloat(t.text))
    -> t
  },
  
  hexNumber: rule {
    ('0x'|'0X') matchedInput[ hexDigit+ ]:text ~idChar
    createToken('number', parseInt(text, 16))
  },
  
  digit:    rule { char('0'..'9') },
  hexDigit: rule { char('0'..'9', 'a'..'f', 'A'..'F') },
  
  
  string: rule {
    ( '\'' (~'\'' stringChar)*:cs '\''
    | '\"' (~'\"' stringChar)*:cs '\"'
    )
    createToken('string', cs.join(''))
  },
  
  stringChar: rule {
    | '\\' stringEscapeSequence
    | ~newline char
  },
  
  stringEscapeSequence: rule {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | '0'  -> '\x00' // ^@  Null Character
    | 'a'  -> '\x07' // ^G  Alarm/Bell
    | 'b'  -> '\x08' // ^H  Backspace
    | 't'  -> '\x09' // ^I  Tab
    | 'n'  -> '\x0a' // ^J  Line Feed
    | 'v'  -> '\x0b' // ^K  Vertical Tab
    | 'f'  -> '\x0c' // ^L  Form Feed
    | 'r'  -> '\x0d' // ^M  Carriage Return
    | 'e'  -> '\x1b' // ^[  Escape
    | 'x' repeat[hexDigit, %2]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %4]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' '(' hexDigit*:hs ')' -> String.fromCodepoint(hs.join(''))
    | error('Unsupported escape sequence')
  },
  
  
  
  // Whitespace Handling
  
  ws: rule {
    ( spaces | comment | newline )*
  },
  
  comment: rule {
    | delimitedComment
    | lineComment
  },
  
  delimitedComment: rule {
    '{-' &( spaces | newline | eof | '-}' | delimitedComment )
    ( ~'-}' ( delimitedComment | char ) )*
    ( '-}' | eof )
  },
  
  lineComment: rule {
    '--' ( ~newline char )* &( newline | eof )
  },
  
  newline:  rule {
    !(this.position):startPos
    ( '\r\n' | char('\r\n') )
    !(this.lineStart = this.position, this.isNewline = true)
    !{ if (this.newlinePosition == null) this.newlinePosition = startPos; }
  },
  
  spaces: rule { ' '+ },
  
  
  
  // Basic Parsing Functionality
  
  next: function () {
    var c = TextParser.prototype.next.call(this);
    this.furthestPosition = Math.max(
      this.futhestPosition,
      this.position
    );
    return c;
  },
  
  nextIf: function (predicate) {
    var c = TextParser.prototype.nextIf.call(this, predicate);
    this.furthestPosition = Math.max(
      this.furthestPosition,
      this.position
    );
    return c;
  },
  
  stringPatternHandler: rule (string) {
    eachChar(string)
  },
  
  tokenOperatorHandler: rule (parser) {
    ws? parser
  },
  
  lineColumnString: function (position) {
    if (position == null) position = this.position;
    
    return this.source.lineColumnAt(position).join(':');
  },
  
  positionString: function (position) {
    if (position == null) position = this.position;
    
    return this.filename + ':' + this.source.lineColumnAt(position).join(':');
  },
  
  log: function (name) {
    var messages = Array.slice(arguments, 1);
    console.log('Lexer2::log() '
      + this.positionString() + ':' + name + ' - '
      + messages.join('; ')
    );
  },
  
});
