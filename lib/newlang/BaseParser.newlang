{-
  Combe - A Parsing Language for JavaScript
  
  Copyright 2011 Lorenz Pretterhofer
  
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
    http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-}

return Object.extend('BaseParser') do(self;)
  
  method initialize(source)
    self@_source = source
    self@_state = self.emptyState
    self@_memoTables
  end
  
  method source -> self@_source
  
  method memoTables -> self@_memoTables
  
  method position -> self@_position
  method position = anIndex -> self@_position = anIndex
  
  method state -> self@_state
  method state = aState -> self@_state = aState
  
  var _BacktrackException = Object.unique('BacktrackException')
  method BacktrackException -> _BacktrackException
  
  method preservingState(block)
    var preservedState = self.state
    try
      block()
    catch e
      if e == self.BacktrackingException
        self.state = preservedState
      end
      throw e
    end
  end
  
  method memoTableAt(position)
    var memoTable = self.memoTables[position]
    return if memoTable != null
           then memoTable
           else self.memoTables[position] = Map.new
  end
  
  method memoize(parser, name)
    var memoTable = self.memoTableAt(self.position)
    var memoEntry = memoTable[name]
    if memoEntry == self.BacktrackException
      throw self.BacktrackException
    else if memoEntry != null
      self.position = memoEntry['position']
      return memoEntry['result']
    else
      try
        var result = parser.call(self)
        memoTable[name] = Map.with('result' => result, 'position' => position)
        return result
      catch e
        if e == self.BacktrackException
          memoTable[name] = self.BacktrackException
        end
        throw e
      end
    end
  end
  
  method match(rulename, ..args)
    try
      -- Todo: I need to add support for escaped property names for this to work
      -- return self.\rulename(..args)
      self.fail
    catch e
      if e == self.BacktrackException
        return null
      else
        throw e
      end
    end
  end
  
  method _choice(..parsers)
    var initialState = self.state
    parser.each do(parser)
      try
        return parser.call(self)
      catch e
        if e == self.BacktrackException
          self.state = initialState
          continue
        else
          throw e
        end
      end
    end
    self.fail
  end
  
  method _concat(..parsers)
    return parsers.map((parser) -> parser.call(self)).last
  end
  
  method _not(parser)
    var initialState = self.state
    try
      parser.call(self)
    catch e
      if e == BacktrackException
        self.state = initialState
        return null
      else
        throw e
      end
    end
    self.state = initialState
    this.fail
  end
  
  method _lookahead(parser)
    var initialState = self.state
    var result = parser.call(self)
    self.state = initialState
    return result
  end
  
  method _repeat(parser, range)
    if Number.isNumber(range) then range = Range.inclusive(range, range)
    if range == null then range = Range.exclusive(0, null)
    
    var results = Array.new
    var initialState = self.state
    while (range.endIsInfinity or
           range.endIsExclusive and results.count < range.end or
           range.endIsInclusive and results.count <= range.end)
      try
        results.push(parser.call(self))
        initialState = self.state
      catch e
        if (e == self.BacktrackException and
            results.count >= range.start)
          self.state = initialState
          return results
        else
          throw e
        end
      end
    end
    return results
  end
  
  method _repeat1(parser)
    -- Todo: Range literals support require for this
    -- return self._repeat(parser, 1..*)
    return self._repeat(parser, Range.exclusive(1, null))
  end
  
  method repeat(parser, range) -> self._repeat(parser, range)
  
  method delimited(elementParser, delimiterParser, range)
    if Number.isNumber(range) then range = Range.inclusive(range, range)
    if range == null then range = Range.exclusive(0, null)
    
    var results = Array.new
    var initialState = self.state
    while (range.endIsInfinity or
           range.endIsExclusive and results.count < range.end or
           range.endIsInclusive and results.count <= range.end)
      try
        if not results.isEmpty then delimiterParser.call(self)
        results.push(elementParser.call(self))
        initialState = self.state
      catch e
        if (e == self.BacktrackException and
            results.count >= range.start)
          self.state = initialState
          return results
        else
          throw e
        end
      end
    end
    return results
  end
  
  method delimited1(elementParser, delimiterParser)
    -- Todo: Range literals support require for this
    -- return self.delimited(elementParser, delimiterParser, 1..*)
    return self.delimited(elementParser, delimiterParser, Range.exclusive(1, null))
  end
  
  method _optional(parser)
    var initialState = self.state
    try
      return parser.call(self)
    catch e
      if e == BacktrackException
        self.state = initialState
        return null
      else
        throw e
      end
    end
  end
  
  method tokenOperatorHandler(parser)
    return parser.call(self)
  end
  
  method stringPatternHandler(string)
    throw Error.new('String pattern handler not provided')
  end
  
  method numberPatternHandler(number)
    throw Error.new('Number pattern handler not provided')
  end
  
  method rangePatternHandler(range)
    throw Error.new('Range pattern handler not provided')
  end
  
  method string(string)
    string.eachChar do(c) -> self.char(c)
    return string
  end
  
  method char(..args)
    if args.isEmpty
      return self.next
    else
      var c = self.next
      args.each do(arg)
        return Function.isFunction(arg) and arg(self, c) or
               arg.include(c)
      end
      self.fail
    end
  end
  
  method fail
    throw self.BacktrackException
  end
  
  method peekNext
    if self.position < self.source.count
      return self.source[self.position]
    else
      self.fail
    end
  end
  
  method next
    if self.position < self.source.count
      var result = self.source[self.position]
      self.position = self.position + 1
      return result
    else
      self.fail
    end
  end
  
  method nextIf(predicate)
    var result = self.next
    if predicate(result)
      return result
    else
      self.fail
    end
  end
  
  method error(description)
    throw Error.new(description)
  end
  
  method nothing
    return null
  end
  
  method eof
    if self.position >= self.source.count
      return null
    else
      self.fail
    end
  end
  
  method _predicate(predicate)
    if predicate.call(self)
      return null
    else
      self.fail
    end
  end
  
  method pred(predicate)
    if predicate()
      return null
    else
      self.fail
    end
  end
  
  method _action(action)
    action.call(self)
  end
  
  method matchedInput(parser)
    var startPosition = self.position
    parser.call(self)
    var endPosition = self.position
    return self.source.slice(startPosition, endPosition)
  end
  
end
