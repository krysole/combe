{-
  Combe - A Parsing Language for JavaScript
  
  Copyright 2011 Lorenz Pretterhofer
  
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
    http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-}

var assert = require('assert')

var mori = require('mori')

var CombeArray = struct('moriVector') do(self, _class)

  -- Instance Creation
  
  _class@_empty = CombeArray.new(mori.empty)
  
  method _class.new(..elements) -> self.allocate(mori.vector(elements))
  method _class.empty -> _empty
  
  
  -- Accessing
  
  method count -> mori.count(self.moriVector)
  
  var propertyDescriptorMap = Object.new
  propertyDescriptorMap@get = method -> self.count
  Object.defineProperty(self, 'length', propertyDescriptorMap)
  
  method first -> mori.first(self.moriVector)
  method last -> mori.last(self.moriVector)
  method rest -> CombeArray.new(mori.rest(self.moriVector))
  
  method top -> mori.last(self.moriVector)
  
  method at(i) -> mori.get(self.moriVector, i)
  
  method indexOf(anObject) -> mori.find(self.moriVector, anObject)
  
  
  -- Enumerating
  
  method reduce(block, initial) -> mori.reduce(self.moriVector, initial, block)
  -- method reduceRight...
  
  method each(block) -> mori.each(self.moriVector, block)
  
  method map(block) -> CombeArray.new(mori.map(self.moriVector, block))
  method select(block) -> CombeArray.new(mori.filter(self.moriVector, block))
  method reject(block) -> CombeArray.new(mori.filter(self.moriVector, (elem) -> not block(elem)))
  
  
  -- Testing
  
  method isEmpty -> mori.isEmpty(self.moriVector)
  method isNotEmpty -> not mori.isEmtpy(self.moriVector)
  
  method includes(anObject) -> mori.hasKey(self.moriVector, anObject)
  
  method any(block) -> mori.some(self.moriVector, block)
  method none(block) -> not mori.some(self.moriVector, block)
  method all(block) -> mori.every(self.moriVector, block)
  
  method hash...
  
  method equals(anArray)...
  method equalElements(aFiniteSequence)...
  
  method compare(anArray)...
  method compareElements(aFiniteSequence)...
  
  method contains(anArray)...
  method containedBy(anArray)...
  
  method isSubset(aFiniteSequence)...
  method isSuperset(aFiniteSequence)...
  
  
  -- Deriving
  
  method push(anObject) -> CombeArray.new(mori.conj(self.moriVector, anObject))
  method pop -> CombeArray.new(mori.pop(self.moriVector))
  
  method pushAll(anArray)...
  
  method take(n) -> CombeArray.new(mori.take(self.moriVector, n))
  method drop(n) -> CombeArray.new(mori.drop(self.moriVector, n))
  
  method remove(anObject) -> CombeArray.new(mori.remove(self.moriVector, anObject))
  
  method removeAll(anArray)...
  
  method reverse -> CombeArray.new(mori.reverse(self.moriVector))
  
  method sort(block)... (block should be optional here)
  method sortBy(block)... (same as sort, but requires block)
  method sortByProperty(propertyName)...
  
  method seperatedBy(anObject)...
  
  method concat(..arrays)...
  method concatenate(..arrays)...
  
  method union(..arrays)...
  method intersection(..arrays)...
  method difference(anArray)...
  
  
  -- Converting
  
  method toArray -> mori.intoArray(self.moriVector)
  
end


var TestCase = Object.extend do(self, _class)
  
  method _class.new(block, name)
    var instance = Object.create
    instance@_name = name
    instance@_function = block
    instance@_success = null
    return instance
  end
  
  
  method name -> self@_name
  method function -> self@_function
  
  method success -> self@_success
  method success = value -> self@_success = value
  
  method fail -> self.success = false
  
  method run
    self.success = true
    self.function.call(self)
    var result = if self.success
                 then 'success'
                 else 'failure'
    console.log('Test ' + self.name + ': ' + result)
  end
  
end

-- Do some basic testing...

var testCases = Array.new

testCases.push(
  TestCase.new('empty array is empty') do(test)
    var a = CombeArray.empty
    test.assert(a.isEmpty)
    test.assert(a.count == 0)
    test.assert(a@length == 0)
  end
)


-- Do some even more basic testing... (I'll switch to a real test suite
-- as I get past this basic stuff

setTimeout(0) do
  assert(CombeArray.empty.isEmpty == true)
  assert(CombeArray.empty.count == 0)
  assert(CombeArray.empty@length == 0)
  
  
  var array = CombeArray.new(1, 2, 3, 4)
  
  assert(not array.isEmpty)
  assert(array.count == array@length)
  assert(array.count == 4)
  
  assert(array.at(0) == 1)
  assert(array.at(1) == 2)
  assert(array.at(2) == 3)
  assert(array.at(3) == 4)
  
  assert(array.first == array.at(0))
  assert(array.last == array.at(3))
  assert(array.top == array.last)
  
  -- Todo: Add plenty more testing I'm sure...
end
