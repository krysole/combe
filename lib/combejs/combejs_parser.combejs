//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

header {
  var Ast = require('./ast');
  var JSParser = require('./jsparser');
}

combe CombeJSParser (JSParser) {
  
  // Todo: I still haven't added the range syntax yet. The token support
  // is there, but not the syntax itself.
  
  rule propertyAssignment {
    | %(JSParser.prototype.propertyAssignment)
    | #describe propertyName:name #':' assignmentExpression:expr
      -> Ast('DescribePropertyDeclaration', {name: name}, expr)
  }
  
  rule memberExpression {
    ( primaryExpression
    | functionExpression
    | classExpression
    | ruleExpression
    | #new memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor[expr]:expr)*
    -> expr
  }
  
  rule statement {
    | %(JSParser.prototype.statement)
    | matchStatement
  }
  
  rule expressionStatement {
    ~(#'{' | #function | #rule | #class) expression:expr #';'
    -> Ast('ExpressionStatement', {}, expr)
  }
  
  rule sourceElement {
    | %(JSParser.prototype.sourceElement)
    | classDeclaration
    | ruleDeclaration
  }
  
  rule matchStatement {
    #match #'(' expression:subject #')' #'{' pattern:ptn #'}'
    -> Ast('MatchStatement', {}, subject, ptn)
  }
  
  rule classDeclaration {
    #class #identifier:name (#'(' expression:inherits #')')?
      #'{' delimited[propertyAssignment, #',']:pdefs #'}'
    -> Ast('ClassDeclaration', {name: name.value}, inherits).concat(pdefs)
  }
  
  rule classExpression {
    #class (#identifier:name)? (#'(' expression:inherits #')')?
      #'{' delimited[propertyAssignment, #',']:pdefs #'}'
    -> Ast('ClassExpression', {name: (name ? name.value : null)}, inherits).concat(pdefs)
  }
  
  rule ruleDeclaration {
    #rule #identifier:name (#'(' delimited[#identifier, #',']:args #')')? #'{' pattern:ptn #'}'
    -> Ast('RuleDeclaration', {name: name.value, 
         argumentNames: (args ? args.map(function (elem) {return elem.value;}) : [])
       }, ptn)
  }
  
  rule ruleExpression {
    #rule (#identifier:name)? (#'(' delimited[#identifier, #',']:args #')')? #'{' pattern:ptn #'}'
    -> Ast('RuleExpression', {name: (name ? name.value : null), 
         argumentNames: (args ? args.map(function (elem) {return elem.value;}) : [])
       }, ptn)
  }
  
  rule pattern {
    choicePattern
  }
  
  rule choicePattern {
    #'|'? returnPattern:ptn
    ( (#'|' returnPattern)+:ptns -> Ast('ChoicePattern', {}, ptn).concat(ptns)
    | -> ptn
    )
  }
  
  rule returnPattern {
    | concatPattern:ptn
      ( #'->' expression:expr 
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionExpressionPattern', {}, expr))
      | #'->' #'{' statement*:stmts #'}'
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionBlockPattern').concat(stmts))
      | -> ptn
      )
    | #'->' expression:expr -> Ast('ActionExpressionPattern', {}, expr)
    | #'->' #'{' statement*:stmts #'}' -> Ast('ActionBlockPattern').concat(stmts)
  }
  
  rule concatPattern {
    bindPattern:ptn
    ( bindPattern+:ptns -> Ast('ConcatPattern', {}, ptn).concat(ptns)
    | -> ptn
    )
  }
  
  // Todo: Move the bind operator to the same level as the repeat patterns, 
  // since any usage of the arity operators could easily be before _or_ after
  // binding it to a variable. We can simply read the operators left to right...
  rule bindPattern {
    | prefixOperatorPattern:ptn
      ( ~whitespace #':' #identifier:name
        -> Ast('BindPattern', {name: name.value}, ptn)
      | -> ptn
      )
    | #':' #identifier:name
      -> Ast('BindPattern', {name: name.value}, Ast('AnythingPattern'))
  }
  
  rule prefixOperatorPattern {
    | repeatPattern
    | #'~' prefixOperatorPattern:ptn -> Ast('NotPattern', {}, ptn)
    | #'&' prefixOperatorPattern:ptn -> Ast('LookaheadPattern', {}, ptn)
    | #'#' prefixOperatorPattern:ptn -> Ast('TokenOperatorPattern', {}, ptn)
  }
  
  rule repeatPattern {
    applyPattern:ptn
    ( #'*' -> Ast('RepeatPattern', {}, ptn)
    | #'+' -> Ast('Repeat1Pattern', {}, ptn)
    | #'?' ~(~whitespace (#'('|#'{')) -> Ast('OptionalPattern', {}, ptn)
    | -> ptn
    )
  }
  
  rule applyPattern {
    primaryPattern:ptn
    ( ~whitespace arguments:args !(ptn = Ast('JSApplyPattern', {}, ptn).concat(args))
    | ~whitespace patternArguments:args !(ptn = Ast('ApplyPattern', {}, ptn).concat(args))
    )* -> ptn
  }
  
  rule patternArguments {
    #'[' delimited[pattern, #',']:args #']' -> args
  }
  
  rule primaryPattern {
    | predicatePattern
    | actionPattern
    | immediatePattern
    | literalPattern
    | variablePattern
    | #'(' pattern:ptn #')' -> ptn
  }
  
  rule predicatePattern {
    | #'?' ~whitespace #'(' expression:expr #')'
      -> Ast('PredicateExpressionPattern', {}, expr)
    | #'?' ~whitespace #'{' statement*:stmts #'}'
      -> Ast('PredicateBlockPattern').concat(stmts)
  }
  
  rule actionPattern {
    | #'!' ~whitespace #'(' expression:expr #')'
      -> Ast('ActionExpressionPattern', {}, expr)
    | #'!' ~whitespace #'{' statement*:stmts #'}'
      -> Ast('ActionBlockPattern').concat(stmts)
  }
  
  rule immediatePattern {
    | #'%' ~whitespace #'(' expression:expr #')'
      -> Ast('ImmediateExpressionPattern', {}, expr)
    | #'%' leftHandSideExpression:expr
      -> Ast('ImmediateExpressionPattern', {}, expr)
    | #'%' ~whitespace #'{' statements*:stmts #'}'
      -> Ast('ImmediateBlockPattern').concat(stmts)
  }
  
  rule literalPattern {
    ( valueLiteral
    | #'undefined' -> Ast('ValueLiteral', {value: undefined})
    ):expr
    -> Ast('ImmediateExpressionPattern', {}, expr)
  }
  
  rule variablePattern {
    // This includes locals and then properties of this, unlike normal EcmaScript
    // variable name resolution.
    #identifier:name -> Ast('VariablePattern', {name: name.value})
  }
  
  rule whitespace {
    | &anything:token ?(!token.previousToken || token.previousToken.is('whitespace'))
    | eof
  }
  
}
