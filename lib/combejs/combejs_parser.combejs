//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

header {
  var Ast = require('./ast');
  var JSParser = require('./jsparser');
}

combe CombeJSParser (JSParser) {
  
  rule propertyAssignment {
    | %(JSParser.propertyAssignment)
    | #describe propertyName:name #':' assignmentExpression:expr
      -> Ast('DescribePropertyDeclaration', {name: name}, expr)
  }
  
  rule memberExpression {
    ( primaryExpression
    | functionExpression
    | classExpression
    | ruleExpression
    | #new memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor[expr]:expr)*
    -> expr
  }
  
  rule statement {
    | %(JSParser.statement)
    | matchStatement
  }
  
  rule expressionStatement {
    ~(#'{' | #function | #rule | #class) expression:expr #';'
    -> Ast('ExpressionStatement', {}, expr)
  }
  
  rule sourceElement {
    | %(JSParser.sourceElement)
    | classDeclaration
    | ruleDeclaration
  }
  
  rule matchStatement {
    #match #'(' expression:subject #')' #'{' pattern:ptn #'}'
    -> Ast('Match', {}, ptn, ptn)
  }
  
  rule classDeclaration {
    #class #identifier:name (#'(' expression:inherits #')')?
      #'{' delimited[propertyAssignment, #',']:pdefs #'}'
    -> Ast('ClassDeclaration', {name: name.value}, inherits).concat(pdefs)
  }
  
  rule classExpression {
    #class #identifier:name? (#'(' expression:inherits #')')?
      #'{' delimited[propertyAssignment, #',']:pdefs #'}'
    -> Ast('Class', {name: (name ? name.value : null)}, inherits).concat(pdefs)
  }
  
  rule ruleDeclaration {
    #rule #identifier:name (#'(' delimited[#identifier, #',']:args #')')? #'{' pattern:ptn #'}'
    -> Ast('RuleDeclaration', {name: name.value, 
         argumentNames: (args ? args.map(function (elem) {return elem.value;}) : [])
       }, ptn)
  }
  
  rule ruleExpression {
    #rule #identifier:name? (#'(' delimited[#identifier, #',']:args #')')? #'{' pattern:ptn #'}'
    -> Ast('RuleExpression', {name: (name ? name.value : null), 
         argumentNames: (args ? args.map(function (elem) {return elem.value;}) : [])
       }, ptn)
  }
  
  rule pattern {
    // Todo:
  }
  
}
