//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

combe CombeParser (require('./base_text_parser')) {

  rule grammar {
    $'combe' $identifier:name parentParser:parent $'{' rule*:rules $'}' $eof
      -> ['Grammar', name, parent, rules]
  }
  
  rule parentParser {
    | jsExpr['']:jsExpr -> ['Parent', jsExpr]
    | -> ['Parent', ['DefaultParent']]
  }
  
  rule rule {
    $'rule' !{this.locals = []; this.argnames = [];}
    $identifier:name ruleArgumentList:args $'{' gexpr:e $'}'
      -> ['Rule', name, args, 
          this.locals.difference(this.argnames).withoutDuplicates(), e]
  }
  rule ruleArgumentList {
    | $'[' delimited[ruleArgument, $',']:args $']' -> args
    | -> []
  }
  rule ruleArgument {
    $identifier:name !{this.argnames.push(name); this.locals.push(name);}
      -> name
  }
  
  rule gexpr {
    choice
  }
  
  rule choice {
    $'|'? returnOperator:e
    ( ($'|' returnOperator)+:es -> ['Choice', e].concat(es)
    | -> e
    )
  }
  
  rule returnOperator {
    | concat:e
      ( $'->' returnOperatorArgument:a -> ['Concat', e, a]
      | -> e
      )
    | $'->' returnOperatorArgument
  }
  rule returnOperatorArgument {
    (jsFunction[''] | jsExpr[''] | jsUntilAnyDelim):js -> ['Action', js]
  }
  
  rule concat {
    bind:e
    ( bind+:es -> ['Concat', e].concat(es)
    | -> e
    )
  }
  
  rule bind {
    | lookahead:e
      ( ':' identifier:name !(this.locals.push(name))
        -> ['Bind', name, e]
      | -> e
      )
    | $':' identifier:name !(this.locals.push(name))
      -> ['Bind', name, ['Apply', ['Property', 'anything']]]
  }
  
  rule lookahead {
    | $'~' repeat:e -> ['Not', e]
    | $'&' repeat:e -> ['Lookahead', e]
    | repeat
  }
  
  rule repeat {
    combeToken:e
    ( $'*' -> ['Repeat', e]
    | $'+' -> ['Repeat1', e]
    | $'?' -> ['Optional', e]
    | -> e
    )
  }
  
  rule combeToken {
    | $'$' term:e -> ['Token', e]
    | term
  }
  
  rule term {
    | predicate
    | action
    | apply
    | destructure
    | range
  }
  
  rule predicate {
    | jsFunction['?']:js -> ['Predicate', js]
    | jsExpr['?']:js -> ['Predicate', js]
  }
  
  rule action {
    | jsFunction['!']:js -> ['Action', js]
    | jsExpr['!']:js -> ['Action', js]
  }
  
  rule apply {
    range:e '[' delimited[gexpr, $',']:args $']'
      -> ['Apply', e, args]
  }
  
  rule destructure {
    $'[' gexpr:e $']' -> ['Destructure', e]
  }
  
  rule range {
    | simpleTerm:l 
      ( $'..' rangeArgument:r -> ['Range', l, r]
      | -> l
      )
    | rangeArgument:l $'..' rangeArgument:r -> ['Range', l, r]
  }
  rule rangeArgument {
    | $'*' -> ['Infinity']
    | simpleTerm
  }
  
  rule simpleTerm {
    | subexpr
    | immediateAction
    | literal
    | variable
  }
  
  rule subexpr {
    $'(' gexpr:e $')' -> e
  }
  
  rule immediateAction {
    | jsFunction['%']:js -> ['ImmediateAction', js]
    | jsExpr['%']:js -> ['ImmediateAction', js]
  }
  
  rule literal {
    | $string:s -> ['String', s]
    | $number:n -> ['Number', s]
  }
  
  rule variable {
    $identifier:name -> {
        if (this.locals.include(name)) {
          return ['Variable', name];
        } else {
          // We assume all non-local vars are properties of the current grammar.
          return ['Property', name];
        }
      }
  }
  
  rule jsFunction[prefix] {
    $prefix '{' jsUntil['}']:code '}' -> ['JSFunction', code]
  }
  
  rule jsExpr[prefix] {
    $prefix '(' jsUntil[')']:code ')' -> ['JSExpr', code]
  }
  
  rule jsUntilAnyDelim {
    jsUntil['..' | ',' | ']' | ')' | '}' | ';' | '|']:code -> ['JSExpr', code]
  }
  
  rule jsUntil[what] {
    matchedInput[ (~what jsChar)* ]
  }
  
  rule jsChar {
    | jsPair
    | string // Assuming JS strings are the same for now
    | char
  }
  
  rule jsPair {
    | '(' (~')' jsChar)* ')'
    | '[' (~']' jsChar)* ']'
    | '{' (~'}' jsChar)* '}'
  }
  
  rule string {
    matchedInput[
      | '\"' ('\\\\' | '\\\"' | ~'\"' char)* '\"'
      | '\'' ('\\\\' | '\\\'' | ~'\'' char)* '\''
    ]
  }
  
  rule number {
    matchedInput[digit+]
  }
  
  rule identifier {
    matchedInput[idLetter idLetterOrDigit*]
  }
  
  rule idLetter {
    letter | '_'
  }
  rule idLetterOrDigit {
    idLetter | digit
  }
  
  rule letter {
    'a'..'z' | 'A'..'Z'
  }
  
  rule digit {
    '0'..'9'
  }
  
  rule whitespace {
    | char[' \t\r\n']
    | comment
  }
  
  rule comment {
    | '//' (~newline char)* newline
    | '/*' (~'*/' char)* '*/'
  }
  
  rule newline {
    | '\r' '\n'?
    | '\n'
    | eof
  }
  
  // Todo: some of these should probably be default definitions in a parent
  // grammar (or the base Combe behaviors).
  rule token[what] {
    whitespace* what
  }
  
}
