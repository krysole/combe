//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

header {
  var Token = require('./token');
  var BaseTextParser = require('./base_text_parser');
}

combe JSLexer (BaseTextParser) {
  
  rule token[type, tags, value] {
    !{
      var endPosition = this.input.position;
      var token = new Token({
        type: type,
        tags: tags,
        value: value,
        startPosition: this.tokenStartPosition,
        endPosition: endPosition,
        input: this.input.current.$string,
        previousToken: this.lastToken
      });
      
      if (!token.is('whitespace')) {
        for (var t = this.lastToken; t.is('whitespace'); t = t.previousToken) {
          if (t.is('newline')) {
            token.precededByNewline = true;
            break;
          }
        }
      }
      
      if (this.lastToken != null) {
        this.lastToken.nextToken = token;
      }
      this.lastToken = token;
      
      this.tokenStartPosition = endPosition;
      
      return token;
    }
  }
  
  rule nextToken {
    whitespace
    
    (
    | identifierName
    | number
    | assignmentOperator
    | punctuation
    | string
    
    | &(division | regex)
      !{
        this.lastToken.endPosition = this.lastToken.startPosition;
        this.lastToken.type = 'unknown';
        this.lastToken.tags = [];
        this.lastToken.value = undefined;
        return this.lastToken;
      }
    )
  }
  
  rule resetToAfterToken[token] {
    !{
      this.lastToken = token;
      this.tokenStartPosition = this.input.position = token.endPosition;
      token.nextToken = null;
    }
  }
  
  rule resetToBeforeToken[token] {
    !{
      if (token.previousToken) {
        this.resetToAfterToken(token.previousToken)
      } else {
        this.lastToken = null;
        this.tokenStartPosition = this.input.position = 0;
      }
    }
  }
  
  rule sourceChar {
    // Todo: This should exclude the invalid codepoints, like control character,
    // i.e., any valid unicode codepoint.
    char
  }
  
  rule identifierName {
    matchedInput[idFirstChar idChar*]:text
    
    ( ?(text === 'null')
      token['null', %(['identifierName']), %(null)]
      
    | ?(text === 'true')
      token['boolean', %(['true', 'identifierName']), %(true)]
      
    | ?(text === 'false')
      token['boolean', %(['false', 'identifierName']), %(false)]
    
    | ?(text.isKeyword(text)) 
      token[text, %(['keyword', 'reservedWord', 'identifierName'])]
      
    | ?(text.isFutureReservedWord(text))
      token['futureReservedWord', %(['reservedWord', 'identifierName'])]
      
    | token['identifier', %(['identifierName']), text]
    )
  }
  
  rule idFirstChar {
    // Todo: handle unicode (es5 compliance)
    char['a'..'z', 'A'..'Z', '_', '$']
  }
  
  rule idChar {
    // Todo: handle unicode (es5 compliance)
    char['a'..'z', 'A'..'Z', '_', '$', '0'..'9']
  }
  
  rule punctuation {
    (
    | '{' | '}' | '(' | ')' | '[' | ']' | '.' | ';' | ',' 
    | '<' | '>' | '<=' | '>=' | '===' | '!==' | '==' | '!='
    | '+' | '-' | '*' | '%' | '&' | '|' | '^' | '!' | '~'
    | '&&' | '||' | '?' | ':' | '++' | '--' | '<<' | '>>' | '>>>'
    ):text
    token[text, %(['punctuation'])]
  }
  
  rule assignmentOperator {
    ( ('=':op ~'=' -> op) | '+=' | '-=' | '*=' | '%=' | '&=' | '|=' | '^='
    | '<<=' | '>>>=' | '>>='
    ):text
    token[text, %(['punctuation', 'assignmentOperator'])]
  }
  
  rule division {
    ( '/' | '/=' ):text token[text, %(['punctuation', 'division'])]
  }
  
  rule number {
    | decimal
    | hexInteger
  }
  
  rule decimal {
    matchedInput[
      | integer ('.' digit*)? (('e'|'E') ('+'|'-'|nothing) digit+)?
      | '.' digit+ (('e'|'E') ('+'|'-'|nothing) digit+)?
    ]:text ~idChar
    token['number', %(['decimal']), %(parseFloat(text))]
    // Todo: Should I include an integer tag for integers?
  }
  
  rule integer {
    char['1'..'9'] digit*
  }
  
  rule digit {
    char['0'..'9']
  }
  
  rule hexInteger {
    ('0x'|'0X') matchedInput[hexDigit+]:text ~idChar
    token['number', %(['hex']), %(parseInt(text, 16))]
  }
  
  rule hexDigit {
    char['0'..'9', 'a'..'f', 'A'..'F']
  }
  
  rule string {
    (stringHelper['\''] | stringHelper['\"']):text
    token['string', null, text]
  }
  
  rule stringHelper[quoteChar] {
    quoteChar
    (~quoteChar stringChar:c)*:characters
    quoteChar
    -> characters.join('')
  }
  
  rule stringChar {
    | '\\' stringEscapeSequence
    | '\\' newline -> ''
    | ~newline sourceChar
  }
  
  rule stringEscapeSequence {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | 'b'  -> '\b'
    | 'f'  -> '\f'
    | 'n'  -> '\n'
    | 'r'  -> '\r'
    | 't'  -> '\t'
    | 'v'  -> '\v'
    | '0' ~digit -> '\0'
    | 'x' repeat[hexDigit, %(2), %(2)]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %(4), %(4)]:hs -> String.fromCodepoint(hs.join(''))
    | ~(newline | digit) sourceChar
  }
  
  rule regex {
    '/' matchedInput[(~'*' regexChar) regexChar*]:pattern '/' matchedInput[idChar*]:options
    token['regex', null, %(new RegExp(pattern, options))]
  }
  
  rule regexChar {
    | '\\' ~newline sourceChar
    | regexCharacterClass
    | ~('/' | newline) sourceChar
  }
  
  rule regexCharacterClass {
    '[' regexCharacterClassChar ']'
  }
  
  rule regexCharacterClassChar {
    | '\\' ~newline sourceChar
    | ~(']' | newline) sourceChar
  }
  
  rule whitespace {
    (spaces | newline | comment)*
  }
  
  rule spaces {
    char[' \t\v\f\u00a0\u200c\u200d\ufeff']
    // Still missing other unicode 'space separator's?
    token['spaces', %(['whitespace'])]
  }
  
  rule newline {
    ('\r\n' | char['\n\r\u2028\u2029'])
    token['newline', %(['whitespace'])]
  }
  
  rule comment {
    (
    | '//' (~newline sourceChar)* (newline | eof)
    | '/*' (~'*/' sourceChar)* '*/'
    )
    token['comment', %(['whitespace'])]
  }

}