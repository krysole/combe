//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

combe CombeASTTranslator {
  
  rule recur {
    [transform:result] -> result
  }

  rule transform {
    | 'Grammar' :name recur:parent [recur*:rules]
        -> ["// Generated by Combe/JS Compiler\n",
            "\n",
            "var extend = require('./util').extend;\n",
            "var ParentParser = ", parent, ";\n",
            "var Range = require('./range');\n",
            "\n",
            "var ", name, " = module.exports = function () {\n",
            "  ParentParser.call(this);\n",
            "};\n",
            "\n",
            "extend((", name, ".prototype = Object.create(ParentParser.prototype)), {\n",
            "\n",
            rules.interpolate(',\n\n'), '\n\n',
            '});\n']
    
    | 'Parent' ['JSExpr' :jsCode] -> ['(', jsCode, ')']
    
    | 'Parent' ['DefaultParent'] -> "(require('./base_parser'))"
    
    | 'Rule' :name :args :vars recur:expr
        -> [(name.isReserved() ? name.quote() : name), 
              ': function (', args.interpolate(', '), ') {\n',
            (vars.isEmpty() ? '' : ['var ', vars.interpolate(', '), ';\n']),
            'return this._apply(', expr, ');\n',
            '}']
    
    | 'Choice' recur+:exprs
        -> ['(function () {return this._choice(', exprs.interpolate(',\n'), ');})']
    
    | 'Concat' recur+:exprs
        -> ['(function () {return this._concat(', exprs.interpolate(',\n'), ');})']
    
    | 'Action' recur:jsExpr -> jsExpr
    
    | 'Bind' :name recur:expr
        -> ['(function () {return (', name, ' = this._apply(', expr, '));})']
    
    | 'Not' recur:expr
        -> ['(function () {return this._not(', expr, ');})']
    
    | 'Lookahead' recur:expr
        -> ['(function () {return this._lookahead(', expr, ');})']
    
    | 'Repeat' recur:expr
        -> ['(function () {return this._repeat(', expr, ');})']
    
    | 'Repeat1' recur:expr
        -> ['(function () {return this._repeat1(', expr, ');})']
    
    | 'Optional' recur:expr
        -> ['(function () {return this._optional(', expr, ');})']
    
    | 'Token' recur:expr
        -> ['(function () {return this.token(', expr, ');})']
    
    | 'Predicate' recur:jsExpr
        -> ['(function () {return this._predicate(', expr, ');})']
    
    | 'Apply' recur:expr 
      ( [recur*:argExprs]
          -> ['(function () {return this._apply(', expr, ', ', 
                argExprs.interpolate(', '), ');})']
      | -> ['(function () {return this._apply(', expr, ');})']
      )
    
    | 'ImmediateAction' ['JSFunction' :jsCode]
        -> ['(function () {', jsCode, '}).call(this)']
    
    | 'ImmediateAction' ['JSExpr' :jsCode]
        -> ['(', jsCode, ')']
    
    | 'Destructure' recur:expr
        -> ['(function () {return this._destructure(', expr, ');})']
    
    | 'Range' recur:leftExpr recur:rightExpr
        -> ['(new Range(', leftExpr, ', ', rightExpr, '))']
    
    | 'Infinity' -> 'Infinity'
    
    | 'String' :string -> string
    
    | 'Number' :number -> number
    
    | 'Variable' :name -> name
    
    | 'Property' :name -> {
          if (name.isReserved()) {
            return 'this[' + name.quote() + ']';
          } else {
            return 'this.' + name;
          }
        }
    
    | 'JSFunction' :jsCode
        -> ['(function () {', jsCode, '})']
    
    | 'JSExpr' :jsCode
        -> ['(function () {return (', jsCode, ');})']
  }

}
