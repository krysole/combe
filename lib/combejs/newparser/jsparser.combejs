//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

var BaseTokenParser = require('../combejs/base_token_parser');
var Token = require('../combejs/token');

var JSParser = module.exports = class JSParser (BaseTokenParser) {
  
  // Useful entry points are 'expression', 'program' and possibly
  // 'statement' or 'sourceElement' (statements + function declarations)
  
  primaryExpression: rule {
    | 'this'                -> Ast('This')
    | 'identifier':token    -> Ast('VariableLookup', {name: token.value})
    | valueLiteral:token    -> Ast('ValueLiteral', {value: token.value})
    | arrayLiteral
    | objectLiteral
    | '(' expression:e ')'  -> e
  },
  
  valueLiteral: rule {
    | 'null'
    | 'boolean'
    | 'number'
    | 'string'
    | 'regex'
  },
  
  arrayLiteral: rule {
    '[' delimited[assignmentExpression?, ',']:exprs ']'
    -> Ast('ArrayLiteral').concat(exprs)
  },
  
  objectLiteral: rule {
    '{' delimited[propertyAssignment, ',']:pdefs '}'
    -> Ast('ObjectLiteral').concat(pdefs)
  },
  
  propertyAssignment: rule {
    | propertyName:name ':' assignmentExpression:expr
      -> Ast('ValuePropertyDeclaration', {name: name}, expr)
    | 'get' propertyName:name '(' ')' '{' functionBody:body '}'
      -> Ast('GetPropertyDeclaration', {name: name}).concat(body)
    | 'set' propertyName:name '(' 'identifier':arg ')' '{' functionBody:body '}'
      -> Ast('SetPropertyDeclaration', {name: name, argumentName: arg.value}).concat(body)
  },
  
  propertyName: rule {
    ( 'identifierName'
    | 'string'
    | 'number'
    ):token -> token.name
  },
  
  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | 'new' memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor[expr]:expr)*
    -> expr
  },
  
  newExpression: rule {
    | memberExpression
    | 'new' newExpression:ctor
      -> Ast('New', {}, ctor)
  },
  
  propertyAccessor: rule (subject) {
    | '[' expression:expr ']'
      -> Ast('PropertyLookup', {}, subject, expr)
    | '.' 'identifierName':t
      -> Ast('PropertyLookup', {}, subject, Ast('ValueLiteral', {value: t.value}))
  },
  
  callExpression: rule {
    memberExpression:expr arguments:args
    !(expr = Ast('Call', {}, expr).concat(args))
    ( arguments:args
      !(expr = Ast('Call', {}, expr).concat(args))
    | propertyAccessor[expr]:expr
    )*
    -> expr
  },
  
  arguments: rule {
    '(' delimited[assignmentExpression, ',']:exprs ')' -> exprs
  },
  
  leftHandSideExpression: rule {
    | callExpression
    | newExpression
  },
  
  postfixExpression: rule {
    leftHandSideExpression:expr
    ( ~newline '++'
      -> Ast('PostfixIncrement', {sign: +1}, expr)
    | ~newline '--'
      -> Ast('PostfixIncrement', {sign: -1}, expr)
    | -> expr
    )
  },
  
  unaryExpression: rule {
    | postfixExpression
    | 'delete'  unaryExpression:expr -> Ast('Delete', {}, expr)
    | 'void'    unaryExpression:expr -> Ast('Void', {}, expr)
    | 'typeof'  unaryExpression:expr -> Ast('TypeOf', {}, expr)
    | ('++'|'--'|'+'|'-'|'~'|'!'):op unaryExpression:expr
      -> Ast('UnaryOperator', {name: op.type}, expr)
  },
  
  multiplicativeExpression: rule {
    unaryExpression:expr
    ( ('*'|'/'|'%'):op unaryExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },
  
  additiveExpression: rule {
    multiplicativeExpression:expr
    ( ('+'|'-'):op multiplicativeExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },
  
  shiftExpression: rule {
    additiveExpression:expr
    ( ('<<'|'>>'|'>>>'):op additiveExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },
  
  inToken: rule (noIn) {
    ?(!noIn) 'in'
  },
  
  relationalExpression: rule (noIn) {
    shiftExpression:expr
    ( ('<'|'>'|'<='|'>='|'instanceof'|inToken(noIn)):op shiftExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },
  
  equalityExpression: rule (noIn) {
    relationalExpression(noIn):expr
    ( ('=='|'!='|'==='|'!=='):op relationalExpression(noIn):rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },
  
  bitwiseAndExpression: rule (noIn) {
    equalityExpression(noIn):expr
    ( '&' equalityExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '&'}, expr, rhs))
    )*
    -> expr
  },
  
  bitwiseXorExpression: rule (noIn) {
    bitwiseAndExpression(noIn):expr
    ( '^' bitwiseAndExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '^'}, expr, rhs))
    )*
    -> expr
  },
  
  bitwiseOrExpression: rule (noIn) {
    bitwiseXorExpression(noIn):expr
    ( '|' bitwiseXorExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '|'}, expr, rhs))
    )*
    -> expr
  },
  
  logicalAndExpression: rule (noIn) {
    bitwiseOrExpression(noIn):expr
    ( '&&' bitwiseOrExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '&&'}, expr, rhs))
    )*
    -> expr
  },
  
  logicalOrExpression: rule (noIn) {
    logicalAndExpression(noIn):expr
    ( '||' logicalAndExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '||'}, expr, rhs))
    )*
    -> expr
  },
  
  conditionalExpression: rule (noIn) {
    logicalOrExpression(noIn):cond
    ( '?' assignmentExpression(noIn):trueExpr ':' assignmentExpression(noIn):falseExpr
      -> Ast('ConditionalExpression', {}, cond, trueExpr, falseExpr)
    | -> cond
    )
  },
  
  assignmentExpression: rule (noIn) {
    | leftHandSideExpression:lhs 
      ( '=' assignmentExpression(noIn):rhs
        -> Ast('Assignment', {}, lhs, rhs)
      | 'assignmentOperator':op assignmentExpression(noIn):rhs
        -> Ast('OperatorAssignment', {operator: op.type.slice(0, -1)}, lhs, rhs)
      )
    | conditionalExpression
  },
  
  expression: rule (noIn) {
    delimited1[assignmentExpression(noIn), ',']:exprs
    ( ?(exprs.length === 1)
      -> exprs[0]
    | -> Ast('ExpressionSequence').concat(exprs)
    )
  },
  
  statement: rule (noIn) {
    | block
    | variableStatement
    | emptyStatement
    | expressionStatement
    | ifStatement
    | iterationStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | withStatement
    | labelledStatement
    | switchStatement
    | throwStatement
    | tryStatement
    | debuggerStatement
  },
  
  block: rule {
    '{' statement*:stmts '}'
    -> Ast('Block').concat(stmts)
  },
  
  variableStatement: rule {
    'var' variableDeclarationList:lst ';' -> lst
  },
  
  variableDeclarationList: rule (noIn) {
    delimited1[variableDeclaration(noIn), ',']:lst
    -> Ast('VariableDeclarationList').concat(lst)
  },
  
  variableDeclaration: rule (noIn) {
    'identifier':name
    ( '=' assignmentExpression(noIn):expr
      -> Ast('VariableDeclaration', {name: name.value}, expr)
    | -> Ast('VariableDeclaration', {name: name.value}
    )
  },
  
  emptyStatement: rule {
    ';' -> Ast('EmptyStatement')
  },
  
  expressionStatement: rule {
    ~('{'|'function') expression:expr ';'
    -> Ast('ExpressionStatement', {}, expr)
  },
  
  ifStatement: rule {
    'if' '(' expression:cond ')' statement:trueBranch
    ( 'else' statement:falseBranch
      -> Ast('If', {}, cond, trueBranch, falseBranch)
    | -> Ast('If', {}, cond, trueBranch)
    )
  },
  
  iterationStatement: rule {
    | 'do' statement:stmt 'while' '(' expression:cond ')' ';'
      -> Ast('DoWhile', {}, cond, stmt)
    | 'while' '(' expression:cond ')' statement:stmt
      -> Ast('While', {}, cond, stmt)
      
    | 'for' '(' expression(true)?:initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> Ast('For', {}, initExpr, condExpr, incExpr, stmt)
    | 'for' '(' 'var' variableDeclarationList(true):initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> Ast('For', {}, initExpr, condExpr, incExpr, stmt)
    
    | 'for' '(' leftHandSideExpression:lvalue 'in' expression:subject ')' statement:stmt
      -> Ast('ForIn', {}, lvalue, subject, stmt)
    | 'for' '(' 'var' variableDeclaration(true):vardecl 'in' expression:subject ')' statement:stmt
      -> Ast('ForIn', {declare: [vardecl.name]}, vardecl.at(0), subject, stmt)
  },
  
  continueStatement: rule {
    'continue' ~newline 'identifier'?:name ';'
    -> Ast('Continue', {label: (name ? name.value : null)})
  },
  
  breakStatement: rule {
    'break' ~newline 'identifier'?:name ';'
    -> Ast('Break', {label: (name ? name.value : null)})
  },
  
  returnStatement: rule {
    'return' ~newline 
    ( expression:expr ';'
      -> Ast('Return', {}, expr)
    | ';'
      -> Ast('Return')
    )
  },
  
  withStatement: rule {
    'with' '(' expression:subject ')' statement:stmt
    -> Ast('With', {}, subject, stmt)
  },
  
  switchStatement: rule {
    'switch' '(' expression:subject ')' '{'
    !(Ast('Switch')):ast caseClause(ast)* (defaultClause(ast) caseClause(ast)*)? '}'
    -> ast
  },
  
  caseClause: rule (ast) {
    'case' expression:cmp ':' statement*:stmts
    !(ast.push(Ast('CaseClause', {}, cmp).concat(stmts)))
  },
  
  defaultClause: rule (ast) {
    'default' ':' statement*:stmts
    !(ast.push(Ast('DefaultClause').concat(stmts)))
  },
  
  labelledStatement: rule {
    'identifier':name ':' statement:stmt
    -> Ast('Label', {name: name.value}, stmt)
  },
  
  throwStatement: rule {
    'throw' ~newline expression:expr ';'
    -> Ast('Throw', {}, expr)
  },
  
  tryStatement: rule {
    | 'try' block:blk catch:c
      -> Ast('Try', {}, blk, c)
    | 'try' block:blk finally:f
      -> Ast('Try', {}, blk, null, f)
    | 'try' block:blk catch:c finally:f
      -> Ast('Try', {}, blk, c, f)
  },
  
  catch: rule {
    'catch' '(' 'identifier':name ')' block:blk
    -> Ast('Catch', {name: name.value}, blk)
  },
  
  finally: rule {
    'finally' block:blk
    -> blk
  },
  
  debuggerStatement: rule {
    'debugger' ';'
    -> Ast('Debugger')
  },
  
  functionDeclaration: rule {
    'function' 'identifier':name '(' delimited['identifier', ',']:args ')' 
      '{' functionBody:stmts '}'
    !(args.map(function (elem) {return elem.value})):args
    -> Ast('FunctionDeclaration', {name: name.value, argumentNames: args}).concat(stmts)
  },
  
  functionExpression: rule {
    'function' 'identifier'?:name '(' delimited['identifier', ',']:args ')'
      '{' functionBody:stmts '}'
    !(args.map(function (elem) {return elem.value})):args
    -> Ast('FunctionExpression', {name: name.value, argumentNames: args}).concat(stmts)
  },
  
  functionBody: rule {
    sourceElement*
  },
  
  program: rule {
    sourceElement*:stmts
    -> Ast('Program').concat(stmts)
  },
  
  sourceElement: rule {
    | statement
    | functionDeclaration
  },
  
  newline: rule {
    | &anything:token ?(token.precededByNewline)
    | eof
  },
  
  getNextToken: function (tag) {
    var token;
    if (this.input.current.eof()) {
      this.fail();
    }
    
    if (tag === '/' || tag === '/=') {
      token = this.input.current.readReplacing(['unknown', 'regex'], 'division');
    } else if (tag === 'regex') {
      token = this.input.current.readReplacing(['unknown', 'division'], 'regex');
    } else {
      token = this.input.current.read();
    }
    
    if (token.is(tag)) {
      return token;
    } else {
      this.fail();
    }
  },
  
};
