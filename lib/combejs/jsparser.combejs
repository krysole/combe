//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

header {
  var Ast = require('./ast');
}

combe JSParser {
  
  // Entry points are 'expression' and 'program'
  
  rule primaryExpression {
    | #this
    | #identifier
    | valueLiteral
    | arrayLiteral
    | objectLiteral
    | #'(' expression:e #')'
  }
  
  rule valueLiteral {
    | #null
    | #boolean
    | #number
    | #string
    | #regex
  }
  
  rule arrayLiteral {
    #'[' delimited[assignmentExpression?, #','] #']'
  }
  
  rule objectLiteral {
    #'{' delimited[propertyAssignment, #','] #'}'
  }
  
  rule propertyAssignment {
    | propertyName #':' assignmentExpression
    | #get propertyName #'(' #')' #'{' functionBody #'}'
    | #set propertyName #'(' #identifier #')' #'{' functionBody #'}'
  }
  
  rule propertyName {
    | #identifierName
    | #string
    | #number
  }
  
  rule memberExpression {
    ( primaryExpression
    | functionExpression
    | #new memberExpression arguments
    )
    propertyAccessor*
  }
  
  rule newExpression {
    | memberExpression
    | #new newExpression
  }
  
  rule propertyAccessor {
    | #'[' expression #']'
    | #'.' #identifierName
  }
  
  rule callExpression {
    memberExpression arguments
    ( arguments 
    | propertyAccessor
    )*
  }
    
  rule arguments {
    #'(' delimited[assignmentExpression, #','] #')'
  }
  
  rule leftHandSideExpression {
    | callExpression
    | newExpression
  }
  
  rule postfixExpression {
    leftHandSideExpression
    ( ~newline #'++'
    | ~newline #'--'
    | nothing
    )
  }
  
  rule unaryExpression {
    | postfixExpression
    | #delete unaryExpression
    | #void   unaryExpression
    | #typeof unaryExpression
    | #'++'   unaryExpression
    | #'--'   unaryExpression
    | #'+'    unaryExpression
    | #'-'    unaryExpression
    | #'~'    unaryExpression
    | #'!'    unaryExpression
  }
  
  rule multiplicativeExpression {
    unaryExpression
    ((#'*'|#'/'|#'%') unaryExpression)*
  }
  
  rule additiveExpression {
    multiplicativeExpression
    ((#'+'|#'-') multiplicativeExpression)*
  }
  
  rule shiftExpression {
    additiveExpression
    ((#'<<'|#'>>'|#'>>>') additiveExpression)*
  }
  
  rule inToken[noIn] {
    ?(!noIn) #in
  }
  
  rule relationalExpression[noIn] {
    shiftExpression
    ((#'<'|#'>'|#'<='|#'>='|#instanceof|inToken[noIn]) shiftExpression)*
  }
  
  rule equalityExpression[noIn] {
    relationalExpression[noIn]
    ((#'=='|#'!='|#'==='|#'!==') relationalExpression[noIn])*
  }
  
  rule bitwiseAndExpression[noIn] {
    equalityExpression[noIn]
    (#'&' equalityExpression[noIn])*
  }
  
  rule bitwiseXorExpression[noIn] {
    bitwiseAndExpression[noIn]
    (#'^' bitwiseAndExpression[noIn])*
  }
  
  rule bitwiseOrExpression[noIn] {
    bitwiseXorExpression[noIn]
    (#'|' bitwiseXorExpression[noIn])*
  }
  
  rule logicalAndExpression[noIn] {
    bitwiseOrExpression[noIn]
    (#'&&' bitwiseOrExpression[noIn])*
  }
  
  rule logicalOrExpression[noIn] {
    logicalAndExpression[noIn]
    (#'||' logicalAndExpression[noIn])*
  }
  
  rule conditionalExpression[noIn] {
    logicalOrExpression[noIn]
    ( #'?' assignmentExpression[noIn] #':' assignmentExpression[noIn]
    | nothing
    )
  }
  
  rule assignmentExpression[noIn] {
    | leftHandSideExpression #assignmentOperator assignmentExpression[noIn]
    | conditionalExpression
  }
  
  rule expression[noIn] {
    delimited1[assignmentExpression[noIn], #',']
  }
  
  rule statement {
    | block
    | variableStatement
    | emptyStatement
    | expressionStatement
    | ifStatement
    | iterationStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | withStatement
    | labelledStatement
    | switchStatement
    | throwStatement
    | tryStatement
    | debuggerStatement
  }
  
  rule block {
    #'{' statement* #'}'
  }
  
  rule variableStatement {
    #var variableDeclarationList #';'
  }
  
  rule variableDeclarationList[noIn] {
    delimited1[variableDeclaration[noIn], #',']
  }
  
  rule variableDeclaration[noIn] {
    #identifier
    ( #'=' assignmentExpression[noIn]
    | nothing
    )
  }
  
  rule emptyStatement {
    #';'
  }
  
  rule expressionStatement {
    ~(#'{' | #function) expression #';'
  }
  
  rule ifStatement {
    #if #'(' expression #')' statement
    ( #else statement
    | nothing
    )
  }
  
  rule iterationStatement {
    | #do statement #while #'(' expression #')' #';'
    | #while #'(' expression #')' statement
    | #for #'(' expression[true]? #';' expression? #';' expression? #')' statement
    | #for #'(' #var variableDeclarationList[true] #';' expression? #';' expression? #')' statement
    | #for #'(' leftHandSideExpression #in expression #')' statement
    | #for #'(' #var variableDeclaration[true] #in expression #')' statement
  }
  
  rule continueStatement {
    #continue ~newline #identifier? #';'
  }
  
  rule breakStatement {
    #break ~newline #identifier? #';'
  }
  
  rule returnStatement {
    #return ~newline expression? #';'
  }
  
  rule withStatement {
    #with #'(' expression #')' statement
  }
  
  rule switchStatement {
    #switch #'(' expression #')' #'{' caseClause* (defaultClause caseClause*)? #'}'
  }
  
  rule caseClause {
    #case expression #':' statement*
  }
  
  rule defaultClause {
    #default #':' statement*
  }
  
  rule labelledStatement {
    #identifier #':' statement
  }
  
  rule throwStatement {
    #throw ~newline expression #';'
  }
  
  rule tryStatement {
    | #try block catch
    | #try block finally
    | #try block catch finally
  }
  
  rule catch {
    #catch #'(' #identifier #')' block
  }
  
  rule finally {
    #finally block
  }
  
  rule debuggerStatement {
    #debugger #';'
  }
  
  rule functionDeclaration {
    #function #identifier #'(' delimited[#identifier, #','] #')' #'{' functionBody #'}'
  }
  
  rule functionExpression {
    #function #identifier? #'(' delimited[#identifier, #','] #')' #'{' functionBody #'}'
  }
  
  rule functionBody {
    sourceElement*
  }
  
  rule program {
    sourceElement*
  }
  
  rule sourceElement {
    | statement
    | functionDeclaration
  }
  
  rule newline {
    | &anything:token ?(token.preceededByNewline)
    | eof
  }
  
  rule defaultTokenOperatorHandler[what] {
    error["Cannot use default tokenOperatorHandler"]
  }
  
  rule stringTokenOperatorHandler[string] {
    getNextToken[string]
  }
  
  rule identifierTokenOperatorHandler[name] {
    getNextToken[name]
  }
  
  rule getNextToken[tag] {
    !{
      var token;
      if (this.input.current.eof()) {
        this._fail();
      }
      
      if (tag === '/' || tag === '/=') {
        token = this.input.current.readReplacing(['unknown', 'regex'], 'division');
      } else if (tag === 'regex') {
        token = this.input.current.readReplacing(['unknown', 'division'], 'regex');
      } else {
        token = this.input.current.read();
      }
      
      if (token.is(tag)) {
        return token;
      } else {
        this._fail();
      }
    }
  }
  
}
