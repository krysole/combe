//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

header {
  var Ast = require('./ast');
}

combe JSParser {
  
  // Entry points are 'expression' and 'program'
  
  rule primaryExpression {
    | #this                   -> Ast('This')
    | #identifier:token       -> Ast('VariableLookup', {name: token.value})
    | valueLiteral
    | arrayLiteral
    | objectLiteral
    | #'(' expression:e #')'  -> e
  }
  
  rule valueLiteral {
    ( #null
    | #boolean
    | #number
    | #string
    | #regex
    ):token -> Ast('ValueLiteral', {value: token.value})
  }
  
  rule arrayLiteral {
    #'[' delimited[arrayElement, #',']:exprs #']'
    -> Ast('ArrayLiteral', {}).concat(exprs)
  }
  
  rule arrayElement {
    | assignmentExpression
    | -> Ast('Elision')
  }
  
  rule objectLiteral {
    #'{' delimited[propertyAssignment, #',']:pdefs #','? #'}'
    -> Ast('ObjectLiteral', {}).concat(pdefs)
  }
  
  rule propertyAssignment {
    | propertyName:name #':' assignmentExpression:expr
      -> Ast('ValuePropertyDeclaration', {name: name}, expr)
    | #get propertyName:name #'(' #')' #'{' functionBody:body #'}'
      -> Ast('GetPropertyDeclaration', {name: name}).concat(body)
    | #set propertyName:name #'(' #identifier:arg #')' #'{' functionBody:body #'}'
      -> Ast('SetPropertyDeclaration', {name: name, argumentName: arg.value}).concat(body)
  }
  
  rule propertyName {
    | #identifierName:token -> token.identifierName
    | #string:token -> token.value
    | #number:token -> token.value
  }
  
  rule memberExpression {
    ( primaryExpression
    | functionExpression
    | #new memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor[expr]:expr)*
    -> expr
  }
  
  rule newExpression {
    | memberExpression
    | #new newExpression:ctor
      -> Ast('New', {}, ctor)
  }
  
  rule propertyAccessor[subject] {
    | #'[' expression:expr #']'
      -> Ast('PropertyLookup', {}, subject, expr)
    | #'.' #identifierName:t
      -> Ast('DotPropertyLookup', {name: t.value}, subject)
  }
  
  rule callExpression {
    memberExpression:expr arguments:args
    !{
      if (expr.is('DotPropertyLookup')) {
        expr = Ast('CallProperty', {name: expr.name}, expr.children[0]).concat(args);
      } else {
        expr = Ast('Call', {}, expr).concat(args);
      }
    }
    ( arguments:args
      !(expr = Ast('Call', {}, expr).concat(args))
    | propertyAccessor[expr]:expr
    )*
    -> expr
  }
    
  rule arguments {
    #'(' delimited[assignmentExpression, #',']:exprs #')' -> exprs
  }
  
  rule leftHandSideExpression {
    | callExpression
    | newExpression
  }
  
  rule postfixExpression {
    leftHandSideExpression:expr
    ( ~newline #'++'
      -> Ast('PostfixIncrement', {sign: +1}, expr)
    | ~newline #'--'
      -> Ast('PostfixIncrement', {sign: -1}, expr)
    | nothing
      -> expr
    )
  }
  
  rule unaryExpression {
    | postfixExpression
    | #delete unaryExpression:expr
      -> Ast('Delete', {}, expr)
    | #void unaryExpression:expr
      -> Ast('Void', {}, expr)
    | #typeof unaryExpression:expr
      -> Ast('TypeOf', {}, expr)
    | (#'++' | #'--' | #'+' | #'-' | #'~' | #'!'):op unaryExpression:expr
      -> Ast('UnaryOperator', {name: op.type}, expr)
  }
  
  rule multiplicativeExpression {
    unaryExpression:expr
    ((#'*'|#'/'|#'%'):op unaryExpression:rhs
     !(expr = Ast('Operator', {name: op.type}, expr, rhs)))*
    -> expr
  }
  
  rule additiveExpression {
    multiplicativeExpression:expr
    ((#'+'|#'-'):op multiplicativeExpression:rhs
     !(expr = Ast('Operator', {name: op.type}, expr, rightExpr)))*
    -> expr
  }
  
  rule shiftExpression {
    additiveExpression:expr
    ((#'<<'|#'>>'|#'>>>'):op additiveExpression:rhs
     !(expr = Ast('Operator', {name: op.type}, expr, rhs)))*
    -> expr
  }
  
  rule inToken[noIn] {
    ?(!noIn) #in
  }
  
  rule relationalExpression[noIn] {
    shiftExpression:expr
    ((#'<'|#'>'|#'<='|#'>='|#instanceof|inToken[noIn]):op shiftExpression:rhs
     !(expr = Ast('Operator', {name: op.type}, expr, rhs)))*
    -> expr
  }
  
  rule equalityExpression[noIn] {
    relationalExpression[noIn]:expr
    ((#'=='|#'!='|#'==='|#'!=='):op relationalExpression[noIn]:rhs
     !(expr = Ast('Operator', {name: op.type}, expr, rhs)))*
    -> expr
  }
  
  rule bitwiseAndExpression[noIn] {
    equalityExpression[noIn]:expr
    (#'&' equalityExpression[noIn]:rhs
     !(expr = Ast('Operator', {name: '&'}, expr, rhs)))*
    -> expr
  }
  
  rule bitwiseXorExpression[noIn] {
    bitwiseAndExpression[noIn]:expr
    (#'^' bitwiseAndExpression[noIn]:rhs
     !(expr = Ast('Operator', {name: '^'}, expr, rhs)))*
    -> expr
  }
  
  rule bitwiseOrExpression[noIn] {
    bitwiseXorExpression[noIn]:expr
    (#'|' bitwiseXorExpression[noIn]:rhs
     !(expr = Ast('Operator', {name: '|'}, expr, rhs)))*
    -> expr
  }
  
  rule logicalAndExpression[noIn] {
    bitwiseOrExpression[noIn]:expr
    (#'&&' bitwiseOrExpression[noIn]:rhs
     !(expr = Ast('Operator', {name: '&&'}, expr, rhs)))*
    -> expr
  }
  
  rule logicalOrExpression[noIn] {
    logicalAndExpression[noIn]:expr
    (#'||' logicalAndExpression[noIn]:rhs
     !(expr = Ast('Operator', {name: '||'}, expr, rhs)))*
    -> expr
  }
  
  rule conditionalExpression[noIn] {
    logicalOrExpression[noIn]:cond
    ( #'?' assignmentExpression[noIn]:trueExpr #':' assignmentExpression[noIn]:falseExpr
      -> Ast('ConditionalExpression', {}, cond, trueExpr, falseExpr)
    | nothing
      -> cond
    )
  }
  
  rule assignmentExpression[noIn] {
    | leftHandSideExpression:lhs #assignmentOperator:op assignmentExpression[noIn]:rhs
      !{
        if (op.type === '=') {
          return Ast('Assignment', {}, lhs, rhs);
        } else {
          return Ast('OperatorAssignment', {operator: op.type.slice(0, -1)}, lhs, rhs);
        }
      }
    | conditionalExpression
  }
  
  rule expression[noIn] {
    delimited1[assignmentExpression[noIn], #',']:exprs
    ( ?(exprs.length === 1) -> exprs[0]
    | -> Ast('ExpressionSequence', {}).concat(exprs)
    )
  }
  
  rule statement {
    | block
    | variableStatement
    | emptyStatement
    | expressionStatement
    | ifStatement
    | iterationStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | withStatement
    | labelledStatement
    | switchStatement
    | throwStatement
    | tryStatement
    | debuggerStatement
  }
  
  rule block {
    #'{' statement*:stmts #'}'
    -> Ast('Block', {}).concat(stmts)
  }
  
  rule variableStatement {
    #var variableDeclarationList:lst #';' -> lst
  }
  
  rule variableDeclarationList[noIn] {
    delimited1[variableDeclaration[noIn], #',']:lst
    -> Ast('VariableDeclarationList').concat(lst)
  }
  
  rule variableDeclaration[noIn] {
    #identifier:name
    ( #'=' assignmentExpression[noIn]:expr
      -> Ast('VariableDeclaration', {name: name.value}, expr)
    | nothing
      -> Ast('VariableDeclaration', {name: name.value})
    )
  }
  
  rule emptyStatement {
    #';' -> Ast('EmptyStatement')
  }
  
  rule expressionStatement {
    ~(#'{' | #function) expression:expr #';'
    -> Ast('ExpressionStatement', {}, expr)
  }
  
  rule ifStatement {
    #if #'(' expression:cond #')' statement:trueBranch
    ( #else statement:falseBranch
      -> Ast('If', {}, cond, trueBranch, falseBranch)
    | nothing
      -> Ast('If', {}, cond, trueBranch)
    )
  }
  
  rule iterationStatement {
    | #do statement:stmt #while #'(' expression:cond #')' #';'
      -> Ast('DoWhile', {}, cond, stmt)
    | #while #'(' expression:cond #')' statement:stmt
      -> Ast('While', {}, cond, stmt)
    | #for #'(' expression[true]?:initExpr #';' expression?:condExpr 
        #';' expression?:incExpr #')' statement:stmt
      -> Ast('For', {}, initExpr, condExpr, incExpr, stmt)
    | #for #'(' #var variableDeclarationList[true]:initExpr 
        #';' expression?:condExpr #';' expression?:incExpr #')' statement:stmt
      -> Ast('For', {}, initExpr, condExpr, incExpr, stmt)
    | #for #'(' leftHandSideExpression:lvalue #in expression:subject #')' statement:stmt
      -> Ast('ForIn', {}, lvalue, subject, stmt)
    | #for #'(' #var variableDeclaration[true]:vardecl #in expression:subject #')' statement:stmt
      -> Ast('ForIn', {declare: [vardecl.name]}, vardecl.at(0), subject, stmt)
  }
  
  rule continueStatement {
    #continue ~newline #identifier?:name #';'
    -> Ast('Continue', {label: (name ? name.value : null)})
  }
  
  rule breakStatement {
    #break ~newline #identifier?:name #';'
    -> Ast('Break', {label: (name ? name.value : null)})
  }
  
  rule returnStatement {
    #return ~newline expression?:expr #';'
    !{
      var ast = Ast('Return');
      if (expr) ast.push(expr);
      return ast;
    }
  }
  
  rule withStatement {
    #with #'(' expression:subject #')' statement:stmt
    -> Ast('With', {}, subject, stmt)
  }
  
  rule switchStatement {
    #switch #'(' expression:subject #')' #'{' 
    !(Ast('Switch')):ast caseClause[ast]* (defaultClause[ast] caseClause[ast]*)? #'}'
    -> ast
  }
  
  rule caseClause[ast] {
    #case expression:cmp #':' statement*:stmts
    !(ast.push(Ast('CaseClause', {}, cmp).concat(stmts)))
  }
  
  rule defaultClause[ast] {
    #default #':' statement*:stmts
    !(ast.push(Ast('DefaultClause').concat(stmts)))
  }
  
  rule labelledStatement {
    #identifier:name #':' statement:stmt
    -> Ast('Label', {name: name.value}, stmt)
  }
  
  rule throwStatement {
    #throw ~newline expression:expr #';'
    -> Ast('Throw', {}, expr)
  }
  
  rule tryStatement {
    | #try block:blk catch:c
      -> Ast('Try', {}, blk, c)
    | #try block:blk finally:f
      -> Ast('Try', {}, blk, null, f)
    | #try block:blk catch:c finally:f
      -> Ast('Try', {}, blk, c, f)
  }
  
  rule catch {
    #catch #'(' #identifier:name #')' block:blk
    -> Ast('Catch', {name: name.value}, blk)
  }
  
  rule finally {
    #finally block:blk
    -> blk
  }
  
  rule debuggerStatement {
    #debugger #';'
    -> Ast('Debugger')
  }
  
  rule functionDeclaration {
    #function #identifier:name #'(' delimited[#identifier, #',']:args #')' #'{' functionBody:stmts #'}'
    -> Ast('FunctionDeclaration', {name: name.value, 
      argumentNames: args.map(function (elem) {return elem.value})}).concat(stmts)
  }
  
  rule functionExpression {
    #function #identifier?:name #'(' delimited[#identifier, #',']:args #')' #'{' functionBody:stmts #'}'
    -> Ast('FunctionExpression', {name: (name ? name.value : null), 
      argumentNames: args.map(function (elem) {return elem.value})}).concat(stmts)
  }
  
  rule functionBody {
    sourceElement*
  }
  
  rule program {
    sourceElement*:stmts eof
    -> Ast('Program').concat(stmts)
  }
  
  rule sourceElement {
    | statement
    | functionDeclaration
  }
  
  rule newline {
    | &anything:token ?(token.preceededByNewline)
    | eof
  }
  
  rule defaultTokenOperatorHandler[what] {
    error["Cannot use default tokenOperatorHandler"]
  }
  
  rule stringTokenOperatorHandler[string] {
    getNextToken[string]
  }
  
  rule identifierTokenOperatorHandler[name] {
    getNextToken[name]
  }
  
  rule getNextToken[tag] {
    !{
      var token;
      if (tag === '/' || tag === '/=') {
        token = this.input.current.readReplacing(['unknown', 'regex'], 'division');
      } else if (tag === 'regex') {
        token = this.input.current.readReplacing(['unknown', 'division'], 'regex');
      } else {
        token = this.input.current.read();
      }
      
      if (token.is(tag)) {
        return token;
      } else {
        this._fail();
      }
    }
  }
  
  rule eof {
    getNextToken['eof']
  }
  
}
