//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

header {
}

combe JSParser {
  
  rule script {
    statement*:stmts eof -> stmts
  }
  
  rule primaryExpression {
    | #this
    | #identifier
    | valueLiteral
    | arrayLiteral
    | objectLiteral
    | #'(' expression #')'
  }
  
  rule valueLiteral {
    | #null
    | #boolean
    | #number
    | #string
    | #regex
  }
  
  rule arrayLiteral {
    #'[' delimited[assignmentExpression?, #','] #']'
  }
  
  rule objectLiteral {
    #'{' delimited[propertyAssignment, #','] #'}'
  }
  
  rule propertyAssignment {
    | propertyName #':' assignmentExpression
    | #get propertyName #'(' #')' #'{' functionBody #'}'
    | #set propertyName #'(' #identifier #')' #'{' functionBody #'}'
  }
  
  rule propertyName {
    | #identifierName
    | #string
    | #number
  }
  
  rule memberExpression {
    ( primaryExpression
    | functionExpression
    | #new memberExpression arguments
    )
    propertyAccessor*
  }
  
  rule newExpression {
    | memberExpression
    | #new newExpression
  }
  
  rule propertyAccessor {
    | #'[' expression #']'
    | #'.' #identifierName
  }
  
  rule callExpression {
    memberExpression arguments
    ( arguments 
    | propertyAccessor
    )*
  }
    
  rule arguments {
    #'(' delimited[assignmentExpression, #','] #')'
  }
  
  rule leftHandSideExpression {
    | newExpression
    | callExpression
  }
  
  rule postfixExpression {
    leftHandSideExpression
    ( ~newline #'++'
    | ~newline #'--'
    | nothing
    )
  }
  
  rule unaryExpression {
    | postfixExpression
    | #delete unaryExpression
    | #void   unaryExpression
    | #typeof unaryExpression
    | #'++'   unaryExpression
    | #'--'   unaryExpression
    | #'+'    unaryExpression
    | #'-'    unaryExpression
    | #'~'    unaryExpression
    | #'!'    unaryExpression
  }
  
  rule multiplicativeExpression {
    unaryExpression
    ((#'*'|#'/'|#'%') unaryExpression)*
  }
  
  rule additiveExpression {
    multiplicativeExpression
    ((#'+'|#'-') multiplicativeExpression)*
  }
  
  rule shiftExpression {
    additiveExpression
    ((#'<<'|#'>>'|#'>>>') additiveExpression)*
  }
  
  rule inToken[allowIn] {
    ?(allowIn) #in
  }
  
  rule relationalExpression[allowIn] {
    shiftExpression
    ((#'<'|#'>'|#'<='|#'>='|#instanceof|inToken[allowIn]) shiftExpression)*
  }
  
  rule equalityExpression[allowIn] {
    relationalExpression[allowIn]
    ((#'=='|#'!='|#'==='|#'!==') relationalExpression[allowIn])*
  }
  
  rule bitwiseAndExpression[allowIn] {
    equalityExpression[allowIn]
    (#'&' equalityExpression[allowIn])*
  }
  
  rule bitwiseXorExpression[allowIn] {
    bitwiseAndExpression[allowIn]
    (#'^' bitwiseAndExpression[allowIn])*
  }
  
  rule bitwiseOrExpression[allowIn] {
    bitwiseXorExpression[allowIn]
    (#'|' bitwiseXorExpression[allowIn])*
  }
  
  rule logicalAndExpression[allowIn] {
    bitwiseOrExpression[allowIn]
    (#'&&' bitwiseOrExpression[allowIn])*
  }
  
  rule logicalOrExpression[allowIn] {
    logicalAndExpression[allowIn]
    (#'||' logicalAndExpression[allowIn])*
  }
  
  rule conditionalExpression[allowIn] {
    logicalOrExpression[allowIn]
    ( #'?' assignmentExpression[allowIn] #':' assignmentExpression[allowIn]
    | nothing
    )
  }
  
  rule assignmentExpression[allowIn] {
    | conditionalExpression
    | leftHandSideExpression #assignmentOperator assignmentExpression[allowIn]
  }
  
  rule expression[allowIn] {
    delimited[assignmentExpression[allowIn], #',']
  }
  
  rule statement {
    | block
    | variableStatement
    | emptyStatement
    | expressionStatement
    | ifStatement
    | iterationStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | withStatement
    | labelledStatement
    | switchStatement
    | throwStatement
    | tryStatement
    | debuggerStatement
  }
  
  rule block {
    #'{' statement* #'}'
  }
  
  rule variableStatement {
    #var variableDeclarationList #';'
  }
  
  rule variableDeclarationList[allowIn] {
    delimited[variableDeclaration[allowIn], #',']
  }
  
  rule variableDeclaration[allowIn] {
    #identifier
    ( #'=' assignmentExpression[allowIn]
    | nothing
    )
  }
  
  rule emptyStatement {
    #';'
  }
  
  rule expressionStatement {
    ~(#'{' | #function) expression #';'
  }
  
  rule ifStatement {
    #if #'(' expression #')' statement
    ( #else statement
    | nothing
    )
  }
  
  rule iterationStatement {
    | #do statement #while #'(' expression #')' #';'
    | #while #'(' expression #')' statement
    | #for #'(' expression[false]? #';' expression? #';' expression? #')' statement
    | #for #'(' #var variableDeclarationList[false] #';' expression? #';' expression? #')' statement
    | #for #'(' leftHandSideExpression #in expression #')' statement
    | #for #'(' #var variableDeclaration[false] #in expression #')' statement
  }
  
  rule continueStatement {
    #continue ~newline #identifier? #';'
  }
  
  rule breakStatement {
    #break ~newline #identifier? #';'
  }
  
  rule returnStatement {
    #return ~newline expression? #';'
  }
  
  rule withStatement {
    #with #'(' expression #')' statement
  }
  
  rule switchStatement {
    #switch #'(' expression #')' #'{' caseClause* defaultClause caseClause* #'}'
  }
  
  rule caseClause {
    #case expression #':' statement*
  }
  
  rule defaultClause {
    #default #':' statement*
  }
  
  rule labelledStatement {
    #identifier #':' statement
  }
  
  rule throwStatement {
    #throw ~newline expression #';'
  }
  
  rule tryStatement {
    | #try block catch
    | #try block finally
    | #try block catch finally
  }
  
  rule catch {
    #catch #'(' #identifier #')' block
  }
  
  rule finally {
    #finally block
  }
  
  rule debuggerStatement {
    #debugger #';'
  }
  
  rule functionDeclaration {
    #function #identifier #'(' delimited[#identifier, #','] #')' #'{' functionBody #'}'
  }
  
  rule functionExpression {
    #function #identifier? #'(' delimited[#identifier, #','] #')' #'{' functionBody #'}'
  }
  
  rule functionBody {
    sourceElement*
  }
  
  rule program {
    sourceElement*
  }
  
  rule sourceElement {
    | statement
    | functionDeclaration
  }
  
  rule newline {
    | &anything:token ?(token.preceededByNewline)
    | eof
  }
  
  rule defaultTokenOperatorHandler[what] {
    error["Cannot use default tokenOperatorHandler"]
  }
  
  rule stringTokenOperatorHandler[string] {
    getNextToken[string]
  }
  
  rule identifierTokenOperatorHandler[name] {
    getNextToken[name]
  }
  
  rule getNextToken[tag] {
    !{
      if (this.input.current.eof()) {
        this._fail();
      } else if (tag === '/' || tag === '/=') {
        return this.input.current.readReplacing(['unknown', 'regex'], 'division', tag);
      } else if (tag === 'regex') {
        return this.input.current.readReplacing(['unknown', 'division'], 'regex', tag);
      } else {
        return this._anything(function (token) {
          return token.is(tag);
        });
      }
    }
  }
  
}
