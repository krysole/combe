//
// Combe - A Parsing Extension for JavaScript
//
// Copyright 2015 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
"use strict";

var crypto = require('crypto');

var Util = require("../Util.js");
var Show = require("../Show.js");
var Ast = require("../Ast.js");
var ObjectGrammar = require("../ObjectGrammar.js");



function Translator() {
  ObjectGrammar.call(this);
};
Translator.prototype = Object.create(ObjectGrammar.prototype);
Translator.prototype.constructor = Translator;
module.exports = Translator;



Translator.prototype.start = rule (r) {
  postorderTransform[%r, rewrite]:r
  postorderTransform[%r, simplify]:r
  on[%r, translate(0)]:r
  !r
};



Translator.prototype.hash = function (r) {
  var text = Show.show(r);
  var hash = crypto.createHash("md5");
  hash.update(text);
  return hash.digest("base64").slice(0, -2); // Without base64 suffix
};

Translator.prototype.memoname = function (name, iname, hash) {
  if (name != null) iname = name;
  if (iname == null) iname = "*unnamed";
  return iname + "_" + hash;
};



Translator.prototype.rewrite = rule {
  
| [^"Rule", :indent, :name, :iname, :pf, :bs, :p]:r
  hash(r):h memoname(name, iname, h):memoname
  ![
    [^"VarDecl*", bs],
    [^"ExprStmt", [^"ThisCall", [^"ThisProperty", "ignore"], []]],
    [^"ExprStmt", [^"ThisCall", [^"ThisProperty", "pushStartPosition"], []]],
    [^"VarDecl", "__result", [^"ThisCall", p, []]],
    [^"ExprStmt", [^"ThisCall", [^"ThisProperty", "popStartPosition"], []]],
    [^"Return", [^"Var", "__result"]]
  ]:stmts
  
  ( on[%pf, ( [] | nou )]
    ![^"Indent", indent,
      [^"Function", name, null, [
        [^"Return", [^"ThisCall", [^"ThisProperty", "memoize"], 
                                  [[^"Fragment", memoname.quote()],
                                   [^"Function", null, null, stmts]
                                  ]
                    ]
        ]
      ]]
    ]
  | ![^"Indent", indent,
      [^"Function", name, pf, stmts]
    ]
  )
  
  
  
| [^"ChoicePattern",      :as] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "choice"      ], as ]]]]
| [^"SequencePattern",    :as] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "sequence"    ], as ]]]]
| [^"BindPattern",  :name, :p] ![^"Function", null, null, [[^"Return", [^"Assign", [^"Var", name], [^"ThisCall", p, []]    ]]]]
| [^"LookaheadPattern",    :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "lookahead"   ], [p]]]]]
| [^"DoubleNegatePattern", :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "doubleNegate"], [p]]]]]
| [^"NegatePattern",       :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "negate"      ], [p]]]]]
| [^"OptionalPattern",     :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "optional"    ], [p]]]]]
| [^"RepeatPattern",       :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "repeat"      ], [p]]]]]
| [^"Repeat1Pattern",      :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "repeat1"     ], [p]]]]]
| [^"JSCallPattern",  :p, :af] ![^"Function", null, null, [[^"Return", [^"ThisCall", p, af]]]]
| [^"CallPattern",    :p, :as] ![^"Function", null, null, [[^"Return", [^"ThisCall", p, as]]]]
| [^"PredicatePattern",    :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "predicate"   ], [p]]]]]
| [^"ActionPattern",       :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "action"      ], [p]]]]]
| [^"ImmediatePattern",    :p] ![^"ThisCall", p, []]
| [^"PropertyPattern",  :name] ![^"ThisProperty", name]
| [^"ObjectPattern",       :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "object"      ],      [[^"ThisCall", p, []]]]]]]
| [^"StringPattern",       :f] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "string"      ],      [[^"Fragment", f    ]]]]]]
| [^"NumberPattern",       :f] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "number"      ],      [[^"Fragment", f    ]]]]]]
| [^"RegularExpression",   :f] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "regularExpression"], [[^"Fragment", f    ]]]]]]
| [^"NestedArrayPattern",  :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "nestedArray" ], [p]]]]]
| [^"NestedAstPattern",    :p] ![^"Function", null, null, [[^"Return", [^"ThisCall", [^"ThisProperty", "nestedAst"   ], [p]]]]]
| [^"EmptyPattern"           ] ![^"ThisProperty", "pass"]
| [^"NextPattern"            ] ![^"ThisProperty", "next"]

| [^"AstConstructor",      :f] ![^"New", [^"Var", "Ast"], [f]]

| [^"ExpressionSemanticBody", :f] ![^"Function", null, null, [[^"Return", [^"Subexpression", f]]]]
| [^"FunctionSemanticBody",   :f] ![^"Function", null, null, [f]]
| [^"ImmediateSemanticBody",  :f] ![^"Function", null, null, [[^"Return", f]]]

| :

};



Translator.prototype.simplify = rule {
  
| [^"ThisCall", [^"ThisProperty", :name], :as_or_f]
  ![^"Call", [^"Lookup", [^"This"], name], as_or_f]
  
| [^"ThisCall", :fn, [next*:as]]
  ![^"Call", [^"Lookup", fn, "call"], [[^"This"]].concat(as)]
  
| [^"ThisCall", :fn, :f]
  ![^"Call", [^"Lookup", fn, "call"], [[^"This"], f]]
  
  
  
| [^"ThisProperty", :name]
  ![^"Lookup", [^"This"], name]
  
  

| [^"Call", [^"Function", nou, ( [] | nou ), [[^"Return", :expr]]],
            ( [] | nou )
  ]
  !expr
  
| [^"Call", [^"Lookup", [^"Function", nou, ( [] | nou ), [[^"Return", :expr]]],
                        "call"
            ],
            [[^"This"]]
  ]
  !expr


  
| :
  
};



Translator.prototype.translate = rule (i) {
  
| [^"Indent", :k, translate(k):x]
  !x
  
  
  
| [^"Composite", [translate(i)*:fs]]
  !fs.join("")

| [^"Fragment", :f]
  !f



  // Functions
  
| [^"Function", :name, :ps, [translate(i + 2)*:stmts]]
  on[%ps, ( [next*:ps]          !ps.join(", ")
          | nou                 !""
          | translate(i):pf     !pf
          )
  ]:ps
  !( name != null ? name : "" ):name
  !(
    "function " + name + "(" + ps + ") {\n" +
      stmts.join("") +
    " ".repeat(i) + "}"
  )
  
  
  
  // Statements
  
| [^"VarDecl*", :names]
  !{
    if (names.length > 0) {
      return " ".repeat(i) + "var " + names.join(", ") + ";\n";
    }
    else {
      return "";
    }
  }
  
| [^"VarDecl", :name, translate(i)?:expr]
  !{
    if (expr != null) {
      return " ".repeat(i) + "var " + name + " = " + expr + ";\n";
    }
    else {
      return " ".repeat(i) + "var " + name + ";\n";
    }
  }
  
| [^"ExprStmt", translate(i):expr]
  !(
    " ".repeat(i) + expr + ";\n"
  )
  
| [^"Return", translate(i):expr]
  !(
    " ".repeat(i) + "return " + expr + ";\n"
  )
  
  
  
  // Expressions
  
| [^"Assign", translate(i):lvalue, translate(i):rvalue]
  !(
    lvalue + " = " + rvalue
  )
  
| [^"Call", translate(i + 2):fn, [[^"This"]]]
  !(
    fn + "(this)"
  )
  
| [^"Call", translate(i + 2):fn, [[^"This"], translate(i + 2)*:as]]
  !{
    if (Util.isSingleline(as.join(", "))) {
      return fn + "(this, " + as.join(", ") + ")";
    }
    else {
      return (
        fn + "(this,\n" + 
          " ".repeat(i + 2) + as.join(",\n" + " ".repeat(i + 2)) + "\n" +
        " ".repeat(i) + ")"
      );
    }
  }
  
| [^"Call", translate(i + 2):fn, [translate(i + 2)*:as]]
  !{
    if (Util.isSingleline(as.join(", "))) {
      return fn + "(" + as.join(", ") + ")";
    }
    else {
      return (
        fn + "(\n" +
          " ".repeat(i + 2) + as.join(",\n" + " ".repeat(i + 2)) + "\n" +
        " ".repeat(i) + ")"
      );
    }
  }
  
| [^"New", translate(i):fn, [translate(i)*:as]]
  !(
    "new " + fn + "(" + as.join(", ") + ")"
  )
  
| [^"Lookup", translate(i):o, :name]
  !{
    if (Util.isIdentifierName(name)) return o + "." + name;
    else                             return o + "[" + name.quote() + "]";
  }
  
| [^"Var", :name]
  !name
  
| [^"This"]
  !"this"
  
| [^"Subexpression", translate(i):expr]
  !(
    "(" + expr + ")"
  )
  
  
  
  // Unexpected form
  
| :x error("Unexpected translator jsast " + Show.synopsis(x))
  
};
