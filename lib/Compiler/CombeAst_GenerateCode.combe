//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2012 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var crypto = require('crypto')

var AstVisitor = require('./AstVisitor')

var CombeAst = require('./CombeAst')

var CombeAst_GenerateCode = module.exports = AstVisitor.subclass('CombeAst_GenerateCode', {}, {
  
  order: 'post'
  recurseOverUnspecified: false
  
  handleScript(ast) { // [ statements ]
    var stmts = ast.statements.map(function (stmt) {
      return [stmt.code, ';\n']
    })
    
    ast.code = [
      '// Generated by Combe compiler (', CombeVersion, ')\n',
      '"use strict";\n',
      'if (!__combe_runtimeLoaded) throw new Error("Combe runtime not loaded");\n',
      '(function () {\n',
        'var __combe_this = null;\n',
        'var __combe_return = null;\n',
        'try {\n',
          stmts,
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})();'
    ]
  }
  
  handleVarStatement(ast) { // [ declarations ]
    var decls = ast.declarations.map(function (decl) {
      return decl.code
    }).separatedBy(', ')
    
    ast.code = [
      'var ', decls
    ]
  }
  
  
  handleIf(ast) { // [ condition, consiquent, alternative ]
    var alt = (ast.alternative != null) ? ast.alternative.code : 'null'
    
    ast.code = [
      '(/* if */ ', ast.condition.code, '\n',
      '? /* then */ ', ast.consiquent.code, '\n',
      ': /* else */ ', alt, ')'
    ]
  }
  
  handleWhile(ast) { // [ condition, body ]
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        'while (', ast.condition.code, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '}\n',
      '})()'
    ]
  }
  
  handleDoWhile(ast) { // [ body, condition ]
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        'do {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '} while (', ast.condition.code, ');\n',
      '})()'
    ]
  }
  
  handleFor(ast) { // [ initialize, condition, increment, body ]
    var init = (ast.initialize != null) ? ast.initialize.code : null
    var cond = (ast.condition != null) ? ast.condition.code : null
    var inc = (ast.increment != null) ? ast.increment.code : null
    
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        'for (', init, '; ', cond, '; ', inc, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '}\n',
      '})()'
    ]
  }
  
  handleForDeclaring(ast) { // [ declarations, condition, increment, body ]
    var decls = ['var ', ast.declarations.map(function (decl) {
      return decl.code
    }).separatedBy(', ')]
    
    var names = []
    var inits = []
    for (var i = 0; i < ast.declarations.length; i++) {
      var decl = ast.declarations[i]
      names.push(decl.name)
      inits.push(decl.expression.code)
    }
    names.separatedBy(', ')
    inits.separatedBy(', ')
    
    var cond = (ast.condition != null) ? ast.condition.code : null
    var inc = (ast.increment != null) ? ast.increment.code : null
    
    var body = self.unwrapBlockAsStatements(ast.body, true)
    
    ast.code = [
      '(function (', names, ') {\n',
        'while (', cond, ') {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e !== __combe_continue) throw __combe_e;\n',
          '}\n',
          inc, ';\n',
        '}\n',
      '})(', inits, ')'
    ]
  }
  
  handleDo(ast) { // [ body ]
    var body = self.unwrapBlockAsStatements(ast.body)
    
    ast.code = [
      '(function () {\n',
        '/* do */ {\n',
          'try {\n',
            body,
          '}\n',
          'catch (__combe_e) {\n',
            'if (__combe_e === __combe_break) break;\n',
            'if (__combe_e === __combe_continue) continue;\n',
            'throw __combe_e;\n',
          '}\n',
        '}\n',
      '})()'
    ]
  }
  
  handleTryCatch(ast) { // [ tryBody, catchVariable, catchBody, finallyBody ]
    var tryFragment = [
      'try {\n',
        ast.tryBody.code, ';\n',
      '}\n'
    ]
    
    var catchFragment = null
    if (ast.catchBody != null) {
      catchFragment = [
        'catch (', ast.catchVariable, ') {\n',
          ast.catchBody.code, ';\n',
        '}\n'
      ]
    }
    
    var finallyBody = null
    if (ast.finallyBody != null) {
      finallyBody = [
        'finally {\n',
          ast.finallyBody.code, ';\n',
        '}\n'
      ]
    }
    
    ast.code = [
      '(function () {\n', 
        tryFragment,
        catchFragment,
        finallyBody,
      '})()'
    ]
  }
  
  handleThrow(ast) { // [ argument ]
    ast.code = [
      '(function () { throw ', ast.argument.code, '; })()'
    ]
  }
  
  handleReturn(ast) { // [ argument ]
    var valueCode = (ast.argument != null) ? ast.argument.code : 'undefined'
    
    ast.code = [
      '(function () { throw (__combe_return = { value: ', valueCode, ' }); })()'
    ]
  }
  
  handleBreak(ast) { // [ ]
    ast.code = [
      '(function () { throw __combe_break; })()'
    ]
  }
  
  handleContinue(ast) { // [ ]
    ast.code = [
      '(function () { throw __combe_continue; })()'
    ]
  }
  
  handleSequence(ast) { // [ expressions ]
    var exprs = ast.expressions.map(function (expr) {
      return expr.code
    }).separatedBy(', ')
    
    if (exprs.isEmpty()) {
      exprs = 'null'
    }
    
    ast.code = [
      '(', exprs, ')'
    ]
  }
  
  
  handleAssignment(ast) { // [ lhs, rhs ]
    if (ast.lhs.is('Subscript')) {
      ast.code = self.generateMethodCall(ast.lhs.subject.code, CombeAst.Literal('setSubscript'), ast.lhs.arguments.concat(ast.rhs))
    }
    else { // Dot or Variable
      ast.code = [
        '(', ast.lhs.code, ' = ', ast.rhs.code, ')'
      ]
    }
  }
  
  handleOperatorAssignment(ast) { // [ name, lhs, rhs ]
    if (ast.lhs.is('Subscript')) {
      var argumentsVariable = self.generateArgumentsVariable(ast.lhs.arguments)
      if (argumentsVariable == null) {
        // We know that our arguments are a simple list
        argumentsVariable = [
          'var __combe_arguments = [', ast.lhs.arguments.map(a -> a.code).separatedBy(', '), '];\n'
        ]
      }
      var opname = ast.name.slice(0, ast.name.length - 1)
      ast.code = [
        '(function () {\n',
          'var __combe_subject = ', ast.lhs.subject.code, ';\n',
          argumentsVariable,
          'var __combe_value = __combe_subject.subscript.apply(__combe_subject, __combe_arguments) ', opname, ' ', ast.rhs, ';\n',
          '__combe_arguments.push(__combe_value);\n',
          '__combe_subject.setSubscript.apply(__combe_subject, __combe_arguments);\n',
          'return __combe_value;\n',
        '})()'
      ]
    }
    else {
      ast.code = [
        '(', ast.lhs.code, ' ', ast.name, ' ', ast.rhs.code, ')'
      ]
    }
  }
  
  handlePrefixOperator(ast) { // [ name, argument ]
    ast.code = [
      '(', ast.name, ast.argument.code, ')'
    ]
  }
  
  handlePostfixOperator(ast) { // [ name, argument ]
    ast.code = [
      '(', ast.argument.code, ast.name, ')'
    ]
  }
  
  handleInfixOperator(ast) { // [ name, lhs, rhs ]
    if (['==', '!=', '<', '<=', '>', '>=', '<=>'].include(ast.name)) {
      ast.code = [
        '__combe_infixOperators[', ast.name.quote(), '](',
          ast.lhs.code, ', ',
          ast.rhs.code,
        ')'
      ]
    }
    else {
      ast.code = [
        '(', ast.lhs.code, ' ', ast.name, ' ', ast.rhs.code, ')'
      ]
    }
  }
  
  
  handleCall(ast) { // [ function, arguments ]
    ast.code = self.generateCall(ast.function.code, ast.arguments)
  }
  
  handleSubscript(ast) { // [ subject, arguments ]
    ast.code = self.generateMethodCall(ast.subject.code, CombeAst.Literal('subscript'), ast.arguments)
  }
  
  handleMethodCall(ast) { // [ subject, name, arguments ]
    ast.code = self.generateMethodCall(ast.subject.code, ast.name, ast.arguments)
  }
  
  handleDot(ast) { // [ subject, name ]
    if (ast.name.is('Literal') &&
        String.isClassOf(ast.name.value) &&
        ast.name.value.isJavaScriptPropertyName()) {
      ast.code = [ast.subject.code, '.', ast.name.value]
    }
    else {
      ast.code = [ast.subject.code, '[', ast.name.code, ']']
    }
  }
  
  
  handleInclusiveRange(ast) { // [ lhs, rhs ]
    ast.code = [
      'Range.inclusive(',
        ast.lhs.code, ', ',
        ast.rhs.code,
      ')'
    ]
  }
  
  handleExclusiveRange(ast) { // [ lhs, rhs ]
    ast.code = [
      'Range.exclusive(',
        ast.lhs.code, ', ',
        ast.rhs.code,
      ')'
    ]
  }
  
  handleThis(ast) { // [ ]
    ast.code = '__combe_this'
  }
  
  handleVariable(ast) { // [ name ]
    ast.code = ast.name
  }
  
  handleLiteral(ast) { // [ value ]
    ast.code = String.sourceStringFrom(ast.value)
  }
  
  handleArray(ast) { // [ arguments ]
    if (ast.arguments == null) ast.arguments = []
    
    var argumentsVariable = self.generateArgumentsVariable(ast.arguments)
    if (argumentsVariable != null) {
      ast.code = [
        '(function () {\n',
          argumentsVariable,
          'return __combe_arguments;\n',
        '})()'
      ]
    }
    else {
      ast.code = ['[', ast.arguments.map((a) -> a.code).separatedBy(', '), ']']
    }
  }
  
  handleObject(ast) { // [ properties ]
    var prologue = [
      'var __combe_object = {};\n'
    ]
    
    var decls = ast.properties.map(function (pdecl) {
      return [pdecl.code, ';\n']
    })
    
    var epilogue = [
      'return __combe_object;\n'
    ]
    
    ast.code = [
      '(function () {\n',
        prologue,
        decls,
        epilogue,
      '})()'
    ]
  }
  
  
  handleFunction(ast) { // [ parameters, body ]
    var p = self.generateParameters(ast.parameters)
    
    ast.code = [
      '(function (', p.jsParams, ') {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        p.restParams,
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
  }
  
  handleMethod(ast) { // [ parameters, body ]
    var p = self.generateParameters(ast.parameters)
    
    ast.code = [
      '(function (', p.jsParams, ') {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'var self = this;\n',
        p.restParams,
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
  }
  
  handleRule(ast) { // [ parameters, body ]
    var p = self.generateParameters(ast.parameters)
    
    var declareVars = null
    if (ast.declareVariables.length >= 1) {
      declareVars = [
        'var ', ast.declareVariables.separatedBy(', '), ';\n'
      ]
    }
    
    if (p.jsParams == null && p.restParams == null) {
      var innerFunction = [
        '(function () {\n',
          'var self = this;\n',
          declareVars,
          'return ', ast.body.code, '.call(this);\n',
        '})'
      ]
      
      var innerFunctionCode = Array.deepJoinIOList(innerFunction)
      var hash = crypto.createHash('md5')
      hash.update(innerFunctionCode)
      var digest = hash.digest('base64').slice(0, -2); // without base64 suffix
      
      ast.code = [
        '(function () {\n',
          'return this.__combe_memoize(', digest.quote(), ', ', innerFunction, ');\n',
        '})'
      ]
    }
    else {
      ast.code = [
        '(function (', p.jsParams, ') {\n',
          p.restParams,
          'var self = this;\n',
          declareVars,
          'return ', ast.body.code, '.call(this);\n',
        '})'
      ]
    }
  }
  
  handleVariableDeclaration(ast) { // [ name, expression ]
    // Note: These should always be attached to a JS var statement...
    if (ast.expression != null) {
      ast.code = [ast.name, ' = ', ast.expression.code]
    }
    else {
      ast.code = ast.name
    }
  }
  
  
  handleBlock(ast) { // [ statements ]
    var stmts = ast.statements.map(function (stmt) {
      return [stmt.code, ';\n']
    })
    
    ast.code = [
      '(function () {\n',
        stmts, // no default result
      '})()'
    ]
  }
  
  
  handleSplatArgument(ast) { // [ argument ]
    ast.code = ast.argument.code;
  }
  
  handleParameter(ast) { // [ name ]
    // Do nothing
  }
  
  handleSplatParameter(ast) { // [ name ]
    // Do nothing
  }
  
  
  handleValueProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe_defineValueProperty(', 
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  handleGetProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe_defineGetProperty(', 
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  handleSetProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe_defineSetProperty(',
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  handleDescribeProperty(ast) { // [ name, value ]
    ast.code = [
      '__combe_defineDescribedProperty(', 
        '__combe_object, ',
        ast.name.code, ', ',
        ast.value.code,
      ')'
    ]
  }
  
  handleChoicePattern(ast) { // [ patterns ]
    var ps = ast.patterns.map(function (p) {
      return p.code
    }).separatedBy(', ')
    
    ast.code = [
      '(function () {\n',
        'return this.__combe_choice(', ps, ');\n',
      '})'
    ]
  }
  
  handleSequencePattern(ast) { // [ patterns ]
    var ps = ast.patterns.slice(0, ast.patterns.length - 1).map(function (p) {
      return [p.code, '.call(this);\n']
    })
    ps.push([
      'return ', ast.patterns.last.code, '.call(this);\n'
    ])
    
    ast.code = [
      '(function () {\n',
        ps,
      '})'
    ]
  }
  
  handleNotPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_not(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  handleLookaheadPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_lookahead(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  handleHashOperatorPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.handleHashPattern(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  handleRepeatPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_repeat(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  handleNonZeroRepeatPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_nonZeroRepeat(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  handleOptionalPattern(ast) { // [ pattern ]
    ast.code = [
      '(function () {\n',
        'return this.__combe_optional(', ast.pattern.code, ');\n',
      '})'
    ]
  }
  
  handleBindPattern(ast) { // [ pattern, name ]
    ast.code = [
      '(function () {\n',
        'return (', ast.name, ' = ', ast.pattern.code, '.call(this));\n',
      '})'
    ]
  }
  
  handleCallPattern(ast) { // [ pattern, arguments ]
    var argumentsVariable = self.generateArgumentsVariable(ast.arguments);
    if (argumentsVariable != null) {
      ast.code = [
        '(function () {\n',
          'var __combe_this = this;\n', // Needed for argumentsVariable
          'var __combe_subject = ', ast.pattern.code, ';\n',
          argumentsVariable,
          'return __combe_subject.apply(__combe_this, __combe_arguments);\n',
        '})'
      ]
    }
    else {
      var as = ast.arguments.map((a) -> a.code).separatedBy(', ')
      ast.code = [
        '(function () {\n',
          'var __combe_this = this;\n', // Needed for arguments
          'return ', ast.pattern.code, '.call(this, ', as, ');\n',
        '})'
      ]
    }
  }
  
  handlePredicatePattern(ast) { // [ body ]
    var pattern = [
      '(function () {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
    
    ast.code = [
      '(function () {\n',
        'return this.__combe_predicate(', pattern, ');\n',
      '})'
    ]
  }
  
  handleActionPattern(ast) { // [ body ]
    ast.code = [
      '(function () {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
  }
  
  handleImmediateActionPattern(ast) { // [ body ]
    var pattern = [
      '(function () {\n',
        'var __combe_this = this;\n',
        'var __combe_return = null;\n',
        'try {\n',
          'return ', ast.body.code, ';\n',
        '}\n',
        'catch (__combe_e) {\n',
          'if (__combe_e === __combe_return) return __combe_return.value;\n',
          'throw __combe_e;\n',
        '}\n',
      '})'
    ]
    
    ast.code = [
      pattern, '.call(this)'
    ]
  }
  
  handleStringPattern(ast) { // [ argument ]
    ast.code = [
      '(function () {\n',
        'return this.handleStringPattern(', ast.argument.code, ');\n',
      '})'
    ]
  }
  
  handleVariablePattern(ast) { // [ name ]
    if (ast.containingScope.variables.include(ast.name)) {
      ast.code = [ ast.name ]
    }
    else {
      ast.code = [ 'this.', ast.name ]
    }
  }
  
  
  unwrapBlockAsStatements(ast, ignoreDefAndVarTest) {
    if (ignoreDefAndVarTest == null) ignoreDefAndVarTest = false
    
    if (ast == null) {
      return null
    }
    else if (ast.type === 'Block') {
      var stmts = ast.statements.map(function (stmt) {
        return [stmt.code, ';\n']
      })
      
      if (ast.statements.some(function (stmt) {
        return ['VarStatement'].include(stmt.type)
      }) || ignoreDefAndVarTest) {
        return stmts
      }
      else {
        return [
          '(function () {\n',
            stmts,
          '})()'
        ]
      }
    }
    else {
      return [ast.code, ';\n']
    }
  }
  
  generateArgumentsVariable(args) {
    if (args == null || args.length == 0) {
      return null
    }
    else if (args.length === 1 && args[0].is('SplatArgument')) {
      return ['var __combe_arguments = ', args[0].code, ';\n']
    }
    else if (args.any((a) -> a.is('SplatArgument'))) {
      var initialArgumentsLimit = args.indexOfPredicate((a) -> a.is('SplatArgument'));
      var initialArgumentsCode = args.slice(0, initialArgumentsLimit).map((a) -> a.code)
      
      var code = [
        'var __combe_arguments = [', initialArgumentsCode.separatedBy(', '), '];\n'
      ]
      
      for (var i = initialArgumentsLimit; i < args.length; i++) {
        if (args[i].is('SplatArgument')) {
          code.push('__combe_arguments.pushAll(', args[i].code, ');\n')
        }
        else {
          code.push('__combe_arguments.push(', arg[i].code, ');\n')
        }
      }
      
      return code;
    }
    else {
      return null;
    }
  }
  
  generateCall(functionCode, args) {
    if (args == null) args = []
    
    var argumentsVariable = self.generateArgumentsVariable(args);
    if (argumentsVariable != null) {
      return [
        '(function () {\n',
          'var __combe_subject = ', functionCode, ';\n',
          argumentsVariable,
          'return __combe_subject.apply(null, __combe_arguments);\n',
        '})()'
      ]
    }
    else {
      return [
        functionCode, '(', args.map((a) -> a.code).separatedBy(', '), ')'
      ]
    }
  }
  
  generateMethodCall(subjectCode, name, args) {
    if (args == null) args = []
    
    var argumentsVariable = self.generateArgumentsVariable(args);
    if (argumentsVariable != null) {
      return [
        '(function () {\n',
          'var __combe_subject = ', subjectCode, ';\n',
          'var __combe_name = ', name.code, ';\n',
          argumentsVariable,
          'return __combe_subject[__combe_name].apply(__combe_subject, __combe_arguments);\n',
        '})()'
      ]
    }
    else {
      args = args.map((a) -> a.code).separatedBy(', ')
      if (name.is('Literal') &&
          String.isClassOf(name.value) &&
          name.value.isJavaScriptPropertyName()) {
        return [subjectCode, '.', name.value, '(', args, ')']
      }
      else {
        return [subjectCode, '[', name.code, '](', args, ')']
      }
    }
  }
  
  generateParameters(params) {
    if (params == null || params.length == 0) return {
      jsParams: null,
      restParams: null,
    }
    
    assert(params.count((p) -> p.is('SplatParameter')) <= 1)
    
    var jsParams = null
    var restParams = null
    if (params.any((p) -> p.is('SplatParameter'))) {
      if (params.length == 1) {
        restParams = [
          'var ', params[0].name, ' = Array.slice(arguments);\n'
        ]
      }
      else if (params.last.is('SplatParameter')) {
        jsParams = params.dropLast(1).map((p) -> p.name).separatedBy(', ')
        restParams = [
          'var ', params.last.name, ' = Array.slice(arguments, ', (params.length - 1).toString(), ');\n'
        ]
      }
      else {
        var splatIndex = params.indexOfPredicate((p) -> p.is('SplatParameter'))
        jsParams = params.take(splatIndex).map((p) -> p.name).separatedBy(', ')
        var remParams = params.drop(splatIndex + 1)
        restParams = [
          'var ', params[splatIndex].name, ' = Array.slice(arguments, ', splatIndex.toString(), 'arguments.length - ', remParams.length.toString(), ');\n'
        ]
        remParams.each(function (p, i) {
          restParams.push('var ', p.name, ' = arguments[', (splatIndex + 1 + i).toString(), '];\n')
        })
      }
    }
    else {
      jsParams = params.map((p) -> p.name).separatedBy(', ')
    }
    
    return {
      jsParams: jsParams,
      restParams: restParams
    }
  }
    
  
  gensymIndex: 0,
  
  gensym(name) {
    if (name == null) name = '__unnamed'
    
    return '__combe_gensym_' + name + self.gensymIndex++
  }
  
})
