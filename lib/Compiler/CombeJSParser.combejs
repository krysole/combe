//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

var JSParser = require('../JSParser').JSParser;
var Ast = require('../Runtime').Ast;
var CombeJSLexer = require('./CombeJSLexer');

/*
  CombeJS AST (Extending JSParser AST)

  SourceElement += ...
  RuleDeclaration: {name [String], argumentNames [*String]}, [Pattern]

  Expression += ...
  RuleExpression: {name [String?], argumentNames [*String]}, [Pattern]
  InclusiveRange: [Expression], [Expression]
  ExclusiveRange: [Expression], [Expression]
  RangeInfinity

  PropertyDeclaration += ...
  DescribePropertyDeclaration: {name [String]}, descriptorMap [ObjectLiteral]

  Pattern = ...
  EmptyPattern
  AnythingPattern
  ChoicePattern: [+Pattern]
  ConcatPattern: [+Pattern]
  BindPattern: {name [String]}, [Pattern]
  NotPattern: [Pattern]
  LookaheadPattern: [Pattern]
  TokenOperatorPattern: [Pattern]
  RepeatPattern: [Pattern]
  Repeat1Pattern: [Pattern]
  OptionalPattern: [Pattern]
  JSApplyPattern: pattern [Pattern], +args [+Expression]
  ApplyPattern: pattern [Pattern], +args [+Pattern]
  PredicateExpressionPattern: [Expression]
  PredicateBlockPattern: [+Statement]
  ActionExpressionPattern: [Expression]
  ActionBlockPattern: [+Statement]
  ImmediateExpressionPattern: [Expression]
  ImmediateBlockPattern: [+Statement]
  StringPattern: {value [String]}
  NumberPattern: {value [Number]}
  RangePattern: [InclusiveRange | ExclusiveRange]
  VariablePattern: {name [String]}
*/

var CombeJSParser = module.exports = Class.new(JSParser, {}, {
  
  DefaultLexer: CombeJSLexer,

  propertyAssignment: rule {
    | %JSParser.prototype.propertyAssignment
    | 'describe' propertyName:name ':' assignmentExpression:expr
      -> Ast('DescribePropertyDeclaration', {name: name}, expr)
  },

  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | ruleExpression
    | 'new' memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor(expr):expr)*
    -> expr
  },

  prefixExpression: rule {
    %JSParser.prototype.unaryExpression
  },

  rangeInfinity: rule {
    '*' -> Ast('RangeInfinity')
  },

  rangeOperator: rule (ast) {
    | '..' (rangeInfinity | prefixExpression):rhs
      -> Ast('InclusiveRange', {}, ast, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast('ExclusiveRange', {}, ast, rhs)
  },

  unaryExpression: rule {
    ( rangeInfinity:expr rangeOperator(expr):expr
    | prefixExpression:expr
    )
    (rangeOperator(expr):expr)*
    -> expr
  },

  expressionStatement: rule {
    ~('{'|'function'|'rule') expression:expr ';'
    -> Ast('ExpressionStatement', {}, expr)
  },

  sourceElement: rule {
    | %JSParser.prototype.sourceElement
    | ruleDeclaration
  },

  ruleDeclaration: rule {
    'rule' 'identifier':name ('(' delimited['identifier', ',']:args ')')?
      '{' optionalPattern:ptn '}'
    !(args ? args.map(function (elem) {return elem.value;}) : []):args
    -> Ast('RuleDeclaration', {name: name.value, argumentNames: args}, ptn)
  },

  ruleExpression: rule {
    'rule' 'identifier'?:name ('(' delimited['identifier', ',']:args ')')?
      '{' optionalPattern:ptn '}'
    !(args ? args.map(function (elem) {return elem.value;}) : []):args
    -> Ast('RuleExpression', {name: (name ? name.value : null), argumentNames: args}, ptn)
  },

  optionalPattern: rule {
    | choicePattern
    | '|'? -> Ast('EmptyPattern')
  },

  pattern: rule {
    choicePattern
  },

  choicePattern: rule {
    '|'? returnPattern:ptn
    ( ('|' returnPattern)+:ptns 
      !(ptn = Ast('ChoicePattern', {}, ptn).concat(ptns)) )?
    ( '|'
      !(ptn.push(Ast('EmptyPattern'))) )?
    -> ptn
  },

  returnPattern: rule {
    | concatPattern:ptn
      ( '->' leftHandSideExpression:expr
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionExpressionPattern', {}, expr))
      | '->' '{' statement*:stmts '}'
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionBlockPattern').concat(stmts))
      | -> ptn
      )
    | '->' leftHandSideExpression:expr -> Ast('ActionExpressionPattern', {}, expr)
    | '->' '{' statement*:stmts '}' -> Ast('ActionBlockPattern').concat(stmts)
  },

  concatPattern: rule {
    prefixOperatorPattern:ptn
    ( prefixOperatorPattern+:ptns -> Ast('ConcatPattern', {}, ptn).concat(ptns)
    | -> ptn
    )
  },

  prefixOperatorPattern: rule {
    | postfixOperatorPattern
    | '~' prefixOperatorPattern:ptn -> Ast('NotPattern', {}, ptn)
    | '&' prefixOperatorPattern:ptn -> Ast('LookaheadPattern', {}, ptn)
    | '#' prefixOperatorPattern:ptn -> Ast('TokenOperatorPattern', {}, ptn)
  },

  postfixOperatorPattern: rule {
    | applyPattern:ptn ( repeatOperatorPattern(ptn):ptn )*
      -> ptn
    | ':' ~whitespace 'identifier':name
      -> Ast('BindPattern', {name: name.value}, Ast('AnythingPattern'))
  },

  repeatOperatorPattern: rule (ptn) {
    ( '*' -> Ast('RepeatPattern', {}, ptn)
    | '+' -> Ast('Repeat1Pattern', {}, ptn)
    | '?' ~( ~whitespace ('('|'{') )
      -> Ast('OptionalPattern', {}, ptn)
    | ~whitespace ':' ~whitespace 'identifier':name
      -> Ast('BindPattern', {name: name.value}, ptn)
    )
  },

  applyPattern: rule {
    primaryPattern:ptn
    ( ~whitespace arguments:args
      !(ptn = Ast('JSApplyPattern', {}, ptn).concat(args))
    | ~whitespace patternArguments:args
      !(ptn = Ast('ApplyPattern', {}, ptn).concat(args))
    )*
    -> ptn
  },

  patternArguments: rule {
    '[' delimited[pattern, ',']:args ']' -> args
  },

  primaryPattern: rule {
    | predicatePattern
    | actionPattern
    | immediatePattern
    | literalPattern
    | variablePattern
    | '(' pattern:ptn ')' -> ptn
  },

  predicatePattern: rule {
    | '?' ~whitespace '(' expression:expr ')'
      -> Ast('PredicateExpressionPattern', {}, expr)
    | '?' ~whitespace '{' statement*:stmts '}'
      -> Ast('PredicateBlockPattern').concat(stmts)
  },

  actionPattern: rule {
    | '!' ~whitespace '(' expression:expr ')'
      -> Ast('ActionExpressionPattern', {}, expr)
    | '!' ~whitespace '{' statement*:stmts '}'
      -> Ast('ActionBlockPattern').concat(stmts)
  },

  immediatePattern: rule {
    | '%' leftHandSideExpression:expr
      -> Ast('ImmediateExpressionPattern', {}, expr)
    | '%' ~whitespace '{' statement*:stmts '}'
      -> Ast('ImmediateBlockPattern').concat(stmts)
  },

  literalPattern: rule {
    // Todo: Add range pattern support, which will likely require changing
    // the range operator to only support ranges between primary expressions?
    | ( 'null' | 'boolean' | 'regex' | 'undefined' ) error('Not a valid literal pattern')
    | 'number':n -> Ast('NumberPattern', {value: n.value})
    | 'string':s -> Ast('StringPattern', {value: s.value})
  },

  variablePattern: rule {
    'identifier':name -> Ast('VariablePattern', {name: name.value})
  },

  whitespace: rule {
    | &anything:token ?(!token.previousToken || token.previousToken.is('whitespace'))
    | eof
  },

});
