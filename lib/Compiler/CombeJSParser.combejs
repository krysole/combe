//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

var JSParser = require('../JSParser').JSParser;
var Ast = require('../Runtime').Ast;
var CombeJSLexer = require('./CombeJSLexer');

/*
  CombeJS AST (Extending JSParser AST)

  SourceElement += ...
  RuleDeclaration: {name [String], argumentNames [*String]}, [Pattern]

  Expression += ...
  RuleExpression: {name [String?], argumentNames [*String]}, [Pattern]
  InclusiveRange: [Expression], [Expression]
  ExclusiveRange: [Expression], [Expression]
  RangeInfinity

  PropertyDeclaration += ...
  DescribePropertyDeclaration: {name [String]}, descriptorMap [ObjectLiteral]

  Pattern = ...
  EmptyPattern
  AnythingPattern
  ChoicePattern: [+Pattern]
  ConcatPattern: [+Pattern]
  BindPattern: {name [String]}, [Pattern]
  NotPattern: [Pattern]
  LookaheadPattern: [Pattern]
  TokenOperatorPattern: [Pattern]
  RepeatPattern: [Pattern]
  Repeat1Pattern: [Pattern]
  OptionalPattern: [Pattern]
  JSApplyPattern: pattern [Pattern], +args [+Expression]
  ApplyPattern: pattern [Pattern], +args [+Pattern]
  PredicateExpressionPattern: [Expression]
  PredicateBlockPattern: [+Statement]
  ActionExpressionPattern: [Expression]
  ActionBlockPattern: [+Statement]
  ImmediateExpressionPattern: [Expression]
  ImmediateBlockPattern: [+Statement]
  StringPattern: {value [String]}
  NumberPattern: {value [Number]}
  RangePattern: [InclusiveRange | ExclusiveRange]
  VariablePattern: {name [String]}
*/

var CombeJSParser = module.exports = Class.new(JSParser, {}, {
  
  DefaultLexer: CombeJSLexer,
  
  emptyState: function () {
    return {
      position: 0,
      astTemplates: false
    };
  },
  
  copyState: function () {
    return {
      position: this.state.position,
      astTemplates: this.state.astTemplates
    };
  },
  
  primaryExpression: rule {
    | %JSParser.prototype.primaryExpression
    | interpolateExpression
    | interpolateIdentifier
  },
  
  interpolateExpression: rule {
    '%' interpolationBody:body
    -> Ast('InterpolateExpression', {}, body)
  },
  
  interpolateIdentifier: rule {
    '%' 'id' interpolationBody:body
    -> Ast('InterpolateIdentifier', {}, body)
  },
  
  arrayElement: rule {
    | %JSParser.prototype.arrayElement
    | '%' 'expand' interpolationBody:body
      -> Ast('ExpandInterpolateArrayElement', {}, body)
  },

  propertyAssignment: rule {
    | %JSParser.prototype.propertyAssignment
    | 'describe' propertyName:name ':' assignmentExpression:expr
      -> Ast('DescribePropertyDeclaration', {name: name}, expr)
    | '%' 'expand' interpolationBody:body
      -> Ast('ExpandInterpolatePropertyAssignment', {}, body)
  },

  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | ruleExpression
    | 'new' memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor(expr):expr)*
    -> expr
  },
  
  arguments: rule {
    '(' delimited[expandInterpolateArgument, ',']:exprs ')' -> exprs
  },
  
  expandInterpolateArgument: rule {
    | '%' 'expand' interpolationBody:body
      -> Ast('ExpandInterpolateArgument', {}, body)
    | assignmentExpression
  },

  prefixExpression: rule {
    %JSParser.prototype.unaryExpression
  },

  rangeInfinity: rule {
    '*' -> Ast('RangeInfinity')
  },

  rangeOperator: rule (ast) {
    | '..' (rangeInfinity | prefixExpression):rhs
      -> Ast('InclusiveRange', {}, ast, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast('ExclusiveRange', {}, ast, rhs)
  },

  unaryExpression: rule {
    ( rangeInfinity:expr rangeOperator(expr):expr
    | prefixExpression:expr
    )
    (rangeOperator(expr):expr)*
    -> expr
  },

  expression: rule (noIn) {
    delimited1[expandInterpolateExpression, ',']:exprs
    ( ?(exprs.length === 1 && exprs[0].is('ExpandInterpolateExpression'))
      -> Ast('ExpressionSequence').concat(exprs)
    | ?(exprs.length === 1)
      -> exprs[0]
    | -> Ast('ExpressionSequence').concat(exprs)
    )
  },
  
  expandInterpolateExpression: rule (noIn) {
    | '%' 'expand' interpolationBody:body
      -> Ast('ExpandInterpolateExpression', {}, body)
    | assignmentExpression(noIn)
  },
  
  statement: rule (noIn) {
    | (%JSParser.prototype.statement)(noIn)
    | interpolateStatements
  },
  
  interpolateStatements: rule {
    '%' 'statements' interpolationBody:body
    -> Ast('InterpolateStatements', {}, body)
  },
  
  // Todo: I can't add this until the identifiers/bindings are Ast nodes themselves.  
  // variableDeclarationList: rule (noIn) {
  //   delimited1[expandInterpolateVariableDeclaration(noIn), ',']:lst
  // },
  // 
  // expandInterpolateVariableDeclaration: rule (noIn) {
  //   | '%' 'expand' interpolationBody:body
  //     -> Ast('ExpandInterpolateVariableDeclaration', {}, body)
  //   | variableDeclaration(noIn)
  // },

  expressionStatement: rule {
    ~('{'|'function'|'rule') expression:expr ';'
    -> Ast('ExpressionStatement', {}, expr)
  },
  
  // Todo: I can't add this until the identifiers/bindings are Ast nodes themselves.
  // functionArguments: rule {
  //   '(' delimited[expandInterpolateFunctionArgument, ',']:args ')' -> args
  // },
  // 
  // expandInterpolateFunctionArgument: rule {
  //   | '%' 'expand' interpolationBody:body
  //     -> Ast('ExpandInterpolateFunctionArgument', {}, body)
  //   | 'identifier':name -> name.identifierName
  // },

  sourceElement: rule {
    | %JSParser.prototype.sourceElement
    | ruleDeclaration
  },
  
  // Todo: I need to update the identifier rule in JSParser to produce
  // an Ast itself. Respectively, only variables could really be done directly, 
  // since the ast would be different for the others? I'll need to unify the
  // Ast nodes for them to make it more consistant, or use multiple variations
  // of the identifier rule...
  // identifier: rule {
  //   | 'identifier'
  //   | '%' 'id' interpolationBody:body
  //     -> Ast('InterpolateIdentifier', {}, body)
  // },
  // 
  // identifierName: rule {
  //   | 'identifierName'
  //   | '%' 'id' interpolationBody:body
  //     -> Ast('InterpolateIdentifierName', {}, body)
  // },

  ruleDeclaration: rule {
    'rule' 'identifier':name ('(' delimited['identifier', ',']:args ')')?
      '{' optionalPattern:ptn '}'
    !(args ? args.map(function (elem) {return elem.value;}) : []):args
    -> Ast('RuleDeclaration', {name: name.value, argumentNames: args}, ptn)
  },

  ruleExpression: rule {
    'rule' 'identifier'?:name ('(' delimited['identifier', ',']:args ')')?
      '{' optionalPattern:ptn '}'
    !(args ? args.map(function (elem) {return elem.value;}) : []):args
    -> Ast('RuleExpression', {name: (name ? name.value : null), argumentNames: args}, ptn)
  },

  optionalPattern: rule {
    | choicePattern
    | '|'? -> Ast('EmptyPattern')
  },

  pattern: rule {
    choicePattern
  },

  choicePattern: rule {
    '|'? returnPattern:ptn
    ( ('|' returnPattern)+:ptns 
      !(ptn = Ast('ChoicePattern', {}, ptn).concat(ptns)) )?
    ( '|'
      !(ptn.push(Ast('EmptyPattern'))) )?
    -> ptn
  },

  returnPattern: rule {
    | concatPattern:ptn
      ( '->' leftHandSideExpression:expr
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionExpressionPattern', {}, expr))
      | '->' '{' statement*:stmts '}'
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionBlockPattern').concat(stmts))
      | -> ptn
      )
    | '->' leftHandSideExpression:expr -> Ast('ActionExpressionPattern', {}, expr)
    | '->' '{' statement*:stmts '}' -> Ast('ActionBlockPattern').concat(stmts)
  },

  concatPattern: rule {
    prefixOperatorPattern:ptn
    ( prefixOperatorPattern+:ptns -> Ast('ConcatPattern', {}, ptn).concat(ptns)
    | -> ptn
    )
  },

  prefixOperatorPattern: rule {
    | postfixOperatorPattern
    | '~' prefixOperatorPattern:ptn -> Ast('NotPattern', {}, ptn)
    | '&' prefixOperatorPattern:ptn -> Ast('LookaheadPattern', {}, ptn)
    | '#' prefixOperatorPattern:ptn -> Ast('TokenOperatorPattern', {}, ptn)
  },

  postfixOperatorPattern: rule {
    | applyPattern:ptn ( repeatOperatorPattern(ptn):ptn )*
      -> ptn
    | ':' ~whitespace 'identifier':name
      -> Ast('BindPattern', {name: name.value}, Ast('AnythingPattern'))
  },

  repeatOperatorPattern: rule (ptn) {
    ( '*' -> Ast('RepeatPattern', {}, ptn)
    | '+' -> Ast('Repeat1Pattern', {}, ptn)
    | '?' ~( ~whitespace ('('|'{') )
      -> Ast('OptionalPattern', {}, ptn)
    | ~whitespace ':' ~whitespace 'identifier':name
      -> Ast('BindPattern', {name: name.value}, ptn)
    )
  },

  applyPattern: rule {
    primaryPattern:ptn
    ( ~whitespace arguments:args
      !(ptn = Ast('JSApplyPattern', {}, ptn).concat(args))
    | ~whitespace patternArguments:args
      !(ptn = Ast('ApplyPattern', {}, ptn).concat(args))
    )*
    -> ptn
  },

  patternArguments: rule {
    '[' delimited[pattern, ',']:args ']' -> args
  },

  primaryPattern: rule {
    | predicatePattern
    | actionPattern
    | immediatePattern
    | literalPattern
    | variablePattern
    | '(' pattern:ptn ')' -> ptn
  },

  predicatePattern: rule {
    | '?' ~whitespace '(' expression:expr ')'
      -> Ast('PredicateExpressionPattern', {}, expr)
    | '?' ~whitespace '{' statement*:stmts '}'
      -> Ast('PredicateBlockPattern').concat(stmts)
  },

  actionPattern: rule {
    | '!' ~whitespace '(' expression:expr ')'
      -> Ast('ActionExpressionPattern', {}, expr)
    | '!' ~whitespace '{' statement*:stmts '}'
      -> Ast('ActionBlockPattern').concat(stmts)
  },

  immediatePattern: rule {
    | '%' leftHandSideExpression:expr
      -> Ast('ImmediateExpressionPattern', {}, expr)
    | '%' ~whitespace '{' statement*:stmts '}'
      -> Ast('ImmediateBlockPattern').concat(stmts)
  },

  literalPattern: rule {
    // Todo: Add range pattern support, which will likely require changing
    // the range operator to only support ranges between primary expressions?
    | ( 'null' | 'boolean' | 'regex' | 'undefined' ) error('Not a valid literal pattern')
    | 'number':n -> Ast('NumberPattern', {value: n.value})
    | 'string':s -> Ast('StringPattern', {value: s.value})
  },

  variablePattern: rule {
    'identifier':name -> Ast('VariablePattern', {name: name.value})
  },
  
  astTemplateExpression: rule {
    | '__ast' '(' withAstTemplates[expression]:expr ')'
      -> Ast('ExpressionAstTemplate', {}, expr)
    | '__ast' '{' wihtAstTemplates[functionBody]:stmts '}'
      -> Ast('StatementAstTemplate').concat(stmts)
  },
  
  withAstTemplates: rule (pattern) {
    !(this.state.astTemplates):oldval
    !(this.state.astTemplates = true)
    pattern:r
    !(this.state.astTemplates = oldval)
    -> r
  },
  
  interpolationBody: rule {
    | '(' withoutAstTemplates[expression]:expr ')'
      -> Ast('ExpressionInterpolationBody', {}, expr)
    | '{' withoutAstTemplates[functionBody]:stmts '}'
      -> Ast('StatementsInterpolationBody').concat(stmts)
    // Todo: I still need to add checks to make sure that these
    // aren't used when not in an __ast literal.
  },
  
  withoutAstTemplates: rule (pattern) {
    !(this.state.astTemplates):oldval
    !(this.state.astTemplates = false)
    pattern:r
    !(this.statement.astTemplates = oldval)
    -> r
  },

  whitespace: rule {
    | &anything:token ?(!token.previousToken || token.previousToken.is('whitespace'))
    | eof
  },

});
