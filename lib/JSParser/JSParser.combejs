//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

var TokenParser = require('../Runtime').TokenParser;
var Ast = require('../Runtime').Ast;
var JSLexer = require('./JSLexer');

/*
  JSParser Ast:

  Program *statements [*SourceElement]

  SourceElement = Statement | FunctionDeclaration

  FunctionDeclaration {name [String], argumentNames [*String]}, 
                      *statements [*SourceElement*]

  Statement = ...
  Block: *statements [*Statement]
  VariableDeclarationList: +variables [+VariableDeclaration]
  VariableDeclaration: {name [String]}, expression [Expression]
  If: condition [Expression], trueBranch [Statement], falseBranch [Statement]
  While: condition [Expression], body [Statement]
  DoWhile: condition [Expression], body [Statement]
  For: initialization [(VariableDeclaration | Expression)?], 
       condition [Expression?],
       increment [Expression?],
       body [Statement]
  ForIn: {declareVariable [String]}, 
         lvalue [LValue], 
         subject [Expression], 
         body [Statement]
  Continue: {label [String?]}
  Break: {label [String?]}
  Return: [Expression]
  With: subject [Expression], body [Statement]
  Switch: subject [Expression], *clauses [*SwitchClause]
  Label: {name [String]}, body [Statement]
  Throw: exception [Expression]
  Try: body [Block], catch [Catch?], finally [Block?]
  EmptyStatement
  Debugger
  ExpressionStatement: [Expression]

  SwitchClause = ...
  CaseClause: compareWith [Expression], *statements [*Statement]
  DefaultClause: *statements [*Statement]

  Catch: {name [String]}, [Block]

  LValue = VariableLookup | PropertyLookup

  Expression = ...
  This
  VariableLookup: {name [String]}
  ValueLiteral: {value [Object]}
  ArrayLiteral: [*Expression]
  ObjectLiteral: [*PropertyDeclaration]
  New: constructor [Expression], *arguments [*Expression]
  PropertyLookup: subject [Expression], name [Expression]
  DotPropertyLookup: {name [String]}, subject [Expression]
  Call: function [Expression], *arguments [*Expression]
  CallProperty: {name [String]}, function [Expression], *arguments [*Expression]
  PostfixIncrement: {sign [Integer]}, expression [Expression]
  Delete: [Expression]
  Void: [Expression]
  TypeOf: [Expression]
  UnaryOperator: {name [String]}, [Expression]
  Operator: {name [String]}, [Expression], [Expression]
  ConditionalExpression: condition [Expression],
                         trueBranch [Expression],
                         falseBranch [Expression]
  Assignment: lvalue [LValue], rvalue [Expression]
  OperatorAssignment: {operator [String]}, lvalue [LValue], rvalue [Expression]
  FunctionExpression: {name [String], argumentNames [*String]}, *statements [*SourceElement]
  ExpressionSequence: +exprs [+Expression]

  PropertyDeclaration = ...
  ValuePropertyDeclaration: {name [String]}, value [Expression]
  GetPropertyDeclaration: {name [String]}, *statements [*SourceElement]
  SetPropertyDeclaration: {name [String], argumentName [String]}, *statement [*SourceElement]
*/

var JSParser = module.exports = Class.new(TokenParser, {}, {

  DefaultLexer: JSLexer,

  // Useful entry points are 'expression', 'program' and possibly
  // 'statement' or 'sourceElement' (statements + function declarations)

  primaryExpression: rule {
    | 'this'                -> Ast('This')
    | identifier:name         -> Ast('VariableLookup', {name: name.identifierName})
    | valueLiteral
    | arrayLiteral
    | objectLiteral
    | '(' expression:e ')'  -> e
  },

  valueLiteral: rule {
    ( 'null'
    | 'boolean'
    | 'number'
    | 'string'
    | 'regex'
    ):token -> Ast('ValueLiteral', {value: token.value})
  },

  arrayLiteral: rule {
    '[' delimited[arrayElement, ',']:exprs ']'
    -> Ast('ArrayLiteral').concat(exprs)
  },

  arrayElement: rule {
    | assignmentExpression
    | -> Ast('Elision')
  },

  objectLiteral: rule {
    '{' delimited[propertyAssignment, ',']:pdefs ','? '}'
    -> Ast('ObjectLiteral').concat(pdefs)
  },

  propertyAssignment: rule {
    | propertyName:name ':' assignmentExpression:expr
      -> Ast('ValuePropertyDeclaration', {name: name}, expr)
    | 'get' propertyName:name '(' ')' '{' functionBody:body '}'
      -> Ast('GetPropertyDeclaration', {name: name}).concat(body)
    | 'set' propertyName:name '(' identifier:arg ')' '{' functionBody:body '}'
      -> Ast('SetPropertyDeclaration', {name: name, argumentName: arg.identifierName}).concat(body)
  },

  propertyName: rule {
    | identifierName:token -> token.identifierName
    | 'string' -> token.value
    | 'number' -> token.value
  },

  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | 'new' memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor(expr):expr)*
    -> expr
  },

  newExpression: rule {
    | memberExpression
    | 'new' newExpression:ctor
      -> Ast('New', {}, ctor)
  },

  propertyAccessor: rule (subject) {
    | '[' expression:expr ']'
      -> Ast('PropertyLookup', {}, subject, expr)
    | '.' identifierName:t
      -> Ast('DotPropertyLookup', {name: t.identifierName}, subject)
  },

  callExpression: rule {
    memberExpression:expr arguments:args
    ( ?(expr.is('DotPropertyLookup'))
      !(expr = Ast('CallProperty', {name: expr.name}, expr.children[0]).concat(args))
    | !(expr = Ast('Call', {}, expr).concat(args))
    )
    ( arguments:args
      !(expr = Ast('Call', {}, expr).concat(args))
    | propertyAccessor(expr):expr
    )*
    -> expr
  },

  arguments: rule {
    '(' delimited[assignmentExpression, ',']:exprs ')' -> exprs
  },

  leftHandSideExpression: rule {
    | callExpression
    | newExpression
  },

  postfixExpression: rule {
    leftHandSideExpression:expr
    ( ~newline '++'
      -> Ast('PostfixIncrement', {sign: +1}, expr)
    | ~newline '--'
      -> Ast('PostfixIncrement', {sign: -1}, expr)
    | -> expr
    )
  },

  unaryExpression: rule {
    | postfixExpression
    | 'delete'  unaryExpression:expr -> Ast('Delete', {}, expr)
    | 'void'    unaryExpression:expr -> Ast('Void', {}, expr)
    | 'typeof'  unaryExpression:expr -> Ast('TypeOf', {}, expr)
    | ('++'|'--'|'+'|'-'|'~'|'!'):op unaryExpression:expr
      -> Ast('UnaryOperator', {name: op.type}, expr)
  },

  multiplicativeExpression: rule {
    unaryExpression:expr
    ( ('*'|'/'|'%'):op unaryExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },

  additiveExpression: rule {
    multiplicativeExpression:expr
    ( ('+'|'-'):op multiplicativeExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },

  shiftExpression: rule {
    additiveExpression:expr
    ( ('<<'|'>>'|'>>>'):op additiveExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },

  inToken: rule (noIn) {
    ?(!noIn) 'in'
  },

  relationalExpression: rule (noIn) {
    shiftExpression:expr
    ( ('<'|'>'|'<='|'>='|'instanceof'|inToken(noIn)):op shiftExpression:rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },

  equalityExpression: rule (noIn) {
    relationalExpression(noIn):expr
    ( ('=='|'!='|'==='|'!=='):op relationalExpression(noIn):rhs
      !(expr = Ast('Operator', {name: op.type}, expr, rhs))
    )*
    -> expr
  },

  bitwiseAndExpression: rule (noIn) {
    equalityExpression(noIn):expr
    ( '&' equalityExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '&'}, expr, rhs))
    )*
    -> expr
  },

  bitwiseXorExpression: rule (noIn) {
    bitwiseAndExpression(noIn):expr
    ( '^' bitwiseAndExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '^'}, expr, rhs))
    )*
    -> expr
  },

  bitwiseOrExpression: rule (noIn) {
    bitwiseXorExpression(noIn):expr
    ( '|' bitwiseXorExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '|'}, expr, rhs))
    )*
    -> expr
  },

  logicalAndExpression: rule (noIn) {
    bitwiseOrExpression(noIn):expr
    ( '&&' bitwiseOrExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '&&'}, expr, rhs))
    )*
    -> expr
  },

  logicalOrExpression: rule (noIn) {
    logicalAndExpression(noIn):expr
    ( '||' logicalAndExpression(noIn):rhs
      !(expr = Ast('Operator', {name: '||'}, expr, rhs))
    )*
    -> expr
  },

  conditionalExpression: rule (noIn) {
    logicalOrExpression(noIn):cond
    ( '?' assignmentExpression(noIn):trueExpr ':' assignmentExpression(noIn):falseExpr
      -> Ast('ConditionalExpression', {}, cond, trueExpr, falseExpr)
    | -> cond
    )
  },

  assignmentExpression: rule (noIn) {
    | leftHandSideExpression:lhs 
      ( '=' assignmentExpression(noIn):rhs
        -> Ast('Assignment', {}, lhs, rhs)
      | 'assignmentOperator':op assignmentExpression(noIn):rhs
        -> Ast('OperatorAssignment', {operator: op.opname}, lhs, rhs)
      )
    | conditionalExpression
  },

  expression: rule (noIn) {
    delimited1[assignmentExpression(noIn), ',']:exprs
    ( ?(exprs.length === 1)
      -> exprs[0]
    | -> Ast('ExpressionSequence').concat(exprs)
    )
  },

  statement: rule (noIn) {
    | block
    | variableStatement
    | emptyStatement
    | expressionStatement
    | ifStatement
    | iterationStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | withStatement
    | labelledStatement
    | switchStatement
    | throwStatement
    | tryStatement
    | debuggerStatement
  },

  block: rule {
    '{' statement*:stmts '}'
    -> Ast('Block').concat(stmts)
  },

  variableStatement: rule {
    'var' variableDeclarationList:lst ';' -> lst
  },

  variableDeclarationList: rule (noIn) {
    delimited1[variableDeclaration(noIn), ',']:lst
    -> Ast('VariableDeclarationList').concat(lst)
  },

  variableDeclaration: rule (noIn) {
    identifier:name
    ( '=' assignmentExpression(noIn):expr
      -> Ast('VariableDeclaration', {name: name.identifierName}, expr)
    | -> Ast('VariableDeclaration', {name: name.identifierName})
    )
  },

  emptyStatement: rule {
    ';' -> Ast('EmptyStatement')
  },

  expressionStatement: rule {
    ~('{'|'function') expression:expr ';'
    -> Ast('ExpressionStatement', {}, expr)
  },

  ifStatement: rule {
    'if' '(' expression:cond ')' statement:trueBranch
    ( 'else' statement:falseBranch
      -> Ast('If', {}, cond, trueBranch, falseBranch)
    | -> Ast('If', {}, cond, trueBranch)
    )
  },

  iterationStatement: rule {
    | 'do' statement:stmt 'while' '(' expression:cond ')' ';'
      -> Ast('DoWhile', {}, cond, stmt)
    
    | 'while' '(' expression:cond ')' statement:stmt
      -> Ast('While', {}, cond, stmt)
    
    | 'for' '(' expression(true)?:initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> Ast('For', {}, initExpr, condExpr, incExpr, stmt)
    | 'for' '(' 'var' variableDeclarationList(true):initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> Ast('For', {}, initExpr, condExpr, incExpr, stmt)
  
    | 'for' '(' leftHandSideExpression:lvalue 'in' expression:subject ')' statement:stmt
      -> Ast('ForIn', {}, lvalue, subject, stmt)
    | 'for' '(' 'var' variableDeclaration(true):vardecl 'in' expression:subject ')' statement:stmt
      -> Ast('ForIn', {}, vardecl, subject, stmt)
  },

  continueStatement: rule {
    'continue' ~newline identifier?:name ';'
    -> Ast('Continue', {label: (name ? name.identifierName : null)})
  },

  breakStatement: rule {
    'break' ~newline identifier?:name ';'
    -> Ast('Break', {label: (name ? name.identifierName : null)})
  },

  returnStatement: rule {
    'return' ~newline 
    ( expression:expr ';'
      -> Ast('Return', {}, expr)
    | ';'
      -> Ast('Return')
    )
  },

  withStatement: rule {
    'with' '(' expression:subject ')' statement:stmt
    -> Ast('With', {}, subject, stmt)
  },

  switchStatement: rule {
    'switch' '(' expression:subject ')' '{'
    !(Ast('Switch')):ast caseClause(ast)* (defaultClause(ast) caseClause(ast)*)? '}'
    -> ast
  },

  caseClause: rule (ast) {
    'case' expression:cmp ':' statement*:stmts
    !(ast.push(Ast('CaseClause', {}, cmp).concat(stmts)))
  },

  defaultClause: rule (ast) {
    'default' ':' statement*:stmts
    !(ast.push(Ast('DefaultClause').concat(stmts)))
  },

  labelledStatement: rule {
    identifier:name ':' statement:stmt
    -> Ast('Label', {name: name.identifierName}, stmt)
  },

  throwStatement: rule {
    'throw' ~newline expression:expr ';'
    -> Ast('Throw', {}, expr)
  },

  tryStatement: rule {
    | 'try' block:blk catchClause:c
      -> Ast('Try', {}, blk, c)
    | 'try' block:blk finallyClause:f
      -> Ast('Try', {}, blk, null, f)
    | 'try' block:blk catchClause:c finallyClause:f
      -> Ast('Try', {}, blk, c, f)
  },

  catchClause: rule {
    'catch' '(' identifier:name ')' block:blk
    -> Ast('Catch', {name: name.identifierName}, blk)
  },

  finallyClause: rule {
    'finally' block:blk
    -> blk
  },

  debuggerStatement: rule {
    'debugger' ';'
    -> Ast('Debugger')
  },

  functionDeclaration: rule {
    'function' identifier:name functionArguments:args
      '{' functionBody:stmts '}'
    -> Ast('FunctionDeclaration', {name: name.identifierName, argumentNames: args}).concat(stmts)
  },

  functionExpression: rule {
    'function' identifier?:name functionArguments:args
      '{' functionBody:stmts '}'
    !(name ? name.identifierName : null):name
    -> Ast('FunctionExpression', {name: name, argumentNames: args}).concat(stmts)
  },
  
  functionArguments: rule {
    '(' delimited[identifier:name -> name.identifierName, ',']:args ')' -> args
  },

  functionBody: rule {
    sourceElement*
  },

  program: rule {
    sourceElement*:stmts eof
    -> Ast('Program').concat(stmts)
  },

  sourceElement: rule {
    | statement
    | functionDeclaration
  },

  newline: rule {
    | peekNext:token ?(token.precededByNewline)
    | eof
  },
  
  identifier: rule {
    'identifier'
  },
  
  identifierName: rule {
    'identifierName'
  },

  getNextToken: function (tag) {
    var token;
    if (tag === '/' || tag === '/=') {
      token = this.nextReplacing(['unknown', 'regex'], 'division');
    }
    else if (tag === 'regex') {
      token = this.nextReplacing(['unknown', 'division'], 'regex');
    }
    else {
      token = this.next();
    }
  
    if (token.is(tag)) {
      return token;
    }
    else {
      this.fail();
    }
  },

});
