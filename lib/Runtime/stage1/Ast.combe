//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2013 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

global.Ast = module.exports = Object.subclass('Ast', {
  
  initialize {
    Object.classPrototype.initialize.call(self)
    
    self.initTypeConstructors()
  }
  
  initTypeConstructors(types) {
    if (types == null) types = self.types
    
    if (types == null) return
    
    Object.getOwnPropertyNames(types).each(function (type) {
      self.(type) = method (*attributes) {
        return self.new(type, types.(type), attributes)
      }
    })
  }
  
}, {
  
  initialize(type, attributeNames, attributes) {
    self.parent = null
    self.type = type
    self.attributeNames = attributeNames
    if (attributes != null) {
      assert(attributeNames.length == attributes.length)
      for (var i = 0; i < attributeNames.length; i++) {
        self.(attributeNames[i]) = attributes[i]
      }
    }
    
    self.children.each(child -> child.parent = self)
  }
  
  copy {
    return Ast.new(self.type, self.attributeNames, self.attributes)
  }
  
  deepCopy {
    return Ast.new(self.type, self.attributeNames.deepCopy(), self.attributes.deepCopy())
  }
  
  fix {
    self.fixParent(null)
  }
  
  fixParent(parent) {
    if (parent == null) parent = null
    
    self.parent = parent
    
    self.children.each(child -> child.fixParent(self))
  }
  
  is(*types) -> self.isAny(types)
  
  isAny(types) -> types.any(type -> self.type == type)
  
  get attributes -> self.attributeNames.map(attributeName -> self.(attributeName))
  
  get children {
    var array = []
    self.attributeNames.each(function (name) {
      self.pushChildrenIntoArray(self.(name), array)
    })
    return array
  }
  
  pushChildrenIntoArray(what, array) {
    if (what == null) {
      // Do nothing
    }
    else if (Ast.isClassOf(what)) {
      array.push(what)
    }
    else if (Array.isClassOf(what)) {
      what.each(function (element) {
        self.pushChildrenIntoArray(element, array)
      })
    }
    else if (Object.getPrototypeOf(what) == Object.prototype) {
      Object.getOwnPropertyNames(what).each(function (name) {
        self.pushChildrenIntoArray(what.(name), array)
      })
    }
    else {
      // Do nothing
    }
  }
  
  toString {
    return ('<' + self.class.name + ' ' + self.type + '>')
  }
  
})
