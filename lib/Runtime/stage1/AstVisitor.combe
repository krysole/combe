//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2013 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

var AstVisitor = module.exports = Object.subclass('AstVisitor', {
  
  visit(*args) {
    return self.new(*args).visitRoot()
  }
  
}, {
  
  order: null // 'pre', 'post' or {'in', 'none', 'no', null}
  recurseOverUnspecified: false
  
  visitUnspecified(node) {
    if (self.recurseOverUnspecified) {
      self.visitChildren(node)
    }
    else {
      throw Error.new('AstVisitor cannot handle unspecified ast node type: ' + node.type)
    }
  }
  
  
  initialize(rootNode) {
    self.rootNode = rootNode
    self.path = []
    self.dynamicVariables = []
  }
  
  visitRoot(*rest) {
    self.rootNode.fix() // Ensure parent links, etc., are correct.
    return self.visit(self.rootNode, *rest)
  }
  
  
  push(name, value) {
    if (self.dynamicVariables.(name) == null) {
      self.dynamicVariables.(name) = []
    }
    return self.dynamicVariables.(name).push(value)
  }
  
  pop(name) {
    return self.dynamicVariables.(name).pop(name)
  }
  
  set(name, value) {
    return self.dynamicVariables.(name).top = value
  }
  
  get(name) {
    return self.dynamicVariables.(name).top
  }
  
  
  pushNode(node) {
    return self.path.push(node)
  }
  
  popNode {
    return self.path.pop()
  }
  
  
  visitChildren(node, *rest) {
    return self.visitAll(node.children, *rest)
  }
  
  visitAll(nodes, *rest) {
    return nodes.map(node -> self.visit(node, *rest))
  }
  
  visit(node) {
    var result
    self.pushNode(node)
    if (self.order == null || ['in', 'none', 'no'].include(self.order)) {
      result = self.handle(node)
    }
    else if (self.order == 'pre') {
      result = self.handle(node)
      node.children.each(childNode -> self.visit(childNode))
    }
    else if (self.order == 'post') {
      node.children.each(childNode -> self.visit(childNode))
      result = self.handle(node)
    }
    else assert(false)
    self.popNode()
    return result
  }
  
  handle(node) {
    if (self.('handle' + node.type) != null) {
      return self.('handle' + node.type)(node)
    }
    else {
      return self.visitUnspecified(node)
    }
  }
  
})
