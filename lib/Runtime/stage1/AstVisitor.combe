//
// Combe - Improved JavaScript with Pattern Matching
//
// Copyright 2013 Lorenz Pretterhofer <krysole@alexicalmistake.com>
//
// Permission to use, copy, modify, and distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

global.AstVisitor = module.exports = Object.subclass('AstVisitor', {
  
  visit(*args) {
    return self.new(*args).visitRoot()
  }
  
}, {
  
  trace: false
  
  order: null // 'pre', 'post' or {'in', 'none', 'no', null}
  
  visitUnspecified(node) -> throw Error.new('AstVisitor cannot handle unspecified ast node type: ' + node.type)
  
  
  initialize(rootNode) {
    self.rootNode = rootNode
    self.path = []
    self.dynamicVariables = {}
    self.gensymid = 0
    
    if (self.trace) {
      self.push('traceIndentation', 0)
    }
  }
  
  gensym(basename) {
    return basename + self.gensymid++
  }
  
  visitRoot(*rest) {
    self.rootNode.fix() // Ensure parent links, etc., are correct.
    
    if (self.trace) {
      console.log('Tracing AstVisitor ' + self.class.name)
    }
    
    return self.visit(self.rootNode, *rest)
  }
  
  
  push(name, value) {
    if (self.dynamicVariables.(name) == null) {
      self.dynamicVariables.(name) = []
    }
    return self.dynamicVariables.(name).push(value)
  }
  
  pop(name) {
    return self.dynamicVariables.(name).pop(name)
  }
  
  set(name, value) {
    return self.dynamicVariables.(name).top = value
  }
  
  get(name) {
    return self.dynamicVariables.(name).top
  }
  
  
  pushNode(node) {
    return self.path.push(node)
  }
  
  popNode {
    return self.path.pop()
  }
  
  
  visitChildren(node, *rest) {
    return self.visitAll(node.children, *rest)
  }
  
  visitAll(nodes, *rest) {
    return nodes.map(node -> self.visit(node, *rest))
  }
  
  visit(node) {
    var result
    self.pushNode(node)
    
    if (self.trace) {
      console.log('  '.repeat(self.get('traceIndentation')) + node.type)
      self.push('traceIndentation', self.get('traceIndentation') + 1)
    }
    
    if (self.order == null || ['in', 'none', 'no'].include(self.order)) {
      result = self.handle(node)
    }
    else if (self.order == 'pre') {
      result = self.handle(node)
      self.visitChildren(node)
    }
    else if (self.order == 'post') {
      self.visitChildren(node)
      result = self.handle(node)
    }
    else assert(false)
    
    if (self.trace) {
      self.pop('traceIndentation')
    }
    
    self.popNode()
    return result
  }
  
  handle(node) {
    if (self.('visit' + node.type) != null) {
      return self.('visit' + node.type)(node)
    }
    else {
      return self.visitUnspecified(node)
    }
  }
  
})
