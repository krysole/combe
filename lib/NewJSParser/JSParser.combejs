//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

// Todo: Remove dependency or update/improve TokenParser...
//  (Perhaps make JSParser scannerless?)
var TokenParser = require('../Runtime').TokenParser;
var JSLexer = require('./JSLexer');
var JSAst = require('./JSAst');

var JSParser = module.exports = Class.new(TokenParser, {}, {

  DefaultLexer: JSLexer,

  // Useful entry points are 'expression', 'program' and possibly
  // 'statement' or 'sourceElement' (statements + function declarations)

  primaryExpression: rule {
    | 'this' -> JSAst.This()
    | identifier:name -> JSAst.Variable(name.identifierName)
    | valueLiteral
    | arrayLiteral
    | objectLiteral
    | '(' expression:e ')'  -> e
  },

  valueLiteral: rule {
    ( 'null'
    | 'boolean'
    | 'number'
    | 'string'
    | 'regex'
    ):token -> JSAst.Literal(token.value)
  },

  arrayLiteral: rule {
    '[' delimited[arrayElement, ',']:exprs ']'
    -> JSAst.Array(exprs)
  },

  arrayElement: rule {
    | assignmentExpression
    | -> JSAst.Elision()
  },

  objectLiteral: rule {
    '{' delimited[propertyAssignment, ',']:pdefs ','? '}'
    -> JSAst.Object(pdefs)
  },

  propertyAssignment: rule {
    | propertyName:name ':' assignmentExpression:expr
      -> JSAst.ValueProperty(name, expr)
    | 'get' propertyName:name '(' ')' '{' functionBody:body '}'
      -> JSAst.GetProperty(name, body)
    | 'set' propertyName:name '(' identifier:arg ')' '{' functionBody:body '}'
      -> JSAst.SetProperty(name, arg.identifierName, body)
  },

  propertyName: rule {
    | identifierName:token -> token.identifierName
    | 'string' -> token.value
    | 'number' -> token.value
  },

  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | 'new' memberExpression:ctor arguments:args
      -> JSAst.New(ctor, args)
    ):expr
    (propertyAccessor(expr):expr)*
    -> expr
  },

  newExpression: rule {
    | memberExpression
    | 'new' newExpression:ctor
      -> JSAst.New(ctor, [])
  },

  propertyAccessor: rule (subject) {
    | '[' expression:expr ']'
      -> JSAst.At(subject, expr)
    | '.' identifierName:t
      -> JSAst.Dot(subject, t.identifierName)
  },

  callExpression: rule {
    memberExpression:expr arguments:args
    ( ?(expr.is('Dot')
      !(expr = JSAst.CallMethod(expr.receiver, expr.name, arguments))
    | !(expr = JSAst.Call(expr, args))
    )
    ( arguments:args
      !(expr = JSAst.Call(expr, args))
    | propertyAccessor(expr):expr
    )*
    -> expr
  },

  arguments: rule {
    '(' delimited[assignmentExpression, ',']:exprs ')' -> exprs
  },

  leftHandSideExpression: rule {
    | callExpression
    | newExpression
  },

  postfixExpression: rule {
    leftHandSideExpression:expr
    ( ~newline '++'
      -> JSAst.Postfix('++', expr)
    | ~newline '--'
      -> JSAst.Postfix('--', expr)
    | -> expr
    )
  },

  unaryExpression: rule {
    | postfixExpression
    | 'delete'  unaryExpression:expr -> JSAst.Delete(expr)
    | 'void'    unaryExpression:expr -> JSAst.Void(expr)
    | 'typeof'  unaryExpression:expr -> JSAst.Typeof(expr)
    | ('++'|'--'|'+'|'-'|'~'|'!'):op unaryExpression:expr
      -> JSAst.Prefix(op.type, expr)
  },

  multiplicativeExpression: rule {
    unaryExpression:expr
    ( ('*'|'/'|'%'):op unaryExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  additiveExpression: rule {
    multiplicativeExpression:expr
    ( ('+'|'-'):op multiplicativeExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  shiftExpression: rule {
    additiveExpression:expr
    ( ('<<'|'>>'|'>>>'):op additiveExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  inToken: rule (noIn) {
    ?(!noIn) 'in'
  },

  relationalExpression: rule (noIn) {
    shiftExpression:expr
    ( ('<'|'>'|'<='|'>='|'instanceof'|inToken(noIn)):op shiftExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  equalityExpression: rule (noIn) {
    relationalExpression(noIn):expr
    ( ('=='|'!='|'==='|'!=='):op relationalExpression(noIn):rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  bitwiseAndExpression: rule (noIn) {
    equalityExpression(noIn):expr
    ( '&' equalityExpression(noIn):rhs
      !(expr = JSAst.Operator('&', expr, rhs))
    )*
    -> expr
  },

  bitwiseXorExpression: rule (noIn) {
    bitwiseAndExpression(noIn):expr
    ( '^' bitwiseAndExpression(noIn):rhs
      !(expr = JSAst.Operator('^', expr, rhs))
    )*
    -> expr
  },

  bitwiseOrExpression: rule (noIn) {
    bitwiseXorExpression(noIn):expr
    ( '|' bitwiseXorExpression(noIn):rhs
      !(expr = JSAst.Operator('|', expr, rhs))
    )*
    -> expr
  },

  logicalAndExpression: rule (noIn) {
    bitwiseOrExpression(noIn):expr
    ( '&&' bitwiseOrExpression(noIn):rhs
      !(expr = JSAst.Operator('&&', expr, rhs))
    )*
    -> expr
  },

  logicalOrExpression: rule (noIn) {
    logicalAndExpression(noIn):expr
    ( '||' logicalAndExpression(noIn):rhs
      !(expr = JSAst.Operator('||', expr, rhs))
    )*
    -> expr
  },

  conditionalExpression: rule (noIn) {
    logicalOrExpression(noIn):cond
    ( '?' assignmentExpression(noIn):trueExpr ':' assignmentExpression(noIn):falseExpr
      -> JSAst.Ternary(cond, trueExpr, falseExpr)
    | -> cond
    )
  },

  assignmentExpression: rule (noIn) {
    | leftHandSideExpression:lhs 
      ( '=' assignmentExpression(noIn):rhs
        -> JSAst.Assignment(lhs, rhs)
      | 'assignmentOperator':op assignmentExpression(noIn):rhs
        -> JSAst.OperatorAssignment(op.opname, lhs, rhs)
      )
    | conditionalExpression
  },

  expression: rule (noIn) {
    delimited1[assignmentExpression(noIn), ',']:exprs
    ( ?(exprs.length === 1)
      -> exprs[0]
    | -> JSAst.Sequence(exprs)
    )
  },

  statement: rule (noIn) {
    | block
    | variableStatement
    | emptyStatement
    | expressionStatement
    | ifStatement
    | iterationStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | withStatement
    | labelledStatement
    | switchStatement
    | throwStatement
    | tryStatement
    | debuggerStatement
  },

  block: rule {
    '{' statement*:stmts '}'
    -> JSAst.Block(stmts)
  },

  variableStatement: rule {
    'var' variableDeclarationList:lst ';' -> lst
  },

  variableDeclarationList: rule (noIn) {
    delimited1[variableDeclaration(noIn), ',']:lst
    -> JSAst.Declare(lst)
  },

  variableDeclaration: rule (noIn) {
    identifier:name
    ( '=' assignmentExpression(noIn):expr
      -> JSAst.Assignment(JSAst.Variable(name.identifierName), expr)
    | -> JSAst.Variable(name.identifierName)
    )
  },

  emptyStatement: rule {
    ';' -> JSAst.Empty()
  },

  expressionStatement: rule {
    ~('{'|'function') expression:expr ';'
    -> expr
  },

  ifStatement: rule {
    'if' '(' expression:cond ')' statement:trueBranch
    ( 'else' statement:falseBranch
      -> JSAst.If(cond, trueBranch, falseBranch)
    | -> JSAst.If(cond, trueBranch, null)
    )
  },

  iterationStatement: rule {
    | 'do' statement:stmt 'while' '(' expression:cond ')' ';'
      -> JSAst.DoWhile(stmt, cond)
    
    | 'while' '(' expression:cond ')' statement:stmt
      -> JSAst.While(cond, stmt)
    
    | 'for' '(' expression(true)?:initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> JSAst.For(initExpr, condExpr, incExpr, stmt)
    | 'for' '(' 'var' variableDeclarationList(true):initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> JSAst.For(initExpr, condExpr, incExpr, stmt)
  
    | 'for' '(' leftHandSideExpression:lvalue 'in' expression:subject ')' statement:stmt
      -> JSAst.ForIn(lvalue, subject, stmt)
    | 'for' '(' 'var' variableDeclaration(true):vardecl 'in' expression:subject ')' statement:stmt
      -> JSAst.ForIn(vardecl, subject, stmt)
  },

  continueStatement: rule {
    'continue' ~newline identifier?:name ';'
    -> JSAst.Continue(name ? name.identifierName : null)
  },

  breakStatement: rule {
    'break' ~newline identifier?:name ';'
    -> JSAst.Break(name ? name.identifierName : null)
  },

  returnStatement: rule {
    'return' ~newline 
    ( expression:expr ';'
      -> JSAst.Return(expr)
    | ';'
      -> JSAst.Return(null)
    )
  },

  withStatement: rule {
    'with' '(' expression:subject ')' statement:stmt
    -> JSAst.With(subject, stmt)
  },

  switchStatement: rule {
    'switch' '(' expression:subject ')' '{' !([]):cs
    caseClause(cs)* ( defaultClause(cs) caseClause(cs)* )?
    '}'
    -> JSAst.Switch(subject, cs)
  },

  caseClause: rule (list) {
    'case' expression:subject ':' statement*:stmts
    !(list.push(JSAst.CaseClause(subject, stmts)))
  },

  defaultClause: rule (ast) {
    'default' ':' statement*:stmts
    !(ast.push(JSAst.DefaultClause(stmts)))
  },

  labelledStatement: rule {
    identifier:name ':' statement:stmt
    -> JSAst.Label(name.identifierName, stmt)
  },

  throwStatement: rule {
    'throw' ~newline expression:expr ';'
    -> JSAst.Throw(expr)
  },

  tryStatement: rule {
    'try' block:blk catchClause?:c finallyClause?:f
    -> JSAst.Try(blk, c, f)
  },

  catchClause: rule {
    'catch' '(' identifier:name ')' block:blk
    -> JSAst.Catch(name.identifierName, blk)
  },

  finallyClause: rule {
    'finally' block:blk
    -> JSAst.Finally(blk)
  },

  debuggerStatement: rule {
    'debugger' ';'
    -> JSAst.Debugger()
  },

  functionDeclaration: rule {
    'function' identifier:name functionArguments:args
      '{' functionBody:stmts '}'
    -> JSAst.FunctionDeclaration(name.identifierName, args, stmts)
  },

  functionExpression: rule {
    'function' identifier?:name functionArguments:args
      '{' functionBody:stmts '}'
    !(name ? name.identifierName : null):name
    -> JSAst.Function(name, args, stmts)
  },
  
  functionArguments: rule {
    '(' delimited[identifier:name -> name.identifierName, ',']:args ')' -> args
  },

  functionBody: rule {
    sourceElement*
  },

  program: rule {
    sourceElement*:stmts eof
    -> JSAst.Program(stmts)
  },

  sourceElement: rule {
    | statement
    | functionDeclaration
  },

  newline: rule {
    | &anything:token ?(token.precededByNewline)
    | eof
  },
  
  identifier: rule {
    'identifier'
  },
  
  identifierName: rule {
    'identifierName'
  },

  getNextToken: function (tag) {
    var token;
    if (tag === '/' || tag === '/=') {
      token = this._readReplacing(['unknown', 'regex'], 'division');
    }
    else if (tag === 'regex') {
      token = this._readReplacing(['unknown', 'division'], 'regex');
    }
    else {
      token = this._read();
    }
  
    if (token.is(tag)) {
      return token;
    }
    else {
      this.fail();
    }
  },

});
