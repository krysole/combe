//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

var TokenParser = require('./TokenParser');
var JSLexer = require('./JSLexer');
var JSAst = require('./JSAst');

var JSParser = module.exports = Class.new(TokenParser, {
  
  parseProgram: function (string) {
    return this.parse(string, 'program')
  },
  
  parseExpression: function (string) {
    return this.parse(string, 'expression');
  },
  
  parseStatement: function (string) {
    return this.parse(string, 'statement');
  },
  
  parseSourceElement: function (string) {
    return this.parse(string, 'sourceElement');
  },
  
  parse: function (string, rule /* ...args */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var parser = this.new(string);
    var result = parser.match.apply(parser, args);
    if (!result) {
      if (parser.tokens.last) {
        console.log('  *JSParser Failed: Last token seen was ' + parser.tokens.last);
      }
      else {
        console.log('  *JSParser Failed: No tokens parsed');
      }
    }
    return result;
  },
  
}, {

  // Useful entry points are 'expression', 'program' and possibly
  // 'statement' or 'sourceElement' (statements + function declarations)

  primaryExpression: rule {
    | valueLiteral
    | 'this' -> JSAst.This()
    | identifier:name -> JSAst.Variable(name)
    | arrayLiteral
    | objectLiteral
    | '(' expression:e ')'  -> e
  },

  valueLiteral: rule {
    ( 'null' -> null
    | 'true' -> true
    | 'false' -> false
    | 'number':n -> n.value
    | 'string':s -> s.value
    | 'regex':r -> r.value
    ):v -> JSAst.Literal(v)
  },

  arrayLiteral: rule {
    '[' delimited[arrayElement, ',']:exprs ']'
    -> JSAst.Array(exprs)
  },

  arrayElement: rule {
    | assignmentExpression
    | -> JSAst.Elision()
  },

  objectLiteral: rule {
    '{' delimited[propertyAssignment, ',']:pdefs ','? '}'
    -> JSAst.Object(pdefs)
  },

  propertyAssignment: rule {
    | propertyName:name ':' assignmentExpression:expr
      -> JSAst.ValueProperty(name, expr)
    | 'get' propertyName:name '(' ')' '{' functionBody:body '}'
      -> JSAst.GetProperty(name, body)
    | 'set' propertyName:name '(' identifier:argname ')' '{' functionBody:body '}'
      -> JSAst.SetProperty(name, argname, body)
  },

  propertyName: rule {
    | identifierName
    | 'string' -> token.value
    | 'number' -> token.value
  },

  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | 'new' memberExpression:ctor arguments:args
      -> JSAst.New(ctor, args)
    ):expr
    (propertyAccessor(expr):expr)*
    -> expr
  },

  newExpression: rule {
    | memberExpression
    | 'new' newExpression:ctor
      -> JSAst.New(ctor, [])
  },

  propertyAccessor: rule (subject) {
    | '[' expression:expr ']'
      -> JSAst.At(subject, expr)
    | '.' identifierName:name
      -> JSAst.Dot(subject, name)
  },

  callExpression: rule {
    memberExpression:expr arguments:args
    ( ?(expr.is('Dot')
      !(expr = JSAst.CallMethod(expr.receiver, expr.name, arguments))
    | !(expr = JSAst.Call(expr, args))
    )
    ( arguments:args
      !(expr = JSAst.Call(expr, args))
    | propertyAccessor(expr):expr
    )*
    -> expr
  },

  arguments: rule {
    '(' delimited[assignmentExpression, ',']:exprs ')' -> exprs
  },

  leftHandSideExpression: rule {
    | callExpression
    | newExpression
  },

  postfixExpression: rule {
    leftHandSideExpression:expr
    ( ~newline '++'
      -> JSAst.Postfix('++', expr)
    | ~newline '--'
      -> JSAst.Postfix('--', expr)
    | -> expr
    )
  },

  unaryExpression: rule {
    | postfixExpression
    | 'delete'  unaryExpression:expr -> JSAst.Delete(expr)
    | 'void'    unaryExpression:expr -> JSAst.Void(expr)
    | 'typeof'  unaryExpression:expr -> JSAst.Typeof(expr)
    | ('++'|'--'|'+'|'-'|'~'|'!'):op unaryExpression:expr
      -> JSAst.Prefix(op.type, expr)
  },

  multiplicativeExpression: rule {
    unaryExpression:expr
    ( ('*'|'/'|'%'):op unaryExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  additiveExpression: rule {
    multiplicativeExpression:expr
    ( ('+'|'-'):op multiplicativeExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  shiftExpression: rule {
    additiveExpression:expr
    ( ('<<'|'>>'|'>>>'):op additiveExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  inToken: rule (noIn) {
    ?(!noIn) 'in'
  },

  relationalExpression: rule (noIn) {
    shiftExpression:expr
    ( ('<'|'>'|'<='|'>='|'instanceof'|inToken(noIn)):op shiftExpression:rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  equalityExpression: rule (noIn) {
    relationalExpression(noIn):expr
    ( ('=='|'!='|'==='|'!=='):op relationalExpression(noIn):rhs
      !(expr = JSAst.Operator(op.type, expr, rhs))
    )*
    -> expr
  },

  bitwiseAndExpression: rule (noIn) {
    equalityExpression(noIn):expr
    ( '&' equalityExpression(noIn):rhs
      !(expr = JSAst.Operator('&', expr, rhs))
    )*
    -> expr
  },

  bitwiseXorExpression: rule (noIn) {
    bitwiseAndExpression(noIn):expr
    ( '^' bitwiseAndExpression(noIn):rhs
      !(expr = JSAst.Operator('^', expr, rhs))
    )*
    -> expr
  },

  bitwiseOrExpression: rule (noIn) {
    bitwiseXorExpression(noIn):expr
    ( '|' bitwiseXorExpression(noIn):rhs
      !(expr = JSAst.Operator('|', expr, rhs))
    )*
    -> expr
  },

  logicalAndExpression: rule (noIn) {
    bitwiseOrExpression(noIn):expr
    ( '&&' bitwiseOrExpression(noIn):rhs
      !(expr = JSAst.Operator('&&', expr, rhs))
    )*
    -> expr
  },

  logicalOrExpression: rule (noIn) {
    logicalAndExpression(noIn):expr
    ( '||' logicalAndExpression(noIn):rhs
      !(expr = JSAst.Operator('||', expr, rhs))
    )*
    -> expr
  },

  conditionalExpression: rule (noIn) {
    logicalOrExpression(noIn):cond
    ( '?' assignmentExpression(noIn):trueExpr ':' assignmentExpression(noIn):falseExpr
      -> JSAst.Ternary(cond, trueExpr, falseExpr)
    | -> cond
    )
  },

  assignmentExpression: rule (noIn) {
    | leftHandSideExpression:lhs 
      ( '=' assignmentExpression(noIn):rhs
        -> JSAst.Assignment(lhs, rhs)
      | operatorAssignmentToken:op assignmentExpression(noIn):rhs
        -> JSAst.OperatorAssignment(op, lhs, rhs)
      )
    | conditionalExpression
  },
  
  operatorAssignmentToken: rule {
    next:t ?(t.operatorAssignment) -> t.operator
  },

  expression: rule {
    expressionNoInFlag
  },
  
  expressionNoInFlag: rule (noIn) {
    delimited1[assignmentExpression(noIn), ',']:exprs
    ( ?(exprs.length === 1)
      -> exprs[0]
    | -> JSAst.Sequence(exprs)
    )
  },

  statement: rule {
    | block
    | variableStatement
    | emptyStatement
    | expressionStatement
    | ifStatement
    | doWhileStatement
    | whileStatement
    | forStatement
    | forInStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | withStatement
    | labelledStatement
    | switchStatement
    | throwStatement
    | tryStatement
    | debuggerStatement
  },

  block: rule {
    '{' statement*:stmts '}'
    -> JSAst.Block(stmts)
  },

  variableStatement: rule {
    'var' variableDeclarationList:lst ';' -> lst
  },

  variableDeclarationList: rule (noIn) {
    delimited1[variableDeclaration(noIn), ',']:lst
    -> JSAst.Declare(lst)
  },

  variableDeclaration: rule (noIn) {
    identifier:name
    ( '=' assignmentExpression(noIn):expr
      -> JSAst.Assignment(JSAst.Variable(name), expr)
    | -> JSAst.Variable(name)
    )
  },

  emptyStatement: rule {
    ';' -> JSAst.Empty()
  },

  expressionStatement: rule {
    ~('{'|'function') expression:expr ';'
    -> JSAst.ExpressionStatement(expr)
  },

  ifStatement: rule {
    'if' '(' expression:cond ')' statement:trueBranch
    ( 'else' statement:falseBranch
      -> JSAst.If(cond, trueBranch, falseBranch)
    | -> JSAst.If(cond, trueBranch, null)
    )
  },

  doWhileStatement: rule {
    'do' statement:stmt 'while' '(' expression:cond ')' ';'
    -> JSAst.DoWhile(stmt, cond)
  },
  
  whileStatement: rule {
    'while' '(' expression:cond ')' statement:stmt
    -> JSAst.While(cond, stmt)
  },
  
  forStatement: rule {
    | 'for' '(' expressionNoInFlag(true)?:initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> JSAst.For(initExpr, condExpr, incExpr, stmt)
    | 'for' '(' 'var' variableDeclarationList(true):initExpr ';' expression?:condExpr
        ';' expression?:incExpr ')' statement:stmt
      -> JSAst.For(initExpr, condExpr, incExpr, stmt)
  },
  
  forInStatement: rule {
    | 'for' '(' leftHandSideExpression:lvalue 'in' expression:subject ')' statement:stmt
      -> JSAst.ForIn(lvalue, subject, stmt)
    | 'for' '(' 'var' variableDeclaration(true):vardecl 'in' expression:subject ')' statement:stmt
      -> JSAst.ForIn(vardecl, subject, stmt)
  },

  continueStatement: rule {
    'continue' ~newline identifier?:name ';'
    -> JSAst.Continue(name)
  },

  breakStatement: rule {
    'break' ~newline identifier?:name ';'
    -> JSAst.Break(name)
  },

  returnStatement: rule {
    'return' ~newline expression?:expr ';'
    -> JSAst.Return(expr)
  },

  withStatement: rule {
    'with' '(' expression:subject ')' statement:stmt
    -> JSAst.With(subject, stmt)
  },

  switchStatement: rule {
    'switch' '(' expression:subject ')' '{' !([]):cs
    caseClause(cs)* ( defaultClause(cs) caseClause(cs)* )?
    '}'
    -> JSAst.Switch(subject, cs)
  },

  caseClause: rule (list) {
    'case' expression:subject ':' statement*:stmts
    !(list.push(JSAst.CaseClause(subject, stmts)))
  },

  defaultClause: rule (ast) {
    'default' ':' statement*:stmts
    !(ast.push(JSAst.DefaultClause(stmts)))
  },

  labelledStatement: rule {
    identifier:name ':' statement:stmt
    -> JSAst.Label(name, stmt)
  },

  throwStatement: rule {
    'throw' ~newline expression:expr ';'
    -> JSAst.Throw(expr)
  },

  tryStatement: rule {
    'try' block:blk catchClause?:c finallyClause?:f
    -> JSAst.Try(blk, c, f)
  },

  catchClause: rule {
    'catch' '(' identifier:name ')' block:blk
    -> JSAst.Catch(name, blk)
  },

  finallyClause: rule {
    'finally' block:blk
    -> JSAst.Finally(blk)
  },

  debuggerStatement: rule {
    'debugger' ';'
    -> JSAst.Debugger()
  },

  functionDeclaration: rule {
    'function' identifier:name functionArguments:args
      '{' functionBody:stmts '}'
    -> JSAst.FunctionDeclaration(name, args, stmts)
  },

  functionExpression: rule {
    'function' identifier?:name functionArguments:args
      '{' functionBody:stmts '}'
    -> JSAst.Function(name, args, stmts)
  },
  
  functionArguments: rule {
    '(' delimited[identifier, ',']:args ')' -> args
  },

  functionBody: rule {
    sourceElement*
  },

  program: rule {
    sourceElement*:stmts eof
    -> JSAst.Program(stmts)
  },

  sourceElement: rule {
    | statement
    | functionDeclaration
  },

  newline: rule {
    | peekNext:token ?(token.precededByNewline)
    | eof
  },
  
  identifier: rule {
    'identifier':id ?(!this.ReservedWords.include(id.text)) -> id.text
  },
  
  get reservedWords() {
    return String.ReservedWords;
  },
  
  identifierName: rule {
    'identifierName':id -> id.text
  },

  nextToken: function (tag) {
    var token = this.next();
    if (token.is(tag) || (token.is('identifier') && token.text === tag)) {
      return token;
    }
    else if (['/', '/='].include(tag) && ['unknown', 'regex'].include(token.type)) {
      return this.replaceNext('division');
    }
    else if (tag === 'regex' && ['unknown', 'division'].include(token.type)) {
      return this.replaceNext('regex');
    }
    else {
      this.fail();
    }
  },

});
