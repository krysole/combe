//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

var TextParser = require('../Runtime').TextParser;
var Token = require('../Runtime').Token;


var JSLexer = module.exports = Class.new(TextParser, {}, {

  nextToken: rule {
    whitespace?
  
    ( identifier
    | number
    | operatorAssignment
    | punctuation
    | string
    | &'/' createToken('unknown') // Regex and division are ambiguous
    | eof createToken('eof')
    | !{throw new Error('Not a valid token!');}
    )
  },
  
  resetToBeforeToken: function (token) {
    this.state = {
      position: token.position,
      tokenPosition: token.position,
      precededByNewline: token.precededByNewline
    };
  },
  
  resetToAfterToken: function (token) {
    this.state = {
      position: token.position + token.text.length,
      tokenPosition: token.position + token.text.length,
      precededByNewline: false
    };
  },
  
  emptyState: function () {
    return {
      position: 0,
      tokenPosition: 0,
      precededByNewline: false
    };
  },
  
  copyState: function () {
    return {
      position: this.state.position,
      tokenPosition: this.state.tokenPosition,
      precededByNewline: this.state.precededByNewline
    };
  },
  
  identifier: rule {
    firstIdChar idChar*:text
    createToken('identifier')
  },

  firstIdChar: rule {
    // Todo: handle unicode (es5 compliance)
    char('a'..'z', 'A'..'Z', '_', '$')
  },

  idChar: rule {
    // Todo: handle unicode (es5 compliance)
    char('a'..'z', 'A'..'Z', '_', '$', '0'..'9')
  },

  punctuation: rule {
    ( '{' | '}' | '(' | ')' | '[' | ']' | ';' | ',' | '.' ~digit -> '.'
    | '<<' | '>>>' | '>>' | '<=' | '>=' | '<' | '>'
    | '===' | '!==' | '==' | '!=' | '!' | '='
    | '&&' | '||' | '&' | '|' | '++' | '--' | '+' | '-'
    | '*' | '%' | '~' | '?' | ':'
    ):text
    createToken(text)
  },

  operatorAssignment: rule {
    ( '+=' | '-=' | '*=' | '%=' | '&=' | '|=' | '^='
    | '<<=' | '>>>=' | '>>='
    ):text
    createToken(text):t
    !(t.operatorAssignment = true, t.opname = text.slice(0, -1))
    -> t
  },

  division: rule {
    | '/=' createToken(text):t
      !(t.operatorAssignment = true, t.opname = text.slice(0, -1))
      -> t
    | '/' createToken(text)
  },

  number: rule {
    | decimal
    | hexInteger
  },

  decimal: rule {
    matchedInput[
      | integerPart ('.' digit*)? exponentPart?
      | '.' digit+ exponentPart?
    ]:text ~idChar
    createToken('number', parseFloat(text))
  },

  integerPart: rule {
    | '0'
    | char('1'..'9') digit*
  },

  exponentPart: rule {
    ('e'|'E') ('+'|'-'|nothing) digit+
  },

  digit: rule {
    char('0'..'9')
  },

  hexInteger: rule {
    ('0x'|'0X') matchedInput[hexDigit+]:text ~idChar
    createToken('number', parseInt(text, 16))
  },

  hexDigit: rule {
    char('0'..'9', 'a'..'f', 'A'..'F')
  },

  string: rule {
    ( stringHelper['\''] | stringHelper['\"'] ):text
    createToken('string')
  },

  stringHelper: rule (quote) {
    quote (~quote stringChar)*:characters quote
    -> characters.join('')
  },

  stringChar: rule {
    | '\\' stringEscapeSequence
    | '\\' newline -> ''
    | ~newline sourceChar
  },

  stringEscapeSequence: rule {
    | '\'' -> '\''
    | '\"' -> '\"'
    | '\\' -> '\\'
    | 'b'  -> '\b'
    | 'f'  -> '\f'
    | 'n'  -> '\n'
    | 'r'  -> '\r'
    | 't'  -> '\t'
    | 'v'  -> '\v'
    | '0' ~digit -> '\0'
    | 'x' repeat[hexDigit, %2]:hs -> String.fromCodepoint(hs.join(''))
    | 'u' repeat[hexDigit, %4]:hs -> String.fromCodepoint(hs.join(''))
    | ~(newline | digit) sourceChar
  },

  regex: rule {
    '/' matchedInput[(~'*' regexChar) regexChar*]:pattern '/' matchedInput[idChar*]:options
    createToken('regex', new RegExp(pattern, options))
  },

  regexChar: rule {
    | '\\' ~newline sourceChar
    | regexCharacterClass
    | ~('/' | newline) sourceChar
  },

  regexCharacterClass: rule {
    '[' regexCharacterClassChar ']'
  },

  regexCharacterClassChar: rule {
    | '\\' ~newline sourceChar
    | ~(']' | newline) sourceChar
  },

  whitespace: rule {
    (spaces | newline | comment)+
  },

  spaces: rule {
    char(' \t\v\f\u00a0\u200c\u200d\ufeff')+
  },

  newline: rule {
    ('\r\n' | char('\n\r\u2028\u2029'))
    !(this.state.precededByNewline = true)
  },

  comment: rule {
    ( '//' (~newline sourceChar)* (newline | eof)
    | '/*' (~'*/' sourceChar)* '*/'
    )
  },
  
  createToken: function (type, value) {
    var text = this.slice(this.state.tokenPosition, this.state.position - this.state.tokenPosition);
    
    var token = Token.new(
      type, 
      value,
      text,
      this.state.tokenPosition,
      this.state.precededByNewline,
      this.input
    );
    
    this.state.precededByNewline = false;
    this.state.tokenPosition = this.state.position;
    
    return token;
  },

});
