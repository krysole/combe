//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

var JSParser = require('./JSParser');
var Ast = require('./CombeAst');
var CombeLexer = require('./CombeLexer');

var CombeParser = module.exports = Class.new(JSParser, {
  
  parseProgram: function (string) {
    return this.parse(string, 'program');
  },
  
  parseExpression: function (string) {
    return this.parse(string, 'expression');
  },
  
  parseStatement: function (string) {
    return this.parse(string, 'statement');
  },
  
  parseSourceElement: function (string) {
    return this.parse(string, 'sourceElement');
  },
  
  parse: function (string, ruleName /* ...args */) {
    var args = Array.prototype.slice.call(arguments, 1);
    var parser = this.new(JSLexer.new(string));
    var result = parser.match.apply(parser, [ruleName].concat(args));
    if (!result) {
      if (parser.tokens.last) {
        console.log('  *JSParser Failed: Last token seen was ' + parser.tokens.last);
      }
      else {
        console.log('  *JSParser Failed: No tokens parsed');
      }
    }
    return result;
  },
  
}, {
  
  emptyState: function () {
    return {
      position: 0,
      astTemplates: false
    };
  },
  
  copyState: function () {
    return {
      position: this.state.position,
      astTemplates: this.state.astTemplates
    };
  },
  
  primaryExpression: rule {
    | %JSParser.prototype.primaryExpression
    | interpolateExpression
  },
  
  interpolateExpression: rule {
    '%' interpolationBody:body
    -> Ast.InterpolateExpression(body)
  },
  
  arrayElement: rule {
    | %JSParser.prototype.arrayElement
    | '%' 'expand' interpolationBody:body
      -> Ast.ExpandInterpolate(body)
  },

  propertyAssignment: rule {
    | %JSParser.prototype.propertyAssignment
    | 'describe' propertyName:name ':' assignmentExpression:expr
      -> Ast.DescribeProperty(name, expr)
    | '%' 'expand' interpolationBody:body
      -> Ast.ExpandInterpolate(body)
  },

  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | ruleExpression
    | 'new' memberExpression:ctor arguments:args
      -> Ast.New(ctor, args)
    ):expr
    (propertyAccessor(expr):expr)*
    -> expr
  },
  
  arguments: rule {
    '(' delimited[expandInterpolateArgument, ',']:exprs ')' -> exprs
  },
  
  expandInterpolateArgument: rule {
    | '%' 'expand' interpolationBody:body
      -> Ast.ExpandInterpolate(body)
    | assignmentExpression
  },

  prefixExpression: rule {
    %JSParser.prototype.unaryExpression
  },

  rangeInfinity: rule {
    '*' -> Ast.RangeInfinity()
  },

  rangeOperator: rule (ast) {
    | '..' (rangeInfinity | prefixExpression):rhs
      -> Ast.InclusiveRange(ast, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast.ExclusiveRange(ast, rhs)
  },

  unaryExpression: rule {
    ( rangeInfinity:expr rangeOperator(expr):expr
    | prefixExpression:expr
    )
    (rangeOperator(expr):expr)*
    -> expr
  },

  expressionNoInFlag: rule (noIn) {
    delimited1[expandInterpolateExpression, ',']:exprs
    ( ?(exprs.length === 1 && exprs[0].is('ExpandInterpolateExpression'))
      -> Ast.Sequence(exprs)
    | ?(exprs.length === 1)
      -> exprs[0]
    | -> Ast.Sequence(exprs)
    )
  },
  
  expandInterpolateExpression: rule (noIn) {
    | '%' 'expand' interpolationBody:body
      -> Ast.ExpandInterpolate(body)
    | assignmentExpression(noIn)
  },
  
  statement: rule {
    | (%JSParser.prototype.statement)
    | interpolateStatements
  },
  
  interpolateStatements: rule {
    '%' 'statements' interpolationBody:body
    -> Ast.InterpolateStatements(body)
  },
  
  variableDeclarationList: rule (noIn) {
    delimited1[expandInterpolateVariableDeclaration(noIn), ',']:lst
  },
  
  expandInterpolateVariableDeclaration: rule (noIn) {
    | '%' 'expand' interpolationBody:body
      -> Ast.ExpandInterpolate(body)
    | variableDeclaration(noIn)
  },

  expressionStatement: rule {
    ~('{'|'function'|'rule') expression:expr ';'
    -> Ast.ExpressionStatement(expr)
  },
  
  functionArguments: rule {
    '(' delimited[expandInterpolateFunctionArgument, ',']:args ')' -> args
  },
  
  expandInterpolateFunctionArgument: rule {
    | '%' 'expand' interpolationBody:body
      -> Ast.ExpandInterpolate(body)
    | identifier:name -> name.identifierName
  },

  sourceElement: rule {
    | %JSParser.prototype.sourceElement
    | ruleDeclaration
  },
  
  identifier: rule {
    | 'identifier':name ?(!this.ReservedWords.include(name.text)) -> name.text
    | '%' 'id' interpolationBody:body
      -> Ast.InterpolateIdentifier(body)
  },
  
  get ReservedWords() {
    if (this._ReservedWords == null) {
      this._ReservedWords = String.ReservedWords.concat([
        'rule', '__ast'
      ]);
    }
    return this._ReservedWords;
  },
  
  identifierName: rule {
    | 'identifier':name -> name.text
    | '%' 'id' interpolationBody:body
      -> Ast.InterpolateIdentifier(body)
  },

  ruleExpression: rule {
    'rule' identifier?:name functionArguments?:args
    '{' optionalPattern:ptn '}'
    -> Ast.Rule(name, args, ptn)
  },

  optionalPattern: rule {
    | choicePattern
    | '|'? -> Ast.EmptyPattern()
  },

  pattern: rule {
    choicePattern
  },

  choicePattern: rule {
    '|'? returnPattern:ptn
    ( ('|' returnPattern)+:ptns 
      !(ptn = Ast.ChoicePattern([ptn].concat(ptns)))
    )?
    ( '|'
      !(ptn.push(Ast.EmptyPattern()))
    )?
    -> ptn
  },

  returnPattern: rule {
    | concatPattern:ptn
      ( '->' leftHandSideExpression:expr
        -> Ast.ConcatPatttern([ptn, Ast.Action(Ast.ExpressionBody(expr))])
      | '->' '{' statement*:stmts '}'
        -> Ast.ConcatPattern([ptn, Ast.Action(Ast.StatementsBody(stmts))])
      | -> ptn
      )
    | '->' leftHandSideExpression:expr -> Ast.Action(Ast.ExpressionBody(expr))
    | '->' '{' statement*:stmts '}' -> Ast.Action(Ast.StatementsBody(stmts))
  },

  concatPattern: rule {
    prefixOperatorPattern:ptn
    ( prefixOperatorPattern+:ptns -> Ast.ConcatPattern([ptn].concat(ptns))
    | -> ptn
    )
  },

  prefixOperatorPattern: rule {
    | postfixOperatorPattern
    | '~' prefixOperatorPattern:ptn -> Ast.NotPattern(ptn)
    | '&' prefixOperatorPattern:ptn -> Ast.LookaheadPattern(ptn)
    | '#' prefixOperatorPattern:ptn -> Ast.TokenOperatorPattern(ptn)
  },

  postfixOperatorPattern: rule {
    | applyPattern:ptn ( repeatOperatorPattern(ptn):ptn )*
      -> ptn
    | ':' ~whitespace identifier:name
      -> Ast.BindPattern(name, Ast.AnythingPattern())
  },

  repeatOperatorPattern: rule (ptn) {
    ( '*' -> Ast.RepeatPattern(ptn)
    | '+' -> Ast.Repeat1Pattern(ptn)
    | '?' ~( ~whitespace ('('|'{') )
      -> Ast.OptionalPattern(ptn)
    | ~whitespace ':' ~whitespace identifier:name
      -> Ast.BindPattern(name, ptn)
    )
  },

  applyPattern: rule {
    primaryPattern:ptn
    ( ~whitespace arguments:args
      !(ptn = Ast.JSApplyPattern(ptn, args))
    | ~whitespace patternArguments:args
      !(ptn = Ast.ApplyPattern(ptn, args))
    )*
    -> ptn
  },

  patternArguments: rule {
    '[' delimited[pattern, ',']:args ']' -> args
  },

  primaryPattern: rule {
    | predicatePattern
    | actionPattern
    | immediatePattern
    | literalPattern
    | variablePattern
    | '(' pattern:ptn ')' -> ptn
  },

  predicatePattern: rule {
    '?' ~whitespace interpolationBody:body
    -> Ast.PredicatePattern(body)
  },

  actionPattern: rule {
    '!' ~whitespace interpolationBody:body
    -> Ast.ActionPattern(body)
  },

  immediatePattern: rule {
    | '%' ~whitespace leftHandSideExpression:expr
      -> Ast.ImmediatePattern(Ast.ExpressionBody(expr))
    | '%' ~whitespace interpolationBody:body
      -> Ast.ImmediatePattern(body)
  },

  literalPattern: rule {
    | ( 'null' | 'boolean' | 'regex' | 'undefined' ) error('Not a valid literal pattern')
    | 'number':n -> Ast.NumberPattern(n.value)
    | 'string':s -> Ast.StringPattern(s.value)
  },

  variablePattern: rule {
    identifier:name -> Ast.VariablePattern(name)
  },
  
  astTemplateExpression: rule {
    '__ast' interpolationBody:body
    -> Ast.AstTemplate(body)
  },
  
  interpolationBody: rule {
    | '(' expression:expr ')'
      -> Ast.ExpressionBody(expr)
    | '{' functionBody:stmts '}'
      -> Ast.StatementsBody(stmts)
  },
  
  whitespace: function () {
    if (this.state.position === 0) {
      return null;
    }
    else if (this.isEof()) {
      return null;
    }
    else {
      var last = this.tokenAt(this.state.position - 1);
      var curr = this.peekNext();
      if (last.position + last.text.length < curr.position) {
        return null;
      }
      else {
        return this.fail();
      }
    }
  },

});
