//
// Combe/JS - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

var JSParser = require('./jsparser');
var Ast = require('./ast');

var CombeJSParser = module.exports = class CombeJSParser (JSParser) {
  
  propertyAssignment: rule {
    | %JSParser.prototype.propertyAssignment
    | 'describe' propertyName:name ':' assignmentExpression:expr
      -> Ast('DescribePropertyDeclaration', {name: name}, expr)
  },
  
  memberExpression: rule {
    ( primaryExpression
    | functionExpression
    | classExpression
    | ruleExpression
    | 'new' memberExpression:ctor arguments:args
      -> Ast('New', {}, ctor).concat(args)
    ):expr
    (propertyAccessor(expr):expr)*
    -> expr
  },
  
  prefixExpression: rule {
    %JSParser.prototype.unaryExpression
  },
  
  rangeInfinity: rule {
    '*' -> Ast('RangeInfinity')
  },
  
  rangeOperator: rule (ast) {
    | '..' (rangeInfinity | prefixExpression):rhs
      -> Ast('InclusiveRange', {}, ast, rhs)
    | '...' (rangeInfinity | prefixExpression):rhs
      -> Ast('ExclusiveRange', {}, ast, rhs)
  },
  
  unaryExpression: rule {
    ( rangeInfinity:expr rangeOperator(expr):expr
    | prefixExpression:expr
    )
    (rangeOperator(expr):expr)*
    -> expr
  },
  
  statement: rule {
    | %JSParser.prototype.statement
    | matchStatement
  },
  
  expressionStatement: rule {
    ~('{'|'function'|'rule'|'class') expression:expr ';'
    -> Ast('ExpressionStatement', {}, expr)
  },
  
  sourceElement: rule {
    | %JSParser.prototype.sourceElement
    | classDeclaration
    | ruleDeclaration
  },
  
  matchStatement: rule {
    'match' '(' expression:subject ')' '{' pattern:ptn '}'
    -> Ast('MatchStatement', {}, subject, ptn)
  },
  
  classDeclaration: rule {
    'class' 'identifier':name ('(' expression:inherits ')')?
      '{' delimited[propertyAssignment, ',']:pdefs ','? '}'
    -> Ast('ClassDeclaration', {name: name.value}, inherits).concat(pdefs)
  },
  
  classExpression: rule {
    'class' 'identifier'?:name ('(' expression:inherits ')')?
      '{' delimited[propertyAssignment, ',']:pdefs ','? '}'
    -> Ast('ClassExpression', {name: (name ? name.value :null)}, inherits).concat(pdefs)
  },
  
  ruleDeclaration: rule {
    'rule' 'identifier':name ('(' delimited['identifier', ',']:args ')')?
      '{' pattern:ptn '}'
    !(args ? args.map(function (elem) {return elem.value;}) : []):args
    -> Ast('RuleDeclaration', {name: name.value, argumentNames: args}, ptn)
  },
  
  ruleExpression: rule {
    'rule' 'identifier'?:name ('(' delimited['identifier', ',']:args ')')?
      '{' pattern:ptn '}'
    !(args ? args.map(function (elem) {return elem.value;}) : []):args
    -> Ast('RuleExpression', {name: (name ? name.value : null), argumentNames: args}, ptn)
  },
  
  pattern: rule {
    choicePattern
  },
  
  choicePattern: rule {
    '|'? returnPattern:ptn
    ( ('|' returnPattern)+:ptns -> Ast('ChoicePattern', {}, ptn).concat(ptns)
    | -> ptn
    )
  },
  
  returnPattern: rule {
    | concatPattern:ptn
      ( '->' leftHandSideExpression:expr
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionExpressionPattern', {}, expr))
      | '->' '{' statement*:stmts '}'
        -> Ast('ConcatPattern', {}, ptn, Ast('ActionBlockPattern').concat(stmts))
      | -> ptn
      )
    | '->' leftHandSideExpression:expr -> Ast('ActionExpressionPattern', {}, expr)
    | '->' '{' statement*:stmts '}' -> Ast('ActionBlockPattern').concat(stmts)
  },
  
  concatPattern: rule {
    bindPattern:ptn
    ( bindPattern+:ptns -> Ast('ConcatPattern', {}, ptn).concat(ptns)
    | -> ptn
    )
  },
  
  // Todo: Move the bind operator to the same level as the repeat patterns, 
  // since any usage of the arity operators could easily be before _or_ after
  // binding it to a variable. We can simply read the operators left to right...
  bindPattern: rule {
    | prefixOperatorPattern:ptn
      ( ~whitespace ':' 'identifier':name
        -> Ast('BindPattern', {name: name.value}, ptn)
      | -> ptn
      )
    | ':' 'identifier':name
      -> Ast('BindPattern', {name: name.value}, Ast('AnythingPattern'))
  },
  
  prefixOperatorPattern: rule {
    | repeatPattern
    | '~' prefixOperatorPattern:ptn -> Ast('NotPattern', {}, ptn)
    | '&' prefixOperatorPattern:ptn -> Ast('LookaheadPattern', {}, ptn)
    | '#' prefixOperatorPattern:ptn -> Ast('TokenOperatorPattern', {}, ptn)
  },
  
  repeatPattern: rule {
    applyPattern:ptn
    ( '*' -> Ast('RepeatPattern', {}, ptn)
    | '+' -> Ast('Repeat1Pattern', {}, ptn)
    | '?' ~( ~whitespace ('('|'{') ) -> Ast('OptionalPattern', {}, ptn)
    | -> ptn
    )
  },
  
  applyPattern: rule {
    primaryPattern:ptn
    ( ~whitespace arguments:args
      !(ptn = Ast('JSApplyPattern', {}, ptn).concat(args))
    | ~whitespace patternArguments:args
      !(ptn = Ast('ApplyPattern', {}, ptn).concat(args))
    )*
    -> ptn
  },
  
  patternArguments: rule {
    '[' delimited[pattern, ',']:args ']' -> args
  },
  
  primaryPattern: rule {
    | predicatePattern
    | actionPattern
    | immediatePattern
    | literalPattern
    | variablePattern
    | '(' pattern:ptn ')' -> ptn
  },
  
  predicatePattern: rule {
    | '?' ~whitespace '(' expression:expr ')'
      -> Ast('PredicateExpressionPattern', {}, expr)
    | '?' ~whitespace '{' statement*:stmts '}'
      -> Ast('PredicateBlockPattern').concat(stmts)
  },
  
  actionPattern: rule {
    | '!' ~whitespace '(' expression:expr ')'
      -> Ast('ActionExpressionPattern', {}, expr)
    | '!' ~whitespace '{' statement*:stmts '}'
      -> Ast('ActionBlockPattern').concat(stmts)
  },
  
  immediatePattern: rule {
    | '%' leftHandSideExpression:expr
      -> Ast('ImmediateExpressionPattern', {}, expr)
    | '%' ~whitespace '{' statement*:stmts '}'
      -> Ast('ImmediateBlockPattern').concat(stmts)
  },
  
  literalPattern: rule {
    ( valueLiteral
    | 'undefined' -> Ast('ValueLiteral', {value: undefined})
    ):expr
    -> Ast('ImmediateExpressionPattern', {}, expr)
  },
  
  variablePattern: rule {
    'identifier':name -> Ast('VariablePattern', {name: name.value})
  },
  
  whitespace: rule {
    | &anything:token ?(!token.previousToken || token.previousToken.is('whitespace'))
    | eof
  },
  
};
