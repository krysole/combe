#!/usr/bin/env node
//
// Combe - A Parsing Language for JavaScript
//
// Copyright 2011 Lorenz Pretterhofer
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

var combe = require('combe');

var ensure = function (value) {
  assert(value != null);
  assert(value !== '');
  return value;
};

setTimeout(function () {
  if (process.argv.length <= 2) {
    console.error('Usage: newlang [-c] sourceFile');
    process.exit(1);
  }
  
  var options = {};
  var argv = [].pushAll(process.argv);
  var node = argv.shift();
  var command = argv.shift();
  while (!argv.isEmpty()) {
    var arg = argv.shift();
    
    if (arg == null || arg === '') {
      continue;
    }
    else if (arg.match(/^(-c|--compile)$/)) {
      assert(!options.execute);
      options.compile = true;
      options.source = ensure(argv.shift());
    }
    else if (arg.match(/^(-o|--output|--out)$/)) {
      options.output = ensure(argv.shift());
    }
    else if (arg.match(/^(-e|--execute|--exec)$/)) {
      assert(!options.compile);
      options.execute = true;
      options.source = ensure(argv.shift());
    }
    else if (arg.match(/^(--all-intermediates)$/)) {
      if (options.compilerIntermediates != null) {
        options.compilerIntemediates.all = true;
      }
      else {
        options.compilerIntermediates = { all: true };
      }
    }
    else if (arg.match(/^(--ast)$/)) {
      if (options.compilerIntermediates == null) {
        options.compilerIntermediates = {};
      }
      options.compilerIntermediates.ast = true;
    }
    else if (arg.match(/^(--no-cache)$/)) {
      options.noCache = true;
    }
    else if (arg.match(/^--$/)) {
      assert(!options.compile);
      if (!options.execute) {
        options.execute = true;
        options.source = ensure(argv.shift());
      }
      options.argv = argv;
      break;
    }
    else if (arg.match(/^-/)) {
      if (options.execute) {
        options.argv.push(arg);
      }
      else {
        console.error('unsupported argument: ' + arg);
        process.exit(1);
      }
    }
    else {
      assert(!options.compile);
      if (options.execute) {
        options.argv.push(arg);
      }
      else {
        options.execute = true;
        options.source = arg;
        options.argv = [];
      }
    }
  }
  
  
  if (options.compile) {
    var Compiler = require('combe/lib/newlang/Compiler');
    
    var output = options.output;
    if (output == null) {
      output = options.source + '.js';
    }
    if (options.noCache) {
      output = null;
    }
    
    Compiler.compileFile(options.source, output, options.compilerIntermediates);
  }
  else if (options.execute) {
    var Runtime = require('combe/lib/newlang/Runtime');
    
    assert(options.output == null);
    NewlangRuntime.cacheCompilerOutput = !options.noCache;
    NewlangRuntime.execute(options.source);
  }
  else {
    console.error('Usage: newlang [-c] sourceFile');
    process.exit(1);
  }
}, 0);
